# -*- coding: utf-8 -*-
# Этот файл сгенерирован автоматически.
# Содержит дерево проекта и файлы (.go, .json, .mod, .md) в экранированном виде.

project_tree = '''
.
├── client.go
├── commands_check.go
├── commands_do.go
├── commands_get.go
├── commands_ofd.go
├── commands_reg.go
├── commands_set.go
├── commands_shift.go
├── errors.go
├── pack_go_files.py
├── transport.go
└── types.go
'''

project_files = {
    "client.go": "package mitsu\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Client интерфейс определяет базовые методы для взаимодействия с ККТ Mitsu\ntype Client interface {\n\t// Connect устанавливает соединение с устройством\n\tConnect() error\n\n\t// Disconnect разрывает соединение с устройством\n\tDisconnect() error\n\n\t// SendCommand отправляет XML-команду устройству и возвращает ответ\n\tSendCommand(ctx context.Context, xmlCmd string) ([]byte, error)\n\n\t// --- Получение информации (раздел 3) ---\n\t// GetDev запрашивает модель ККТ (См. п. 3.3)\n\tGetDev(ctx context.Context) (*DevResponse, error)\n\t// GetVer запрашивает версию ПО, серийный номер и MAC-адрес (См. п. 3.4)\n\tGetVer(ctx context.Context) (*VerResponse, error)\n\t// GetDateTime запрашивает текущую дату и время ККТ (См. п. 3.5)\n\tGetDateTime(ctx context.Context) (*DateTimeResponse, error)\n\t// GetCashier запрашивает данные кассира (См. п. 3.6)\n\tGetCashier(ctx context.Context) (*CashierResponse, error)\n\t// GetPrinterSettings запрашивает настройки принтера (См. п. 3.7)\n\tGetPrinterSettings(ctx context.Context) (*PrinterSettings, error)\n\t// GetMoneyDrawerSettings запрашивает настройки денежного ящика (См. п. 3.8)\n\tGetMoneyDrawerSettings(ctx context.Context) (*DrawerSettings, error)\n\t// GetComSettings запрашивает настройки COM-порта (См. п. 3.9)\n\tGetComSettings(ctx context.Context) (*ComSettingsResponse, error)\n\t// GetHeader запрашивает заголовок (См. п. 3.10)\n\tGetHeader(ctx context.Context, n int) (*HeaderResponse, error)\n\t// GetLanSettings запрашивает настройки LAN (См. п. 3.11)\n\tGetLanSettings(ctx context.Context) (*LanSettings, error)\n\t// GetOfdSettings запрашивает настройки ОФД (См. п. 3.12)\n\tGetOfdSettings(ctx context.Context) (*OfdSettings, error)\n\t// GetOismSettings запрашивает настройки OISM (См. п. 3.13)\n\tGetOismSettings(ctx context.Context) (*OismSettings, error)\n\t// GetOkpSettings запрашивает настройки OKP (См. п. 3.14)\n\tGetOkpSettings(ctx context.Context) (*ServerSettings, error)\n\t// GetTaxRates запрашивает налоговые ставки (См. п. 3.15)\n\tGetTaxRates(ctx context.Context) (*TaxRates, error)\n\t// GetRegistrationData запрашивает данные о регистрации ККТ (См. п. 3.16)\n\tGetRegistrationData(ctx context.Context) (*RegData, error)\n\t// GetStatus получает статус ККТ (INFO='0')\n\tGetStatus(ctx context.Context) (*ShiftStatus, error)\n\t// GetShiftTotals получает итоги смены (INFO='1')\n\tGetShiftTotals(ctx context.Context) (*ShiftTotals, error)\n\t// GetFnStatus получает статус фискального накопителя (INFO='F')\n\tGetFnStatus(ctx context.Context) (*FnStatus, error)\n\t// GetOfdExchangeStatus получает статус обмена с ОФД (INFO='O')\n\tGetOfdExchangeStatus(ctx context.Context) (*OfdExchangeStatus, error)\n\t// GetMarkingStatus получает статус маркировки (INFO='M')\n\tGetMarkingStatus(ctx context.Context) (*MarkingStatus, error)\n\t// GetPowerStatus запрашивает статус питания (См. п. 3.33)\n\tGetPowerStatus(ctx context.Context) (*PowerStatusResponse, error)\n\t// GetTimezone запрашивает часовой пояс (См. п. 3.35)\n\tGetTimezone(ctx context.Context) (*TimezoneResponse, error)\n\t// GetOptions запрашивает все опции устройства (См. п. 4.13)\n\tGetOptions(ctx context.Context) (*DeviceOptions, error)\n\t// GetCurrentDocumentType получает тип текущего документа\n\tGetCurrentDocumentType(ctx context.Context) (*CurrentDocumentTypeResponse, error)\n\t// GetDocumentInfoFromFN получает информацию о документе (OFFSET и LENGTH) по номеру FD\n\tGetDocumentInfoFromFN(ctx context.Context, fd int) (*DocumentInfoResponse, error)\n\t// ReadBlock читает блок данных из памяти ФН по OFFSET и LENGTH\n\tReadBlock(ctx context.Context, offset int64, length int) (*ReadBlockResponse, error)\n\n\t// --- Установка настроек (раздел 4) ---\n\t// SetDateTime устанавливает дату и время ККТ (См. п. 4.3)\n\tSetDateTime(ctx context.Context, t time.Time) error\n\t// SetCashier устанавливает данные кассира (См. п. 4.4)\n\tSetCashier(ctx context.Context, name string, inn string) error\n\t// SetComSettings устанавливает настройки COM-порта (См. п. 4.5)\n\tSetComSettings(ctx context.Context, speed int32) error\n\t// SetPrinterSettings устанавливает настройки принтера (См. п. 4.6)\n\tSetPrinterSettings(ctx context.Context, s PrinterSettings) error\n\t// SetMoneyDrawerSettings устанавливает настройки денежного ящика (См. п. 4.7)\n\tSetMoneyDrawerSettings(ctx context.Context, s DrawerSettings) error\n\t// SetHeader устанавливает клише и подвала (См. п. 4.8)\n\tSetHeader(ctx context.Context, headerNum int, lines []ClicheLineData) error\n\t// SetHeaderLine устанавливает одну строку клише (См. п. 4.8)\n\tSetHeaderLine(ctx context.Context, headerNum int, lineNum int, text string, format string) error\n\t// SetLanSettings устанавливает настройки LAN (См. п. 4.9)\n\tSetLanSettings(ctx context.Context, s LanSettings) error\n\t// SetOfdSettings устанавливает настройки ОФД (См. п. 4.10)\n\tSetOfdSettings(ctx context.Context, s OfdSettings) error\n\t// SetOismSettings устанавливает настройки OISM (См. п. 4.11)\n\tSetOismSettings(ctx context.Context, s ServerSettings) error\n\t// SetOkpSettings устанавливает настройки OKP (См. п. 4.12)\n\tSetOkpSettings(ctx context.Context, s ServerSettings) error\n\t// SetOption устанавливает одну опцию устройства (См. п. 4.13)\n\tSetOption(ctx context.Context, optionNum int, value int) error\n\t// SetPowerFlag устанавливает флаг питания (См. п. 4.14)\n\tSetPowerFlag(ctx context.Context, value int) error\n\t// SetTimezone устанавливает часовой пояс (Добавлено в FW 1.2.18)\n\tSetTimezone(ctx context.Context, value int) error\n\t// TechReset выполняет технологическое обнуление устройства\n\tTechReset(ctx context.Context) error\n\n\t// --- Регистрация (раздел 5) ---\n\t// Register выполняет первичную регистрацию ККТ (5.1)\n\tRegister(ctx context.Context, req RegistrationRequest) (*RegResponse, error)\n\t// Reregister выполняет перерегистрацию ККТ (5.2)\n\tReregister(ctx context.Context, req RegistrationRequest, reasons []int) (*RegResponse, error)\n\t// CloseFiscalArchive закрывает фискальный режим (5.4)\n\tCloseFiscalArchive(ctx context.Context) (*CloseFnResult, error)\n\n\t// --- Смена (раздел 6) ---\n\t// OpenShift открывает смену\n\tOpenShift(ctx context.Context, operator string) error\n\t// CloseShift закрывает смену\n\tCloseShift(ctx context.Context, operator string) error\n\t// PrintXReport печатает X-отчет\n\tPrintXReport(ctx context.Context) error\n\t// PrintZReport печатает отчет по расчетам (не закрывает смену!)\n\tPrintZReport(ctx context.Context) error\n\n\t// --- Чеки (раздел 7) ---\n\t// OpenCheck открывает чек\n\tOpenCheck(ctx context.Context, checkType int, taxSystem int) error\n\t// AddPosition добавляет позицию в чек\n\tAddPosition(ctx context.Context, pos ItemPosition) error\n\t// Subtotal рассчитывает промежуточный итог\n\tSubtotal(ctx context.Context) error\n\t// Payment производит оплату\n\tPayment(ctx context.Context, pay PaymentInfo) error\n\t// CloseCheck закрывает чек\n\tCloseCheck(ctx context.Context) error\n\t// CancelCheck отменяет чек\n\tCancelCheck(ctx context.Context) error\n\t// OpenCorrectionCheck открывает чек коррекции\n\tOpenCorrectionCheck(ctx context.Context, checkType int, taxSystem int) error\n\n\t// --- Другие операции ---\n\t// RebootDevice перезапускает устройство\n\tRebootDevice(ctx context.Context) error\n\t// PrintDiagnostics печатает диагностическую информацию\n\tPrintDiagnostics(ctx context.Context) error\n\t// DeviceJob выполняет задачу устройства\n\tDeviceJob(ctx context.Context, job int) error\n\t// Feed проматывает бумагу на указанное количество строк\n\tFeed(ctx context.Context, lines int) error\n\t// Cut выполняет отрезку чека\n\tCut(ctx context.Context) error\n\t// PrintLastDocument печатает последний сформированный документ (копию)\n\tPrintLastDocument(ctx context.Context) error\n\t// ResetMGM сбрасывает флаг МГМ\n\tResetMGM(ctx context.Context) error\n\n\t// --- ОФД ---\n\t// OfdBeginRead начинает процедуру чтения первого непереданного документа для отправки в ОФД\n\tOfdBeginRead(ctx context.Context) (int, error)\n\t// OfdReadBlock считывает блок сообщения заданной длины, начиная с заданной позиции\n\tOfdReadBlock(ctx context.Context, offset, length int) ([]byte, int, error)\n\t// OfdEndRead завершает чтение документа\n\tOfdEndRead(ctx context.Context) error\n\t// OfdLoadReceipt записывает квитанцию от ОФД в ФН\n\tOfdLoadReceipt(ctx context.Context, receipt []byte) error\n\t// OfdCancelRead отменяет чтение документа\n\tOfdCancelRead(ctx context.Context) error\n\t// OfdReadFullDocument читает полный документ для отправки в ОФД\n\tOfdReadFullDocument(ctx context.Context) ([]byte, error)\n}\n\n// mitsuClient реализует интерфейс Client для работы с ККТ Mitsu\ntype mitsuClient struct {\n\ttransport *Transport\n\tconfig    Config\n}\n\n// NewClient создаёт новый экземпляр Client с заданной конфигурацией подключения\nfunc NewClient(config Config) Client {\n\ttransport := NewTransport(config)\n\treturn &mitsuClient{\n\t\ttransport: transport,\n\t\tconfig:    config,\n\t}\n}\n\n// Connect устанавливает соединение с устройством\nfunc (c *mitsuClient) Connect() error {\n\tif c.transport == nil {\n\t\treturn fmt.Errorf(\"транспорт не инициализирован\")\n\t}\n\treturn c.transport.Connect()\n}\n\n// Disconnect разрывает соединение с устройством\nfunc (c *mitsuClient) Disconnect() error {\n\tif c.transport == nil {\n\t\treturn fmt.Errorf(\"транспорт не инициализирован\")\n\t}\n\treturn c.transport.Disconnect()\n}\n\n// SendCommand отправляет XML-команду устройству и возвращает ответ\nfunc (c *mitsuClient) SendCommand(ctx context.Context, xmlCmd string) ([]byte, error) {\n\t// Проверка контекста на отмену\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\tif c.transport == nil {\n\t\treturn nil, fmt.Errorf(\"транспорт не инициализирован\")\n\t}\n\n\t// Отправка команды через транспорт\n\tresp, err := c.transport.Send(xmlCmd, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка отправки команды: %w\", err)\n\t}\n\n\treturn resp, nil\n}\n",
    "commands_check.go": "package mitsu\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// ItemPosition представляет позицию в чеке\ntype ItemPosition struct {\n\tName     string\n\tQuantity float64\n\tPrice    float64\n\tTax      int\n}\n\n// PaymentInfo представляет информацию об оплате\ntype PaymentInfo struct {\n\tType int     // 0 - наличные, 1 - безналичные, 2 - аванс, 3 - кредит, 4 - иная\n\tSum  float64 // сумма оплаты\n}\n\n// OpenCheck открывает чек\nfunc (c *mitsuClient) OpenCheck(ctx context.Context, checkType int, taxSystem int) error {\n\tcmd := fmt.Sprintf(\"<Do CHECK='OPEN' TYPE='%d' TAX='%d' MERGE='0'/>\", checkType, taxSystem)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// AddPosition добавляет позицию в чек\nfunc (c *mitsuClient) AddPosition(ctx context.Context, pos ItemPosition) error {\n\ttaxMap := map[int]int{\n\t\t0: 6, // Без НДС\n\t\t1: 1, // 20%\n\t\t2: 2, // 10%\n\t\t3: 3, // 20/120\n\t\t4: 4, // 10/110\n\t\t5: 5, // 0%\n\t\t6: 6, // Без НДС\n\t}\n\ttax := taxMap[pos.Tax]\n\tif tax == 0 {\n\t\ttax = 6 // по умолчанию Без НДС\n\t}\n\n\ttotal := pos.Price * pos.Quantity\n\tsafeName := escapeXMLText(pos.Name)\n\n\tcmd := fmt.Sprintf(\"<ADD ITEM='%.3f' TAX='%d' UNIT='0' PRICE='%.2f' TOTAL='%.2f' TYPE='1' MODE='4'><NAME>%s</NAME></ADD>\",\n\t\tpos.Quantity, tax, pos.Price, total, safeName)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// Subtotal рассчитывает промежуточный итог\nfunc (c *mitsuClient) Subtotal(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<Do CHECK='TOTAL'/>\")\n\treturn err\n}\n\n// Payment производит оплату\nfunc (c *mitsuClient) Payment(ctx context.Context, pay PaymentInfo) error {\n\tvar pa, pb, pc, pd, pe float64\n\tswitch pay.Type {\n\tcase 0: // наличные\n\t\tpa = pay.Sum\n\tcase 1: // безналичные\n\t\tpb = pay.Sum\n\tcase 2: // аванс\n\t\tpc = pay.Sum\n\tcase 3: // кредит\n\t\tpd = pay.Sum\n\tcase 4: // иная\n\t\tpe = pay.Sum\n\tdefault:\n\t\tpb = pay.Sum // по умолчанию безналичные\n\t}\n\n\tcmd := fmt.Sprintf(\"<Do CHECK='PAY' PA='%.2f' PB='%.2f' PC='%.2f' PD='%.2f' PE='%.2f'/></Do>\",\n\t\tpa, pb, pc, pd, pe)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// CloseCheck закрывает чек\nfunc (c *mitsuClient) CloseCheck(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<Do CHECK='END'/>\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.SendCommand(ctx, \"<Do CHECK='CLOSE'/>\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.SendCommand(ctx, \"<PRINT/>\")\n\treturn err\n}\n\n// CancelCheck отменяет чек\nfunc (c *mitsuClient) CancelCheck(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<Do CHECK='CANCEL'/>\")\n\treturn err\n}\n\n// OpenCorrectionCheck открывает чек коррекции\nfunc (c *mitsuClient) OpenCorrectionCheck(ctx context.Context, checkType int, taxSystem int) error {\n\tcmd := fmt.Sprintf(\"<Do CHECK='CORR' TYPE='%d' TAX='%d'/>\", checkType, taxSystem)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n",
    "commands_do.go": "package mitsu\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// RebootDevice перезапускает устройство\nfunc (c *mitsuClient) RebootDevice(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<DEVICE JOB='0'/>\")\n\treturn err\n}\n\n// PrintDiagnostics печатает диагностическую информацию\nfunc (c *mitsuClient) PrintDiagnostics(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<MAKE REPORT='X'/>\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.SendCommand(ctx, \"<PRINT/>\")\n\treturn err\n}\n\n// DeviceJob выполняет задачу устройства\nfunc (c *mitsuClient) DeviceJob(ctx context.Context, job int) error {\n\tcmd := fmt.Sprintf(\"<DEVICE JOB='%d'/>\", job)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// Feed проматывает бумагу на указанное количество строк\nfunc (c *mitsuClient) Feed(ctx context.Context, lines int) error {\n\tcmd := fmt.Sprintf(\"<FEED N='%d'/>\", lines)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// Cut выполняет отрезку чека\nfunc (c *mitsuClient) Cut(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<CUT/>\")\n\treturn err\n}\n\n// PrintLastDocument печатает последний сформированный документ (копию)\nfunc (c *mitsuClient) PrintLastDocument(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<PRINT/>\")\n\treturn err\n}\n\n// ResetMGM сбрасывает флаг МГМ\nfunc (c *mitsuClient) ResetMGM(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<MAKE FISCAL='RESET'/>\")\n\treturn err\n}\n",
    "commands_get.go": "package mitsu\n\nimport (\n\t\"context\"\n\t\"encoding/xml\"\n\t\"fmt\"\n)\n\n// GetDev запрашивает модель ККТ (См. п. 3.3)\nfunc (c *mitsuClient) GetDev(ctx context.Context) (*DevResponse, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET DEV='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r DevResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа DEV: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetVer запрашивает версию ПО, серийный номер и MAC-адрес (См. п. 3.4)\nfunc (c *mitsuClient) GetVer(ctx context.Context) (*VerResponse, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET VER='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r VerResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа VER: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetDateTime запрашивает текущую дату и время ККТ (См. п. 3.5)\nfunc (c *mitsuClient) GetDateTime(ctx context.Context) (*DateTimeResponse, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET DATE='?' TIME='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r DateTimeResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа DATE/TIME: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetCashier запрашивает данные кассира (См. п. 3.6)\nfunc (c *mitsuClient) GetCashier(ctx context.Context) (*CashierResponse, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET CASHIER='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r CashierResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа CASHIER: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetPrinterSettings запрашивает настройки принтера (См. п. 3.7)\nfunc (c *mitsuClient) GetPrinterSettings(ctx context.Context) (*PrinterSettings, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET PRINTER='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s PrinterSettings\n\tif err := xml.Unmarshal(resp, &s); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа PRINTER: %w\", err)\n\t}\n\n\treturn &s, nil\n}\n\n// GetMoneyDrawerSettings запрашивает настройки денежного ящика (См. п. 3.8)\nfunc (c *mitsuClient) GetMoneyDrawerSettings(ctx context.Context) (*DrawerSettings, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET CD='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s DrawerSettings\n\tif err := xml.Unmarshal(resp, &s); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа CD: %w\", err)\n\t}\n\n\treturn &s, nil\n}\n\n// GetComSettings запрашивает настройки COM-порта (См. п. 3.9)\nfunc (c *mitsuClient) GetComSettings(ctx context.Context) (*ComSettingsResponse, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET COM='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r ComSettingsResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа COM: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetHeader запрашивает заголовок (См. п. 3.10)\nfunc (c *mitsuClient) GetHeader(ctx context.Context, n int) (*HeaderResponse, error) {\n\tcmd := fmt.Sprintf(\"<GET HEADER='%d'/>\", n)\n\tresp, err := c.SendCommand(ctx, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r HeaderResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа HEADER: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetLanSettings запрашивает настройки LAN (См. п. 3.11)\nfunc (c *mitsuClient) GetLanSettings(ctx context.Context) (*LanSettings, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET LAN='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s LanSettings\n\tif err := xml.Unmarshal(resp, &s); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа LAN: %w\", err)\n\t}\n\n\treturn &s, nil\n}\n\n// GetOfdSettings запрашивает настройки ОФД (См. п. 3.12)\nfunc (c *mitsuClient) GetOfdSettings(ctx context.Context) (*OfdSettings, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET OFD='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s OfdSettings\n\tif err := xml.Unmarshal(resp, &s); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа OFD: %w\", err)\n\t}\n\n\treturn &s, nil\n}\n\n// GetOismSettings запрашивает настройки OISM (См. п. 3.13)\nfunc (c *mitsuClient) GetOismSettings(ctx context.Context) (*OismSettings, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET OISM='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s OismSettings\n\tif err := xml.Unmarshal(resp, &s); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа OISM: %w\", err)\n\t}\n\n\treturn &s, nil\n}\n\n// GetOkpSettings запрашивает настройки OKP (См. п. 3.14)\nfunc (c *mitsuClient) GetOkpSettings(ctx context.Context) (*ServerSettings, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET OKP='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s ServerSettings\n\tif err := xml.Unmarshal(resp, &s); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа OKP: %w\", err)\n\t}\n\n\t// Унификация: если заполнено поле Okp, переносим в Addr\n\tif s.Okp != \"\" && s.Addr == \"\" {\n\t\ts.Addr = s.Okp\n\t}\n\n\treturn &s, nil\n}\n\n// GetTaxRates запрашивает налоговые ставки (См. п. 3.15)\nfunc (c *mitsuClient) GetTaxRates(ctx context.Context) (*TaxRates, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET TAX='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar t TaxRates\n\tif err := xml.Unmarshal(resp, &t); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа TAX: %w\", err)\n\t}\n\n\treturn &t, nil\n}\n\n// GetRegistrationData запрашивает данные о регистрации ККТ (См. п. 3.16)\nfunc (c *mitsuClient) GetRegistrationData(ctx context.Context) (*RegData, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET REG='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r RegData\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа REG: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetStatus получает статус ККТ (INFO='0').\nfunc (c *mitsuClient) GetStatus(ctx context.Context) (*ShiftStatus, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET INFO='0'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s ShiftStatus\n\tif err := xml.Unmarshal(resp, &s); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора статуса ККТ: %w\", err)\n\t}\n\n\treturn &s, nil\n}\n\n// GetShiftTotals получает итоги смены (INFO='1')\nfunc (c *mitsuClient) GetShiftTotals(ctx context.Context) (*ShiftTotals, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET INFO='1'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s ShiftTotals\n\tif err := xml.Unmarshal(resp, &s); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора итогов смены: %w\", err)\n\t}\n\n\treturn &s, nil\n}\n\n// GetFnStatus получает статус фискального накопителя (INFO='F').\nfunc (c *mitsuClient) GetFnStatus(ctx context.Context) (*FnStatus, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET INFO='F'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar f FnStatus\n\tif err := xml.Unmarshal(resp, &f); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора статуса ФН: %w\", err)\n\t}\n\n\treturn &f, nil\n}\n\n// GetOfdExchangeStatus получает статус обмена с ОФД (INFO='O')\nfunc (c *mitsuClient) GetOfdExchangeStatus(ctx context.Context) (*OfdExchangeStatus, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET INFO='O'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s OfdExchangeStatus\n\tif err := xml.Unmarshal(resp, &s); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора статуса обмена с ОФД: %w\", err)\n\t}\n\n\treturn &s, nil\n}\n\n// GetMarkingStatus получает статус маркировки (INFO='M')\nfunc (c *mitsuClient) GetMarkingStatus(ctx context.Context) (*MarkingStatus, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET INFO='M'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar m MarkingStatus\n\tif err := xml.Unmarshal(resp, &m); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора статуса маркировки: %w\", err)\n\t}\n\n\treturn &m, nil\n}\n\n// GetPowerStatus запрашивает статус питания (См. п. 3.33)\nfunc (c *mitsuClient) GetPowerStatus(ctx context.Context) (*PowerStatusResponse, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET POWER='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r PowerStatusResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа POWER: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetTimezone запрашивает часовой пояс (См. п. 3.35)\nfunc (c *mitsuClient) GetTimezone(ctx context.Context) (*TimezoneResponse, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET TIMEZONE='?'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r TimezoneResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа TIMEZONE: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetOptions запрашивает все опции устройства (См. п. 4.13)\nfunc (c *mitsuClient) GetOptions(ctx context.Context) (*DeviceOptions, error) {\n\tresp, err := c.SendCommand(ctx, \"<OPTION/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar opts DeviceOptions\n\tif err := xml.Unmarshal(resp, &opts); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа OPTION: %w\", err)\n\t}\n\n\treturn &opts, nil\n}\n\n// GetCurrentDocumentType получает тип текущего документа\nfunc (c *mitsuClient) GetCurrentDocumentType(ctx context.Context) (*CurrentDocumentTypeResponse, error) {\n\tresp, err := c.SendCommand(ctx, \"<GET DOC='0'/>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r CurrentDocumentTypeResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа DOC='0': %w\", err)\n\t}\n\n\treturn &r, nil\n}\n\n// GetDocumentInfoFromFN получает информацию о документе (OFFSET и LENGTH) по номеру FD\nfunc (c *mitsuClient) GetDocumentInfoFromFN(ctx context.Context, fd int) (*DocumentInfoResponse, error) {\n\tcmd := fmt.Sprintf(\"<GET DOC='X:%d'/>\", fd)\n\tresp, err := c.SendCommand(ctx, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r DocumentInfoResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа DOC='X:%d': %w\", fd, err)\n\t}\n\n\treturn &r, nil\n}\n\n// ReadBlock читает блок данных из памяти ФН по OFFSET и LENGTH\nfunc (c *mitsuClient) ReadBlock(ctx context.Context, offset int64, length int) (*ReadBlockResponse, error) {\n\tcmd := fmt.Sprintf(\"<READ OFFSET='%X' LENGTH='%d'/>\", offset, length)\n\tresp, err := c.SendCommand(ctx, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r ReadBlockResponse\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка разбора ответа READ: %w\", err)\n\t}\n\n\treturn &r, nil\n}\n",
    "commands_ofd.go": "package mitsu\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// OfdBeginRead начинает процедуру чтения первого непереданного документа для отправки в ОФД.\n// Возвращает размер сообщения в байтах.\n// Команда: <Do OFD='BEGIN'/>\n// Ответ: <OK LENGTH='размер'/>\nfunc (c *mitsuClient) OfdBeginRead(ctx context.Context) (int, error) {\n\tresp, err := c.SendCommand(ctx, \"<Do OFD='BEGIN'/>\")\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"ошибка начала чтения документа ОФД: %w\", err)\n\t}\n\n\tvar r struct {\n\t\tLength int `xml:\"LENGTH,attr\"`\n\t}\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn 0, fmt.Errorf(\"ошибка разбора ответа OFD BEGIN: %w\", err)\n\t}\n\n\treturn r.Length, nil\n}\n\n// OfdReadBlock считывает блок сообщения заданной длины, начиная с заданной позиции.\n// offset - смещение в байтах от начала сообщения\n// length - число байт блока данных, не более 1000 байт\n// Возвращает: фактический размер прочитанного блока и данные в бинарном виде.\n// Команда: <Do OFD='READ' OFFSET='позиция' LENGTH='размер'/>\n// Ответ: <OK LENGTH='размер'>БЛОК ДАННЫХ В HEX</OK>\nfunc (c *mitsuClient) OfdReadBlock(ctx context.Context, offset, length int) ([]byte, int, error) {\n\tif length > 1000 {\n\t\tlength = 1000\n\t}\n\n\tcmd := fmt.Sprintf(\"<Do OFD='READ' OFFSET='%d' LENGTH='%d'/>\", offset, length)\n\tresp, err := c.SendCommand(ctx, cmd)\n\tif err != nil {\n\t\treturn nil, 0, fmt.Errorf(\"ошибка чтения блока OFD offset=%d length=%d: %w\", offset, length, err)\n\t}\n\n\tvar r struct {\n\t\tLength int    `xml:\"LENGTH,attr\"`\n\t\tData   string `xml:\",innerxml\"`\n\t}\n\tif err := xml.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, 0, fmt.Errorf(\"ошибка разбора ответа OFD READ: %w\", err)\n\t}\n\n\tdata, err := hex.DecodeString(r.Data)\n\tif err != nil {\n\t\treturn nil, 0, fmt.Errorf(\"ошибка декодирования HEX данных OFD: %w\", err)\n\t}\n\n\treturn data, r.Length, nil\n}\n\n// OfdEndRead завершает чтение документа.\n// Команда: <Do OFD='END'/>\nfunc (c *mitsuClient) OfdEndRead(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<Do OFD='END'/>\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"ошибка завершения чтения документа ОФД: %w\", err)\n\t}\n\treturn nil\n}\n\n// OfdLoadReceipt записывает квитанцию от ОФД в ФН.\n// receipt - бинарные данные квитанции\n// Команда: <Do OFD='LOAD' LENGTH='размер'>КВИТАНЦИЯ В HEX</OK>\nfunc (c *mitsuClient) OfdLoadReceipt(ctx context.Context, receipt []byte) error {\n\thexData := strings.ToUpper(hex.EncodeToString(receipt))\n\tcmd := fmt.Sprintf(\"<DO OFD='LOAD' LENGTH='%d'>%s</DO>\", len(receipt), hexData)\n\n\t_, err := c.SendCommand(ctx, cmd)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"ошибка записи квитанции ОФД: %w\", err)\n\t}\n\treturn nil\n}\n\n// OfdCancelRead отменяет чтение документа.\n// Команда: <Do OFD='CANCEL'/>\nfunc (c *mitsuClient) OfdCancelRead(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<Do OFD='CANCEL'/>\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"ошибка отмены чтения документа ОФД: %w\", err)\n\t}\n\treturn nil\n}\n\n// OfdReadFullDocument читает полный документ для отправки в ОФД.\n// Возвращает бинарные данные документа (с обёрткой для ОФД).\nfunc (c *mitsuClient) OfdReadFullDocument(ctx context.Context) ([]byte, error) {\n\ttotalLength, err := c.OfdBeginRead(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif totalLength == 0 {\n\t\tc.OfdEndRead(ctx)\n\t\treturn nil, fmt.Errorf(\"документ пуст или отсутствует\")\n\t}\n\n\tconst blockSize = 1000\n\tvar fullData []byte\n\toffset := 0\n\n\tfor offset < totalLength {\n\t\tremaining := totalLength - offset\n\t\tchunkSize := blockSize\n\t\tif chunkSize > remaining {\n\t\t\tchunkSize = remaining\n\t\t}\n\n\t\tdata, actualLen, err := c.OfdReadBlock(ctx, offset, chunkSize)\n\t\tif err != nil {\n\t\t\tc.OfdCancelRead(ctx)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfullData = append(fullData, data...)\n\t\toffset += actualLen\n\n\t\tif actualLen == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := c.OfdEndRead(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn fullData, nil\n}\n",
    "commands_reg.go": "package mitsu\n\nimport (\n\t\"context\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// RegistrationRequest содержит параметры для регистрации/перерегистрации ККТ.\n// Поля соответствуют атрибутам и тегам команды <REG> (стр. 23 документации).\ntype RegistrationRequest struct {\n\tIsReregistration bool\n\n\t// Обязательные поля\n\tBase          string\n\tTaxSystems    string\n\tTaxSystemBase string\n\n\t// Опциональные поля (флаги режимов)\n\tInternetCalc   bool\n\tService        bool\n\tBSO            bool\n\tLottery        bool\n\tGambling       bool\n\tExcise         bool\n\tMarking        bool\n\tPawnShop       bool\n\tInsurance      bool\n\tCatering       bool\n\tWholesale      bool\n\tVending        bool\n\tAutomatMode    bool\n\tAutonomousMode bool\n\tEncryption     bool\n\tPrinterAutomat bool\n\n\t// Дополнительные поля\n\tFfdVer        string\n\tAutomatNumber string\n\n\t// Теги\n\tOrgName     string\n\tAddress     string\n\tPlace       string\n\tOfdName     string\n\tOfdInn      string\n\tInn         string\n\tRNM         string\n\tFnsSite     string\n\tSenderEmail string\n}\n\n// Register выполняет первичную регистрацию ККТ (5.1).\nfunc (c *mitsuClient) Register(ctx context.Context, req RegistrationRequest) (*RegResponse, error) {\n\treq.IsReregistration = false\n\treq.Base = \"0\" // Для первичной регистрации BASE всегда '0'\n\treturn c.performRegistration(ctx, req)\n}\n\n// Reregister выполняет перерегистрацию ККТ (5.2).\n// reasons - список кодов причин (см. стр 12, например: 1 - замена ФН, 3 - смена реквизитов).\nfunc (c *mitsuClient) Reregister(ctx context.Context, req RegistrationRequest, reasons []int) (*RegResponse, error) {\n\treq.IsReregistration = true\n\tvar strReasons []string\n\tfor _, r := range reasons {\n\t\tstrReasons = append(strReasons, fmt.Sprintf(\"%d\", r))\n\t}\n\treq.Base = strings.Join(strReasons, \",\")\n\tif req.Base == \"\" {\n\t\treturn nil, fmt.Errorf(\"не указаны причины перерегистрации\")\n\t}\n\n\treturn c.performRegistration(ctx, req)\n}\n\n// performRegistration формирует XML команду <REG> и отправляет её.\nfunc (c *mitsuClient) performRegistration(ctx context.Context, req RegistrationRequest) (*RegResponse, error) {\n\tattrs := fmt.Sprintf(\"BASE='%s' T1062='%s'\", req.Base, req.TaxSystems)\n\n\tif req.TaxSystemBase != \"\" {\n\t\tattrs += fmt.Sprintf(\" T1062_Base='%s'\", req.TaxSystemBase)\n\t}\n\n\tif req.InternetCalc {\n\t\tattrs += \" T1108='1'\"\n\t}\n\tif req.Service {\n\t\tattrs += \" T1109='1'\"\n\t}\n\tif req.BSO {\n\t\tattrs += \" T1110='1'\"\n\t}\n\tif req.Lottery {\n\t\tattrs += \" T1126='1'\"\n\t}\n\tif req.Gambling {\n\t\tattrs += \" T1193='1'\"\n\t}\n\tif req.Excise {\n\t\tattrs += \" T1207='1'\"\n\t}\n\tif req.Marking {\n\t\tattrs += \" MARK='1'\"\n\t}\n\tif req.PawnShop {\n\t\tattrs += \" PAWN='1'\"\n\t}\n\tif req.Insurance {\n\t\tattrs += \" INS='1'\"\n\t}\n\tif req.Catering {\n\t\tattrs += \" DINE='1'\"\n\t}\n\tif req.Wholesale {\n\t\tattrs += \" OPT='1'\"\n\t}\n\tif req.Vending {\n\t\tattrs += \" VEND='1'\"\n\t}\n\tif req.AutomatMode {\n\t\tattrs += \" T1001='1'\"\n\t}\n\tif req.AutonomousMode {\n\t\tattrs += \" T1002='1'\"\n\t}\n\tif req.Encryption {\n\t\tattrs += \" T1056='1'\"\n\t}\n\tif req.PrinterAutomat {\n\t\tattrs += \" T1221='1'\"\n\t}\n\n\tif req.FfdVer != \"\" {\n\t\tattrs += fmt.Sprintf(\" T1209='%s'\", req.FfdVer)\n\t}\n\tif req.AutomatNumber != \"\" {\n\t\tattrs += fmt.Sprintf(\" T1036='%s'\", req.AutomatNumber)\n\t}\n\n\ttags := \"\"\n\ttags += fmt.Sprintf(\"<T1048>%s</T1048>\", escapeXMLText(req.OrgName))\n\ttags += fmt.Sprintf(\"<T1009>%s</T1009>\", escapeXMLText(req.Address))\n\ttags += fmt.Sprintf(\"<T1187>%s</T1187>\", escapeXMLText(req.Place))\n\ttags += fmt.Sprintf(\"<T1046>%s</T1046>\", escapeXMLText(req.OfdName))\n\ttags += fmt.Sprintf(\"<T1017>%s</T1017>\", req.OfdInn)\n\n\tif !req.IsReregistration {\n\t\ttags += fmt.Sprintf(\"<T1018>%s</T1018>\", req.Inn)\n\t\ttags += fmt.Sprintf(\"<T1037>%s</T1037>\", req.RNM)\n\t}\n\n\ttags += fmt.Sprintf(\"<T1060>%s</T1060>\", escapeXMLText(req.FnsSite))\n\ttags += fmt.Sprintf(\"<T1117>%s</T1117>\", escapeXMLText(req.SenderEmail))\n\n\tif req.AutomatNumber != \"\" {\n\t\ttags += fmt.Sprintf(\"<T1036>%s</T1036>\", escapeXMLText(req.AutomatNumber))\n\t}\n\n\txmlCmd := fmt.Sprintf(\"<REG %s>%s</REG>\", attrs, tags)\n\n\trespData, err := c.SendCommand(ctx, xmlCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resp RegResponse\n\tif err := xml.Unmarshal(respData, &resp); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка парсинга ответа регистрации: %w\", err)\n\t}\n\n\treturn &resp, nil\n}\n\n// CloseFiscalArchive закрывает фискальный режим (5.4).\nfunc (c *mitsuClient) CloseFiscalArchive(ctx context.Context) (*CloseFnResult, error) {\n\tcmd := \"<MAKE FISCAL='CLOSE'></MAKE>\"\n\trespData, err := c.SendCommand(ctx, cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar resp struct {\n\t\tFD int    `xml:\"FD,attr\"`\n\t\tFP string `xml:\"FP,attr\"`\n\t}\n\tif err := xml.Unmarshal(respData, &resp); err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка парсинга ответа закрытия ФН: %w\", err)\n\t}\n\n\t_, err = c.SendCommand(ctx, \"<PRINT/>\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка печати отчета о закрытии ФН: %w\", err)\n\t}\n\n\treturn &CloseFnResult{FD: resp.FD, FP: resp.FP}, nil\n}\n",
    "commands_set.go": "package mitsu\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n)\n\n// SetDateTime устанавливает дату и время ККТ (См. п. 4.3)\n// ВНИМАНИЕ! Если часы кассы установлены по ошибке на будущую дату/время и оформлен\n// хотя бы один фискальный документ, вернуть назад часы невозможно.\n// В этом случае потребуется замена ФН.\nfunc (c *mitsuClient) SetDateTime(ctx context.Context, t time.Time) error {\n\tdateStr := t.Format(\"2006-01-02\")\n\ttimeStr := t.Format(\"15:04:05\")\n\tcmd := fmt.Sprintf(\"<SET DATE='%s' TIME='%s' />\", dateStr, timeStr)\n\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetCashier устанавливает данные кассира (См. п. 4.4)\n// name: Идентификатор (ФИО, должность), макс 64 символа.\n// inn: ИНН кассира (необязательно).\n// Необходимо устанавливать кассира перед открытием каждого чека.\nfunc (c *mitsuClient) SetCashier(ctx context.Context, name string, inn string) error {\n\tsafeName := escapeXMLText(name)\n\tcmd := fmt.Sprintf(\"<SET CASHIER='%s' INN='%s'/>\", safeName, inn)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetComSettings устанавливает настройки COM-порта (См. п. 4.5)\nfunc (c *mitsuClient) SetComSettings(ctx context.Context, speed int32) error {\n\tcmd := fmt.Sprintf(\"<SET COM='%d'/>\", speed)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetPrinterSettings устанавливает настройки принтера (См. п. 4.6)\nfunc (c *mitsuClient) SetPrinterSettings(ctx context.Context, s PrinterSettings) error {\n\tcmd := fmt.Sprintf(\n\t\t\"<SET PRINTER='%s' BAUDRATE='%d' PAPER='%d' FONT='%d'/>\",\n\t\ts.Model, s.BaudRate, s.Paper, s.Font,\n\t)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetMoneyDrawerSettings устанавливает настройки денежного ящика (См. п. 4.7)\nfunc (c *mitsuClient) SetMoneyDrawerSettings(ctx context.Context, s DrawerSettings) error {\n\tcmd := fmt.Sprintf(\n\t\t\"<SET CD='%d' RISE='%d' FALL='%d'/>\",\n\t\ts.Pin, s.Rise, s.Fall,\n\t)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// ClicheLineData содержит данные одной строки клише\ntype ClicheLineData struct {\n\tText   string\n\tFormat string\n}\n\n// SetHeader устанавливает клише и подвала (См. п. 4.8)\n// headerNum:\n// 1 - клише №1, печатается в заголовке в самом верху документа\n// 2 - клише №2, печатается после строк с наименованием пользователя и адреса расчетов\n// 3 - клише №3, печатается внизу чека перед QR кодом и реквизитами\n// 4 - клише №4, печатается в самом конце чека\n// Суммарная длина всех строк каждого клише до 1000 символов\n// lineNum: 0..9\n// format: \"xxxxxx\" (6 цифр).\n// 1 цифра: инверсия (0 – нет инверсии: черный текст на белом фоне, 1 – инверсия: белый текст на черном фоне)\n// 2 цифра: размер текста по горизонтали (ширина) (0 – размер, установленный в настройках, 1 - обычный, 2-8 масштаб)\n// 3 цифра: размер текста по вертикали (высота) (0 – размер, установленный в настройках, 1 - обычный, 2-8 масштаб)\n// 4 цифра: шрифт (0-шрифт, установленный настройкой <Setup><Font>, 1-А, 2-B)\n// 5 цифра: подчеркивание (0-нет, 1-текст, 2-строка)\n// 6 цифра: выравнивание (0-лево, 1-центр, 2-право)\n// Строки каждого клише надо программировать по одной, подряд без пропуска. Например, если задать строки L0 и L2, то установися только строка L0.\n// Установка каждой строки стирает все последующие внутри клише. Например, если сначала задать строки с L0 по L3, а затем повторно задать строки L0 и L1, то строки L2 и L3 сотрутся\nfunc (c *mitsuClient) SetHeader(ctx context.Context, headerNum int, lines []ClicheLineData) error {\n\tvar sb strings.Builder\n\n\tsb.WriteString(fmt.Sprintf(\"<SET HEADER='%d'>\", headerNum))\n\n\tfor i, line := range lines {\n\t\tif i > 9 {\n\t\t\tbreak\n\t\t}\n\n\t\tformat := line.Format\n\t\tif format == \"\" {\n\t\t\tformat = \"000000\"\n\t\t}\n\n\t\tsafeText := escapeXMLText(line.Text)\n\t\tsb.WriteString(fmt.Sprintf(\"<L%d FORM='%s'>%s</L%d>\", i, format, safeText, i))\n\t}\n\n\tsb.WriteString(\"</SET>\")\n\n\t_, err := c.SendCommand(ctx, sb.String())\n\treturn err\n}\n\n// SetHeaderLine устанавливает одну строку клише (См. п. 4.8)\nfunc (c *mitsuClient) SetHeaderLine(ctx context.Context, headerNum int, lineNum int, text string, format string) error {\n\tif format == \"\" {\n\t\tformat = \"000000\"\n\t}\n\tsafeText := escapeXMLText(text)\n\n\tcmd := fmt.Sprintf(\n\t\t\"<SET HEADER='%d'><L%d FORM='%s'>%s</L%d></SET>\",\n\t\theaderNum, lineNum, format, safeText, lineNum,\n\t)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetLanSettings устанавливает настройки LAN (См. п. 4.9)\nfunc (c *mitsuClient) SetLanSettings(ctx context.Context, s LanSettings) error {\n\tcmd := fmt.Sprintf(\n\t\t\"<SET LAN='%s' MASK='%s' PORT='%d' DNS='%s' GW='%s'/>\",\n\t\ts.Addr, s.Mask, s.Port, s.Dns, s.Gw,\n\t)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetOfdSettings устанавливает настройки ОФД (См. п. 4.10)\nfunc (c *mitsuClient) SetOfdSettings(ctx context.Context, s OfdSettings) error {\n\tcmd := fmt.Sprintf(\n\t\t\"<SET OFD='%s' PORT='%d' CLIENT='%s' TimerFN='%d' TimerOFD='%d'/>\",\n\t\ts.Addr, s.Port, s.Client, s.TimerFN, s.TimerOFD,\n\t)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetOismSettings устанавливает настройки OISM (См. п. 4.11)\nfunc (c *mitsuClient) SetOismSettings(ctx context.Context, s ServerSettings) error {\n\tcmd := fmt.Sprintf(\n\t\t\"<SET OISM='%s' PORT='%d'/>\",\n\t\ts.Addr, s.Port,\n\t)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetOkpSettings устанавливает настройки OKP (См. п. 4.12)\nfunc (c *mitsuClient) SetOkpSettings(ctx context.Context, s ServerSettings) error {\n\taddr := s.Addr\n\tif addr == \"\" && s.Okp != \"\" {\n\t\taddr = s.Okp\n\t}\n\tcmd := fmt.Sprintf(\n\t\t\"<SET OKP='%s' PORT='%d'/>\",\n\t\taddr, s.Port,\n\t)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetOption устанавливает одну опцию устройства (См. п. 4.13)\n// Устанавливает одну опцию b0-b9.\n// Значения опций см. в таблице на стр. 22.\n// Например, b0=0 (нет разделителей), b1=0 (QR слева).\nfunc (c *mitsuClient) SetOption(ctx context.Context, optionNum int, value int) error {\n\tif optionNum < 0 || optionNum > 9 {\n\t\treturn fmt.Errorf(\"неверный номер опции: %d\", optionNum)\n\t}\n\tcmd := fmt.Sprintf(\"<OPTION b%d='%d'/>\", optionNum, value)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetPowerFlag устанавливает флаг питания (См. п. 4.14)\n// Сбрасывает (1) или устанавливает (0) флаг сбоя питания.\nfunc (c *mitsuClient) SetPowerFlag(ctx context.Context, value int) error {\n\tcmd := fmt.Sprintf(\"<SET POWER='%d'/>\", value)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// SetTimezone устанавливает часовой пояс (Добавлено в FW 1.2.18)\nfunc (c *mitsuClient) SetTimezone(ctx context.Context, value int) error {\n\tcmd := fmt.Sprintf(\"<SET TIMEZONE='%d'/>\", value)\n\t_, err := c.SendCommand(ctx, cmd)\n\treturn err\n}\n\n// TechReset выполняет технологическое обнуление устройства\n// Команда: <SET FACTORY=”/>\nfunc (c *mitsuClient) TechReset(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<SET FACTORY=''/>\")\n\treturn err\n}\n\n// escapeXMLText экранирует специальные символы XML\nfunc escapeXMLText(s string) string {\n\tresult := make([]byte, 0, len(s)*2)\n\tfor i := 0; i < len(s); i++ {\n\t\tswitch s[i] {\n\t\tcase '&':\n\t\t\tresult = append(result, '&', 'a', 'm', 'p', ';')\n\t\tcase '<':\n\t\t\tresult = append(result, '&', 'l', 't', ';')\n\t\tcase '>':\n\t\t\tresult = append(result, '&', 'g', 't', ';')\n\t\tcase '\\'':\n\t\t\tresult = append(result, '&', 'a', 'p', 'o', 's', ';')\n\t\tcase '\"':\n\t\t\tresult = append(result, '&', 'q', 'u', 'o', 't', ';')\n\t\tdefault:\n\t\t\tresult = append(result, s[i])\n\t\t}\n\t}\n\treturn string(result)\n}\n",
    "commands_shift.go": "package mitsu\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\n// OpenShift открывает смену\nfunc (c *mitsuClient) OpenShift(ctx context.Context, operator string) error {\n\tif operator != \"\" {\n\t\tif err := c.SetCashier(ctx, operator, \"\"); err != nil {\n\t\t\treturn fmt.Errorf(\"ошибка установки кассира: %w\", err)\n\t\t}\n\t}\n\n\t_, err := c.SendCommand(ctx, \"<Do SHIFT='OPEN'/>\")\n\treturn err\n}\n\n// CloseShift закрывает смену\nfunc (c *mitsuClient) CloseShift(ctx context.Context, operator string) error {\n\tif operator != \"\" {\n\t\tif err := c.SetCashier(ctx, operator, \"\"); err != nil {\n\t\t\treturn fmt.Errorf(\"ошибка установки кассира: %w\", err)\n\t\t}\n\t}\n\n\t_, err := c.SendCommand(ctx, \"<Do SHIFT='CLOSE'/>\")\n\treturn err\n}\n\n// PrintXReport печатает X-отчет\nfunc (c *mitsuClient) PrintXReport(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<MAKE REPORT='X'/>\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.SendCommand(ctx, \"<PRINT/>\")\n\treturn err\n}\n\n// PrintZReport печатает отчет по расчетам (Этот отчет не закрывает смену!)\nfunc (c *mitsuClient) PrintZReport(ctx context.Context) error {\n\t_, err := c.SendCommand(ctx, \"<MAKE REPORT='Z'/>\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.SendCommand(ctx, \"<PRINT/>\")\n\treturn err\n}\n",
    "errors.go": "package mitsu\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"golang.org/x/net/html/charset\"\n)\n\n// Error представляет структуру ошибки ККТ Mitsu с расширенными данными\ntype Error struct {\n\tCode       string // Код ошибки ККТ\n\tMessage    string // Описание ошибки\n\tTAG        string // Тег ошибки (TAG атрибут)\n\tPAR        string // Параметр ошибки (PAR атрибут)\n\tFSECode    string // Код ошибки ФН (FSE атрибут)\n\tFSEMessage string // Описание ошибки ФН\n}\n\n// Error реализует интерфейс error для структуры Error\nfunc (e Error) Error() string {\n\tmsg := fmt.Sprintf(\"Ошибка ККТ #%s: %s\", e.Code, e.Message)\n\n\tif e.PAR != \"\" {\n\t\tmsg += fmt.Sprintf(\" (параметр: %s)\", e.PAR)\n\t}\n\tif e.FSECode != \"\" {\n\t\tif e.FSEMessage != \"\" {\n\t\t\tmsg += fmt.Sprintf(\", ошибка ФН #%s: %s\", e.FSECode, e.FSEMessage)\n\t\t} else {\n\t\t\tmsg += fmt.Sprintf(\", ошибка ФН: %s\", e.FSECode)\n\t\t}\n\t}\n\tif e.TAG != \"\" {\n\t\tmsg += fmt.Sprintf(\" [TAG: %s]\", e.TAG)\n\t}\n\n\treturn msg\n}\n\n// ErrorDescriptions содержит расшифровку кодов ошибок согласно Приложению 1 документации.\nvar ErrorDescriptions = map[string]string{\n\t\"0\":   \"нет ошибок\",\n\t\"1\":   \"неизвестная операция\",\n\t\"2\":   \"недостаточно памяти для выполнения операции\",\n\t\"3\":   \"операция не задана\",\n\t\"4\":   \"не задана структура хранения ошибки операции ФН\",\n\t\"5\":   \"не задана структура для результатов операции ФН\",\n\t\"6\":   \"не задана структура входящих параметров операции ФН\",\n\t\"7\":   \"превышен максимальный размер данных для команды ФН\",\n\t\"8\":   \"внутренняя ошибка ПО (не задан параметр в классификаторе команд)\",\n\t\"10\":  \"ошибка исходного состояния ФН перед (пере-)регистрацией\",\n\t\"11\":  \"ошибка ФН при получении статуса\",\n\t\"12\":  \"ошибка ФН при выдаче команды 'Начать отчет о регистрации'\",\n\t\"13\":  \"ошибка ФН при выдаче команды 'Передать данные документа'\",\n\t\"14\":  \"ошибка ФН при выдаче команды 'Сформировать отчет о регистрации (перерегистрации)'\",\n\t\"15\":  \"ошибка ФН при выдаче команды 'Начать закрытие фискального режима ФН'\",\n\t\"16\":  \"ошибка ФН при выдаче команды 'Закрыть фискальный режим ФН'\",\n\t\"17\":  \"ошибка при попытке захвата ФН\",\n\t\"18\":  \"ошибка ФН при выдаче команды 'Начать формирование отчета о текущем состоянии расчетов'\",\n\t\"19\":  \"ошибка ФН при выдаче команды 'Сформировать отчет о текущем состоянии расчетов'\",\n\t\"20\":  \"ошибка ФН: смена открыта\",\n\t\"21\":  \"ошибка ФН: смена закрыта\",\n\t\"22\":  \"ошибка ФН: имеется незакрытый документ\",\n\t\"23\":  \"ошибка ФН при выдаче команды 'Запрос количества ФД, на которые нет квитанции'\",\n\t\"24\":  \"ошибка ФН при выдаче команды 'Запрос срока действия ФН'\",\n\t\"25\":  \"ошибка ФН при выдаче команды 'Запрос итогов фискализации ФН'\",\n\t\"26\":  \"ошибка ФН: есть неподтвержденные в ОФД документы\",\n\t\"27\":  \"ошибка ФН при выдаче команды 'Начать открытие смены'\",\n\t\"28\":  \"ошибка ФН при выдаче команды 'Открыть смену'\",\n\t\"29\":  \"ошибка ФН при выдаче команды 'Начать закрытие смены'\",\n\t\"30\":  \"ошибка ФН при выдаче команды 'Закрыть смену'\",\n\t\"31\":  \"ошибка ФН при выдаче команды 'Начать формирование чека (БСО)'\",\n\t\"32\":  \"ошибка определения типа: чек или БСО\",\n\t\"33\":  \"ошибка ФН: чек (БСО) не открыт\",\n\t\"34\":  \"ошибка преобразования данных\",\n\t\"35\":  \"ошибка ФН при выдаче команды 'Сформировать чек'\",\n\t\"36\":  \"ошибка ФН при выдаче команды 'Отменить текущий документ'\",\n\t\"37\":  \"ошибка: незакрытый документ отсутствует\",\n\t\"38\":  \"ошибка: время смены истекло\",\n\t\"39\":  \"ошибка: чек коррекции (БСО коррекции) не открыт\",\n\t\"40\":  \"ошибка ФН при получении счетчиков\",\n\t\"41\":  \"ошибка ФН при получении состояния смены\",\n\t\"42\":  \"ошибка: чек пустой (нет предметов расчета)\",\n\t\"43\":  \"ошибка: стадия формирования чека не соответствует операции\",\n\t\"44\":  \"ошибка ФН при выдаче команды 'Запрос номера и типа версии ПО ФН'\",\n\t\"45\":  \"ошибка: нужна отладочная версия ФН для выполнения операции\",\n\t\"46\":  \"ошибка ФН при выдаче команды 'Сброс ФН'\",\n\t\"47\":  \"ошибка ФН при получении статуса информационного обмена с ОФД\",\n\t\"48\":  \"ошибка ФН: чтение сообщения для ОФД уже начато\",\n\t\"49\":  \"ошибка ФН: нет сообщений для ОФД\",\n\t\"50\":  \"ошибка ФН при выдаче команды 'Передать статус транспортного соединения с сервером ОФД'\",\n\t\"51\":  \"ошибка ФН при выдаче команды 'Начать чтение сообщения для сервера ОФД'\",\n\t\"52\":  \"ошибка ФН: чтение сообщения для ОФД еще не начато\",\n\t\"53\":  \"ошибка ФН при выдаче команды 'Отменить чтение сообщения для сервера ОФД'\",\n\t\"54\":  \"ошибка ФН при выдаче команды 'Прочитать блок сообщения для сервера ОФД'\",\n\t\"55\":  \"ошибка ФН: нет готовности к принятию квитанции от ОФД\",\n\t\"56\":  \"ошибка ФН при выдаче команды 'Передать квитанцию от сервера ОФД'\",\n\t\"57\":  \"ошибка ФН: неверный фискальный признак\",\n\t\"58\":  \"ошибка ФН: неверный формат квитанции\",\n\t\"59\":  \"ошибка ФН: неверный номер ФД\",\n\t\"60\":  \"ошибка ФН: неверный номер ФН\",\n\t\"61\":  \"ошибка ФН: неверный CRC\",\n\t\"62\":  \"ошибка ФН при выдаче команды 'Запрос фискального документа в TLV формате'\",\n\t\"63\":  \"ошибка ФН при выдаче команды 'Чтение TLV фискального документа'\",\n\t\"64\":  \"ошибка ФН: отсутствуют необходимые данные документа в архиве\",\n\t\"65\":  \"ошибка ФН: запрошенный из архива документ не является чеком\",\n\t\"66\":  \"ошибка ФН при выдаче команды 'Запрос общего размера данных переданных командой 07h'\",\n\t\"67\":  \"ошибка ФН при выдаче команды 'Запрос формата ФН'\",\n\t\"68\":  \"ошибка ФН: получены ошибочные данные от ФН\",\n\t\"69\":  \"ошибка ФН: ФН не готов или отсутствует\",\n\t\"70\":  \"ошибка ФН: превышено время ожидания ответа от ФН\",\n\t\"71\":  \"ошибка ФН: Не удалось получить запрос на проверку кода маркировки\",\n\t\"72\":  \"ошибка ФН: операция не поддерживается в автономном режиме\",\n\t\"73\":  \"ошибка ФН: чтение уведомления уже начато\",\n\t\"74\":  \"ошибка ФН: нет уведомлений для передачи\",\n\t\"75\":  \"ошибка ФН при выдаче команды 'Начать чтение уведомления'\",\n\t\"76\":  \"ошибка ФН: чтение уведомления еще не начато\",\n\t\"77\":  \"ошибка ФН: нет готовности к принятию квитанции по уведомлениям\",\n\t\"78\":  \"ошибка ФН: неверный номер уведомления\",\n\t\"79\":  \"ошибка ФН: неверная длина ответа\",\n\t\"80\":  \"операция поддерживается только в автономном режиме\",\n\t\"81\":  \"запрос на обновление ключей проверки КМ не был сформирован\",\n\t\"82\":  \"ошибка ФН: неверный номер запроса в ответе\",\n\t\"83\":  \"ошибка ФН: для выполнения команды необходимо обновить ключи проверки кодов маркировки\",\n\t\"84\":  \"необходимо выгрузить уведомления\",\n\t\"94\":  \"Таймаут приема команды\",\n\t\"95\":  \"Устройство печати занято\",\n\t\"96\":  \"В команде заданы неизвестные параметры\",\n\t\"97\":  \"В команде отсутствуют обязательные параметры\",\n\t\"98\":  \"Превышена максимальная длина параметра\",\n\t\"99\":  \"Неверный формат команды или неизвестная команда\",\n\t\"100\": \"ошибка задания версии ФФД\",\n\t\"101\": \"ошибка задания заводского номера\",\n\t\"102\": \"ошибка задания версии\",\n\t\"103\": \"ошибка задания регистрационного номера\",\n\t\"104\": \"ошибка задания ИНН\",\n\t\"105\": \"ошибка задания ИНН ОФД\",\n\t\"106\": \"ошибка задания причины перерегистрации\",\n\t\"107\": \"ошибка: заданная система налогообложения не поддерживается\",\n\t\"108\": \"ошибка задания признака расчета\",\n\t\"109\": \"ошибка задания признака способа расчета\",\n\t\"110\": \"ошибка задания признака предмета расчета\",\n\t\"111\": \"ошибка задания наименования предмета расчета\",\n\t\"112\": \"ошибка задания единицы измерения предмета расчета\",\n\t\"113\": \"ошибка задания кода товарной номенклатуры предмета расчета\",\n\t\"114\": \"ошибка задания количества единиц предмета расчета\",\n\t\"115\": \"ошибка задания цены за единицу предмета расчета\",\n\t\"116\": \"ошибка задания стоимости предмета расчета\",\n\t\"117\": \"ошибка задания ставки НДС предмета расчета\",\n\t\"118\": \"ошибка расчета размера НДС за единицу предмета расчета\",\n\t\"119\": \"ошибка расчета размера НДС предмета расчета\",\n\t\"120\": \"ошибка: расчет стоимости по позициям чека превысил максимально допустимое значение\",\n\t\"121\": \"ошибка: расчет стоимости по чеку превысил сумму оплат\",\n\t\"122\": \"ошибка задания количества принятых наличных денег в оплату чека\",\n\t\"123\": \"ошибка: расчет стоимости по видам оплаты чека превысил максимально допустимое значение\",\n\t\"124\": \"ошибка получения текущего времени от внутренних часов\",\n\t\"125\": \"ошибка: в чеке с оплатой кредита может быть только один предмет расчета\",\n\t\"126\": \"ошибка: кассир не установлен\",\n\t\"127\": \"ошибка задания признака агента\",\n\t\"128\": \"ошибка: документ в электронной форме не сформирован\",\n\t\"129\": \"ошибка: превышено максимальное количество предметов с кодом товарной номенклатуры\",\n\t\"130\": \"ошибка: попытка повторного задания уникального параметра\",\n\t\"131\": \"ошибка: не задан ИНН поставщика\",\n\t\"132\": \"ошибка: попытка задания количества уникального товара\",\n\t\"133\": \"ошибка: сбой принтера\",\n\t\"134\": \"неудача при записи на флэш-память\",\n\t\"135\": \"файл обновления не был загружен\",\n\t\"136\": \"текущая версия ФФД ФН не поддерживает операцию\",\n\t\"137\": \"текущая версия ФФД ФН не поддерживается\",\n\t\"138\": \"ошибочная последовательность команд\",\n\t\"139\": \"работа с подакцизными товарами запрещена\",\n\t\"140\": \"позиции с маркированными товарами в чеках расхода запрещены\",\n\t\"141\": \"сумма оплат видов безналичного расчета не равна размеру оплаты электронными\",\n\t\"142\": \"размер округления не должен превышать 99 копеек\",\n\t\"143\": \"сумма расчета по чеку в рублях не должна изменяться после округления\",\n\t\"144\": \"не задана часовая зона\",\n\t\"145\": \"не задан телефон или электронный адрес покупателя при расчете в сети “Интернет”\",\n\t\"200\": \"у команды есть неправильно заданные операнды\",\n\t\"201\": \"у команды есть не заданные операнды\",\n\t\"202\": \"ошибка задания режимов работы\",\n\t\"203\": \"ошибка задания расширенных режимов работы\",\n\t\"204\": \"ошибка задания параметра с датой/временем\",\n\t\"205\": \"ошибка задания параметра с ИНН\",\n\t\"206\": \"ошибка задания параметра с битовой маской\",\n\t\"207\": \"длина строки слишком большая\",\n\t\"208\": \"некорректные данные\",\n\t\"209\": \"команда допустима только при использовании внешнего клиента обмена\",\n\t\"210\": \"T1119 уже присутствует в T1115 суммы НДС чека\",\n\t\"401\": \"неизвестная команда ФН\",\n\t\"402\": \"некорректное состояние ФН\",\n\t\"403\": \"отказ ФН\",\n\t\"404\": \"отказ КС\",\n\t\"405\": \"параметры команды не соответствуют сроку жизни ФН\",\n\t\"407\": \"некорректная дата и/или время\",\n\t\"408\": \"нет запрошенных данных\",\n\t\"409\": \"некорректное значение параметров команды\",\n\t\"410\": \"некорректная команда\",\n\t\"411\": \"неразрешенные реквизиты\",\n\t\"412\": \"дублирование данных\",\n\t\"413\": \"отсутствуют данные, необходимые для корректного учета в ФН\",\n\t\"414\": \"количество позиций в документе превысило допустимый предел\",\n\t\"416\": \"превышение размеров TLV данных\",\n\t\"417\": \"нет транспортного соединения\",\n\t\"418\": \"исчерпан ресурс ФН\",\n\t\"420\": \"ограничение ресурса ФН\",\n\t\"422\": \"продолжительность смены превышена\",\n\t\"423\": \"некорректные данные о промежутке времени между фискальными документами\",\n\t\"424\": \"некорректный реквизит, переданный в ФН\",\n\t\"425\": \"реквизит не соответствует установкам при регистрации\",\n\t\"432\": \"сообщение ОФД не может быть принято\",\n\t\"435\": \"ошибка сервиса обновления ключей проверки КМ\",\n\t\"436\": \"неизвестный ответ сервиса обновления ключей проверки кодов проверки\",\n\t\"448\": \"ошибка: требуется повтор процедуры обновления ключей проверки КМ\",\n\t\"450\": \"запрещена работа с маркированным товарами\",\n\t\"451\": \"неверная последовательность подачи команд для обработки маркированных товаров\",\n\t\"452\": \"работа с маркированными товарами временно заблокирована\",\n\t\"453\": \"переполнена таблица проверки кодов маркировки\",\n\t\"454\": \"превышен период 90 дня со времени последнего обновления ключей проверки\",\n\t\"460\": \"в блоке TLV отсутствуют необходимые реквизиты\",\n\t\"462\": \"в реквизите 2007 содержится КМ, который ранее не проверялся в ФН\",\n\t\"500\": \"нет бумаги в принтере\",\n\t\"501\": \"крышка принтера открыта\",\n\t\"502\": \"состояние принтера не рабочее (OFFLINE)\",\n\t\"503\": \"сбой резака\",\n\t\"504\": \"есть другая ошибка принтера\",\n\t\"505\": \"принтер выключен\",\n\t\"506\": \"бумага заканчивается\",\n\t\"509\": \"принтер занят, идет печать\",\n\t\"510\": \"печатная форма документа не была завершена (сбой принтера)\",\n\t\"511\": \"нажата кнопка прогона бумаги\",\n\t\"600\": \"ошибка RTC при выдаче команды 'Прочитать дату/время'\",\n\t\"601\": \"ошибка RTC при выдаче команды 'Установить дату/время'\",\n\t\"602\": \"новые дата и время меньше даты и времени последнего оформленного фискального документа\",\n\t\"604\": \"ошибка: не удалось связаться с сервером ОИСМ\",\n\t\"605\": \"ошибка: получен пустой ответ от ОИСМ\",\n\t\"606\": \"ошибка: не удалось связаться с сервером ОКП\",\n\t\"607\": \"ошибка: получен пустой ответ от ОКП\",\n\t\"608\": \"общая ошибка работы с ОКП\",\n}\n\nfunc toUTF8(data []byte) ([]byte, error) {\n\tr, err := charset.NewReaderLabel(\"windows-1251\", bytes.NewReader(data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn io.ReadAll(r)\n}\n\n// ParseError разбирает XML-ответ с ошибкой ККТ и возвращает структуру Error\nfunc ParseError(data []byte) error {\n\tutf8Data, err := toUTF8(data)\n\tif err != nil {\n\t\tutf8Data = data\n\t}\n\n\ttype ErrorResp struct {\n\t\tNo  string `xml:\"No,attr\"`\n\t\tFSE string `xml:\"FSE,attr\"`\n\t\tTAG string `xml:\"TAG,attr\"`\n\t\tPAR string `xml:\"PAR,attr\"`\n\t}\n\tvar e ErrorResp\n\n\tif err := xml.Unmarshal(utf8Data, &e); err != nil {\n\t\treturn fmt.Errorf(\"ошибка ККТ (нераспознанная): %s\", string(data))\n\t}\n\n\tdesc, exists := ErrorDescriptions[e.No]\n\tif !exists {\n\t\tdesc = \"неизвестная ошибка\"\n\t}\n\n\tfseDesc := \"\"\n\tif e.FSE != \"\" {\n\t\tfseDesc, _ = ErrorDescriptions[e.FSE]\n\t}\n\n\treturn Error{\n\t\tCode:       e.No,\n\t\tMessage:    desc,\n\t\tTAG:        e.TAG,\n\t\tPAR:        e.PAR,\n\t\tFSECode:    e.FSE,\n\t\tFSEMessage: fseDesc,\n\t}\n}\n",
    "transport.go": "package mitsu\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"go.bug.st/serial\"\n\t\"golang.org/x/text/encoding/charmap\"\n\t\"golang.org/x/text/transform\"\n)\n\nconst (\n\tstx            = 0x02\n\tetx            = 0x03\n\tetb            = 0x17 // End of Transmission Block (для TCP пакетов)\n\ttcpDataChunkSz = 535  // Макс. кол-во данных в одном TCP пакете перед разбивкой\n)\n\n// Config определяет параметры для подключения к ККТ.\ntype Config struct {\n\tConnectionType int32            `json:\"connectionType\"`      // 0 - COM, 6 - TCP\n\tIPAddress      string           `json:\"ipAddress,omitempty\"` // TCP IP\n\tTCPPort        int32            `json:\"tcpPort,omitempty\"`   // TCP Port\n\tComName        string           `json:\"comName,omitempty\"`   // COM Port Name\n\tBaudRate       int32            `json:\"baudRate,omitempty\"`  // COM Speed\n\tTimeout        int              `json:\"timeout,omitempty\"`   // Timeout ms\n\tLogger         func(msg string) `json:\"-\"`\n}\n\n// Transport инкапсулирует логику работы с соединением (COM или TCP)\ntype Transport struct {\n\tconfig Config\n\tmu     sync.Mutex\n\tport   io.ReadWriteCloser // Используется только для COM\n}\n\n// NewTransport создаёт новый транспортный слой с заданными конфигурациями\nfunc NewTransport(config Config) *Transport {\n\tif config.Timeout == 0 {\n\t\tconfig.Timeout = 3000\n\t}\n\tif config.BaudRate == 0 {\n\t\tconfig.BaudRate = 115200\n\t}\n\treturn &Transport{config: config}\n}\n\n// Connect устанавливает соединение с устройством\nfunc (t *Transport) Connect() error {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn t.connectLocked()\n}\n\n// connectLocked выполняет подключение (должен вызываться только под мьютексом)\nfunc (t *Transport) connectLocked() error {\n\tvar err error\n\tswitch t.config.ConnectionType {\n\tcase 0: // COM\n\t\tif t.port != nil {\n\t\t\treturn nil\n\t\t}\n\t\tmode := &serial.Mode{\n\t\t\tBaudRate: int(t.config.BaudRate),\n\t\t\tDataBits: 8,\n\t\t\tParity:   serial.NoParity,\n\t\t\tStopBits: serial.OneStopBit,\n\t\t}\n\t\tt.port, err = serial.Open(t.config.ComName, mode)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"ошибка открытия COM-порта: %w\", err)\n\t\t}\n\t\tif p, ok := t.port.(serial.Port); ok {\n\t\t\tp.SetReadTimeout(time.Duration(t.config.Timeout) * time.Millisecond)\n\t\t}\n\n\tcase 6: // TCP/IP\n\t\t// Для TCP мы используем режим \"запрос-ответ\" с короткими соединениями.\n\t\t// Connect просто проверяет доступность хоста.\n\t\taddr := net.JoinHostPort(t.config.IPAddress, strconv.Itoa(int(t.config.TCPPort)))\n\t\tconn, err := net.DialTimeout(\"tcp\", addr, time.Duration(t.config.Timeout)*time.Millisecond)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"ошибка подключения TCP: %w\", err)\n\t\t}\n\t\t// Сразу закрываем, реальное соединение будет в performExchange\n\t\tconn.Close()\n\t\t// t.port остается nil для TCP\n\n\tdefault:\n\t\treturn fmt.Errorf(\"неизвестный тип подключения: %d\", t.config.ConnectionType)\n\t}\n\n\treturn nil\n}\n\n// Disconnect разрывает соединение с устройством\nfunc (t *Transport) Disconnect() error {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn t.disconnectLocked()\n}\n\n// disconnectLocked разрывает соединение (должен вызываться только под мьютексом)\nfunc (t *Transport) disconnectLocked() error {\n\tif t.port != nil {\n\t\tt.port.Close()\n\t\tt.port = nil\n\t}\n\treturn nil\n}\n\n// Send отправляет команду устройству с поддержкой фрейминга и повторных попыток\nfunc (t *Transport) Send(xmlCmd string, logEnabled bool) ([]byte, error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\t// Попытки нужны в основном для COM порта или если TCP моргнул\n\tattempts := 1\n\tif t.config.ConnectionType == 0 {\n\t\tattempts = 2\n\t}\n\n\tvar lastErr error\n\n\tfor i := 0; i < attempts; i++ {\n\t\t// 1. Проверяем состояние транспорта\n\t\tif t.config.ConnectionType == 0 && t.port == nil {\n\t\t\tif err := t.connectLocked(); err != nil {\n\t\t\t\tlastErr = err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// 2. Обмен\n\t\tresp, err := t.performExchange(xmlCmd, logEnabled)\n\t\tif err == nil {\n\t\t\treturn resp, nil\n\t\t}\n\n\t\tlastErr = err\n\n\t\t// 3. Retry логика (только для COM)\n\t\tif t.config.ConnectionType == 0 && i < attempts-1 {\n\t\t\tif t.config.Logger != nil {\n\t\t\t\tt.config.Logger(fmt.Sprintf(\"COM Error (%v). Retrying...\", err))\n\t\t\t}\n\t\t\tt.disconnectLocked()\n\t\t\ttime.Sleep(200 * time.Millisecond)\n\t\t\tcontinue\n\t\t}\n\t}\n\n\treturn nil, lastErr\n}\n\n// performExchange выполняет физическую отправку и прием данных (должен вызываться только под мьютексом)\nfunc (t *Transport) performExchange(xmlCmd string, logEnabled bool) ([]byte, error) {\n\tif t.config.Logger != nil && logEnabled {\n\t\tt.config.Logger(fmt.Sprintf(\">> TX: %s\", xmlCmd))\n\t}\n\n\t// 1. Подготовка данных (UTF-8 -> Win1251)\n\tdata, err := encodeCP1251(xmlCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar conn io.ReadWriteCloser\n\n\t// Инициализация соединения\n\tif t.config.ConnectionType == 0 {\n\t\t// --- COM ---\n\t\tif t.port == nil {\n\t\t\treturn nil, errors.New(\"port is closed\")\n\t\t}\n\t\tconn = t.port\n\t} else {\n\t\t// --- TCP: Transactional Mode ---\n\t\t// Открываем сокет на КАЖДЫЙ запрос\n\t\taddr := net.JoinHostPort(t.config.IPAddress, strconv.Itoa(int(t.config.TCPPort)))\n\t\tnetConn, err := net.DialTimeout(\"tcp\", addr, time.Duration(t.config.Timeout)*time.Millisecond)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer netConn.Close() // Гарантированно закрываем после обмена\n\n\t\tnetConn.SetDeadline(time.Now().Add(time.Duration(t.config.Timeout) * time.Millisecond))\n\t\tconn = netConn\n\t}\n\n\t// 2. Отправка (Framing)\n\tif t.config.ConnectionType == 0 {\n\t\t// --- COM Framing (STX...ETX) ---\n\t\tpacket := make([]byte, 0, len(data)+5)\n\t\tpacket = append(packet, stx)\n\t\tlenBuf := make([]byte, 2)\n\t\tbinary.LittleEndian.PutUint16(lenBuf, uint16(len(data)))\n\t\tpacket = append(packet, lenBuf...)\n\t\tpacket = append(packet, data...)\n\t\tpacket = append(packet, etx)\n\t\tlrc := byte(0)\n\t\tfor _, b := range packet {\n\t\t\tlrc ^= b\n\t\t}\n\t\tpacket = append(packet, lrc)\n\n\t\tif _, err := conn.Write(packet); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\t// --- TCP Framing (Chunked + ETB) ---\n\t\toffset := 0\n\t\ttotalLen := len(data)\n\n\t\tif totalLen == 0 {\n\t\t\treturn nil, errors.New(\"empty command\")\n\t\t}\n\n\t\tfor offset < totalLen {\n\t\t\tremaining := totalLen - offset\n\t\t\tchunkSize := remaining\n\t\t\tif chunkSize > tcpDataChunkSz {\n\t\t\t\tchunkSize = tcpDataChunkSz\n\t\t\t}\n\t\t\tchunk := data[offset : offset+chunkSize]\n\n\t\t\t// Нужно ли слать ETB? (если это НЕ последний пакет)\n\t\t\tisLastPacket := (offset + chunkSize) >= totalLen\n\n\t\t\tif _, err := conn.Write(chunk); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif !isLastPacket {\n\t\t\t\tif _, err := conn.Write([]byte{etb}); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset += chunkSize\n\t\t}\n\t}\n\n\t// 3. Чтение ответа\n\tvar responseData []byte\n\n\tif t.config.ConnectionType == 0 {\n\t\t// --- COM Reading ---\n\t\tbuf := make([]byte, 1)\n\t\treadBuf := make([]byte, 0, 1024)\n\t\tfor {\n\t\t\tn, err := conn.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif n == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treadBuf = append(readBuf, buf[0])\n\t\t\tif buf[0] == etx {\n\t\t\t\tlrcBuf := make([]byte, 1)\n\t\t\t\t_, err := io.ReadFull(conn, lrcBuf)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treadBuf = append(readBuf, lrcBuf[0])\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif len(readBuf) < 2 {\n\t\t\treturn nil, errors.New(\"short response\")\n\t\t}\n\t\tresponseData = readBuf[:len(readBuf)-2]\n\n\t} else {\n\t\t// --- TCP Reading ---\n\t\taccumulated := make([]byte, 0, 4096)\n\t\ttempBuf := make([]byte, 1024)\n\n\t\tfor {\n\t\t\tn, err := conn.Read(tempBuf)\n\t\t\tif err != nil {\n\t\t\t\t// EOF при TCP Transactional mode - это НОРМАЛЬНОЕ завершение,\n\t\t\t\t// если мы уже получили данные. Устройство закрыло соединение после ответа.\n\t\t\t\tif err == io.EOF && len(accumulated) > 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif n == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tchunk := tempBuf[:n]\n\n\t\t\t// Обработка ETB (признак продолжения)\n\t\t\thasEtb := false\n\t\t\tif len(chunk) > 0 && chunk[len(chunk)-1] == etb {\n\t\t\t\thasEtb = true\n\t\t\t\tchunk = chunk[:len(chunk)-1]\n\t\t\t}\n\n\t\t\taccumulated = append(accumulated, chunk...)\n\n\t\t\t// Если ETB нет, проверяем, не конец ли это XML\n\t\t\tif !hasEtb {\n\t\t\t\ttailLen := 50\n\t\t\t\tif len(accumulated) < tailLen {\n\t\t\t\t\ttailLen = len(accumulated)\n\t\t\t\t}\n\t\t\t\ttail := string(accumulated[len(accumulated)-tailLen:])\n\n\t\t\t\t// Если видим закрывающий тег, считаем ответ полным и выходим,\n\t\t\t\t// не дожидаясь таймаута или EOF.\n\t\t\t\tif strings.Contains(tail, \"/>\") ||\n\t\t\t\t\tstrings.Contains(tail, \"</OK>\") ||\n\t\t\t\t\tstrings.Contains(tail, \"</ERROR>\") ||\n\t\t\t\t\tstrings.Contains(tail, \"</ANS>\") ||\n\t\t\t\t\tstrings.Contains(tail, \"</Do>\") ||\n\t\t\t\t\tstrings.Contains(tail, \"</REG>\") {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresponseData = accumulated\n\t}\n\n\t// 4. Проверка на логические ошибки\n\tif bytes.Contains(responseData, []byte(\"ERROR\")) {\n\t\tif t.config.Logger != nil {\n\t\t\tdecodedLog, _ := toUTF8(responseData)\n\t\t\tt.config.Logger(fmt.Sprintf(\"<< RX (ERR): %s\", string(decodedLog)))\n\t\t}\n\t\treturn nil, ParseError(responseData)\n\t}\n\n\tif t.config.Logger != nil && logEnabled {\n\t\tdecodedLog, _ := toUTF8(responseData)\n\t\tt.config.Logger(fmt.Sprintf(\"<< RX: %s\", string(decodedLog)))\n\t}\n\n\treturn responseData, nil\n}\n\n// encodeCP1251 конвертирует строку из UTF-8 в Windows-1251\nfunc encodeCP1251(s string) ([]byte, error) {\n\tencoder := charmap.Windows1251.NewEncoder()\n\tres, _, err := transform.Bytes(encoder, []byte(s))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ошибка кодирования в WIN-1251: %w\", err)\n\t}\n\treturn res, nil\n}\n",
    "types.go": "package mitsu\n\n// DevResponse содержит ответ на команду GET DEV (См. п. 3.3)\ntype DevResponse struct {\n\tModel string `xml:\"DEV,attr\"`\n}\n\n// VerResponse содержит ответ на команду GET VER (См. п. 3.4)\ntype VerResponse struct {\n\tVersion string `xml:\"VER,attr\"`\n\tSize    string `xml:\"SIZE,attr\"`\n\tCrc32   string `xml:\"CRC32,attr\"`\n\tSerial  string `xml:\"SERIAL,attr\"`\n\tMac     string `xml:\"MAC,attr\"`\n\tStatus  string `xml:\"STS,attr\"`\n}\n\n// DateTimeResponse содержит ответ на команду GET DATE/TIME (См. п. 3.5)\ntype DateTimeResponse struct {\n\tDate string `xml:\"DATE,attr\"`\n\tTime string `xml:\"TIME,attr\"`\n}\n\n// PrinterSettings содержит настройки принтера.\ntype PrinterSettings struct {\n\tModel    string `xml:\"PRINTER,attr\"`\n\tBaudRate int    `xml:\"BAUDRATE,attr\"`\n\tPaper    int    `xml:\"PAPER,attr\"`\n\tFont     int    `xml:\"FONT,attr\"`\n\tWidth    int    `xml:\"WIDTH,attr\"`\n\tLength   int    `xml:\"LENGTH,attr\"`\n}\n\n// DrawerSettings содержит настройки денежного ящика.\ntype DrawerSettings struct {\n\tPin  int `xml:\"CD:PIN,attr\"`\n\tRise int `xml:\"RISE,attr\"`\n\tFall int `xml:\"FALL,attr\"`\n}\n\n// LanSettings содержит настройки сети.\ntype LanSettings struct {\n\tAddr string `xml:\"LAN,attr\"`\n\tPort int    `xml:\"PORT,attr\"`\n\tMask string `xml:\"MASK,attr\"`\n\tDns  string `xml:\"DNS,attr\"`\n\tGw   string `xml:\"GW,attr\"`\n}\n\n// OfdSettings содержит настройки ОФД.\ntype OfdSettings struct {\n\tAddr     string `xml:\"OFD,attr\"`\n\tPort     int    `xml:\"PORT,attr\"`\n\tClient   string `xml:\"CLIENT,attr\"`\n\tTimerFN  int    `xml:\"TimerFN,attr\"`\n\tTimerOFD int    `xml:\"TimerOFD,attr\"`\n}\n\n// OismSettings содержит настройки сервера OISM.\ntype OismSettings struct {\n\tAddr string `xml:\"OISM,attr\"`\n\tPort int    `xml:\"PORT,attr\"`\n}\n\n// ServerSettings содержит настройки сервера OKP.\ntype ServerSettings struct {\n\tAddr string `xml:\"ADDR,attr\"`\n\tOkp  string `xml:\"OKP,attr\"`\n\tPort int    `xml:\"PORT,attr\"`\n}\n\n// TaxRates содержит настройки налоговых ставок.\ntype TaxRates struct {\n\tT1  string `xml:\"T1,attr\"`  // 20%\n\tT2  string `xml:\"T2,attr\"`  // 10%\n\tT3  string `xml:\"T3,attr\"`  // 20/120\n\tT4  string `xml:\"T4,attr\"`  // 10/110\n\tT5  string `xml:\"T5,attr\"`  // 0%\n\tT6  string `xml:\"T6,attr\"`  // Без НДС\n\tT7  string `xml:\"T7,attr\"`  // 5%\n\tT8  string `xml:\"T8,attr\"`  // 7%\n\tT9  string `xml:\"T9,attr\"`  // 5/105\n\tT10 string `xml:\"T10,attr\"` // 7/107\n}\n\n// RegData содержит полные данные о регистрации ККТ (См. п. 3.16).\ntype RegData struct {\n\tRNM        string `xml:\"T1037,attr\"`\n\tInn        string `xml:\"T1018,attr\"`\n\tFfdVer     string `xml:\"T1209,attr\"`\n\tRegDate    string `xml:\"DATE,attr\"`\n\tRegTime    string `xml:\"TIME,attr\"`\n\tRegNumber  string `xml:\"REG,attr\"`   // Порядковый номер регистрации\n\tFdNumber   string `xml:\"FD,attr\"`    // Номер фискального документа\n\tFpNumber   string `xml:\"T1077,attr\"` // Фискальный признак из T1077\n\tBase       string `xml:\"BASE,attr\"`  // Коды причин регистрации\n\tTaxSystems string `xml:\"T1062,attr\"` // СНО (0,1,...)\n\tTaxBase    string `xml:\"T1062_Base,attr\"`\n\n\tModeMask    uint32 `xml:\"MODE,attr\"`\n\tExtModeMask uint32 `xml:\"ExtMODE,attr\"`\n\n\tMarkAttr      string `xml:\"MARK,attr\"`  // Маркировка\n\tExciseAttr    string `xml:\"T1207,attr\"` // Подакцизные\n\tInternetAttr  string `xml:\"T1108,attr\"` // Интернет\n\tServiceAttr   string `xml:\"T1109,attr\"` // Услуги\n\tBsoAttr       string `xml:\"T1110,attr\"` // БСО\n\tLotteryAttr   string `xml:\"T1126,attr\"` // Лотерея\n\tGamblingAttr  string `xml:\"T1193,attr\"` // Азартные\n\tPawnAttr      string `xml:\"PAWN,attr\"`  // Ломбард\n\tInsAttr       string `xml:\"INS,attr\"`   // Страхование\n\tDineAttr      string `xml:\"DINE,attr\"`  // Общепит\n\tOptAttr       string `xml:\"OPT,attr\"`   // Опт\n\tVendAttr      string `xml:\"VEND,attr\"`  // Вендинг\n\tAutoModeAttr  string `xml:\"T1001,attr\"` // Автоматический режим\n\tAutoNumAttr   string `xml:\"T1036,attr\"` // Номер автомата (атрибут)\n\tAutonomAttr   string `xml:\"T1002,attr\"` // Автономный\n\tEncryptAttr   string `xml:\"T1056,attr\"` // Шифрование\n\tPrintAutoAttr string `xml:\"T1221,attr\"` // Принтер в автомате\n\n\tOrgName     string `xml:\"T1048\"`\n\tAddress     string `xml:\"T1009\"`\n\tPlace       string `xml:\"T1187\"`\n\tOfdName     string `xml:\"T1046\"`\n\tOfdInn      string `xml:\"T1017,attr\"`\n\tSite        string `xml:\"T1060\"`\n\tEmailSender string `xml:\"T1117\"`\n\tAutoNumTag  string `xml:\"T1036\"`\n\n\tFnSerial      string // Заводской номер ФН\n\tFnEdition     string // Исполнение ФН\n\tPrinterSerial string // Серийный номер ФР\n}\n\n// ShiftStatus содержит информацию о текущей смене.\ntype ShiftStatus struct {\n\tShiftNum int    `xml:\"SHIFT,attr\"`\n\tState    string `xml:\"STATE,attr\"` // 0-закрыта, 1-открыта, 9-истекла\n\tCount    int    `xml:\"COUNT,attr\"`\n\tFdNum    int    `xml:\"FD,attr\"`\n\tKeyValid int    `xml:\"KeyValid,attr\"`\n\n\tOfd struct {\n\t\tCount int    `xml:\"COUNT,attr\"`\n\t\tFirst int    `xml:\"FIRST,attr\"`\n\t\tDate  string `xml:\"DATE,attr\"`\n\t\tTime  string `xml:\"TIME,attr\"`\n\t} `xml:\"OFD\"`\n}\n\n// ShiftTotals содержит итоги смены.\ntype ShiftTotals struct {\n\tShiftNum int `xml:\"SHIFT,attr\"`\n\tIncome   struct {\n\t\tCount string `xml:\"COUNT,attr\"`\n\t\tTotal string `xml:\"TOTAL,attr\"`\n\t} `xml:\"INCOME\"`\n\tPayout struct {\n\t\tCount string `xml:\"COUNT,attr\"`\n\t\tTotal string `xml:\"TOTAL,attr\"`\n\t} `xml:\"PAYOUT\"`\n\tCash struct {\n\t\tTotal string `xml:\"TOTAL,attr\"`\n\t} `xml:\"CASH\"`\n}\n\n// FnStatus содержит информацию о фискальном накопителе.\ntype FnStatus struct {\n\tSerial  string `xml:\"FN,attr\"`\n\tFfd     string `xml:\"FFD,attr\"`\n\tPhase   string `xml:\"PHASE,attr\"`\n\tValid   string `xml:\"VALID,attr\"`\n\tLastFD  int    `xml:\"LAST,attr\"`\n\tFlag    string `xml:\"FLAG,attr\"` // HEX маска предупреждений\n\tEdition string `xml:\"EDITION,attr\"`\n\tPower   string `xml:\"POWER,attr\"` // Флаг питания (1 = установлен, 0 = сброшен)\n}\n\n// OfdExchangeStatus содержит информацию об обмене с ОФД.\ntype OfdExchangeStatus struct {\n\tCount    int    `xml:\"COUNT,attr\"`\n\tFirstDoc int    `xml:\"FIRST,attr\"`\n\tDate     string `xml:\"DATE,attr\"`\n\tTime     string `xml:\"TIME,attr\"`\n}\n\n// MarkingStatus содержит информацию о маркировке.\ntype MarkingStatus struct {\n\tMarkState int    `xml:\"MARK,attr\"`\n\tKeep      int    `xml:\"KEEP,attr\"`\n\tFlag      string `xml:\"FLAG,attr\"`\n\tNotice    int    `xml:\"NOTICE,attr\"`\n\tHolds     int    `xml:\"HOLDS,attr\"`\n\tPending   int    `xml:\"PENDING,attr\"`\n\tWarning   int    `xml:\"WARNING,attr\"`\n}\n\n// RegResponse содержит ответ на команду регистрации/перерегистрации.\ntype RegResponse struct {\n\tFdNumber string `xml:\"FD,attr\"`    // Номер фискального документа\n\tFpNumber string `xml:\"T1077,attr\"` // Фискальный признак из T1077\n}\n\n// CloseFnResult содержит результат закрытия фискального архива.\ntype CloseFnResult struct {\n\tFD int    // номер фискального документа\n\tFP string // фискальный признак\n}\n\n// ReportFnCloseData содержит данные для отчета о закрытии фискального архива.\ntype ReportFnCloseData struct {\n\tDateTime  string\n\tFP        string\n\tFD        int\n\tRNM       string\n\tFNNumber  string\n\tKKTNumber string\n\tAddress   string\n\tPlace     string\n}\n\n// CashierResponse содержит ответ на команду GET CASHIER (См. п. 3.6)\ntype CashierResponse struct {\n\tName string `xml:\"CASHIER,attr\"`\n\tInn  string `xml:\"INN,attr\"`\n}\n\n// ComSettingsResponse содержит ответ на команду GET COM (См. п. 3.9)\ntype ComSettingsResponse struct {\n\tSpeed int32 `xml:\"COM,attr\"`\n}\n\n// HeaderLine содержит данные одной строки заголовка/подвала\ntype HeaderLine struct {\n\tText   string `xml:\",chardata\"`\n\tFormat string `xml:\"FORM,attr\"` // Реальный вариант\n\tF      string `xml:\"F,attr\"`    // Старый вариант из документации\n}\n\n// HeaderResponse содержит ответ на команду GET HEADER (См. п. 3.10)\ntype HeaderResponse struct {\n\tL0 HeaderLine `xml:\"L0\"`\n\tL1 HeaderLine `xml:\"L1\"`\n\tL2 HeaderLine `xml:\"L2\"`\n\tL3 HeaderLine `xml:\"L3\"`\n\tL4 HeaderLine `xml:\"L4\"`\n\tL5 HeaderLine `xml:\"L5\"`\n\tL6 HeaderLine `xml:\"L6\"`\n\tL7 HeaderLine `xml:\"L7\"`\n\tL8 HeaderLine `xml:\"L8\"`\n\tL9 HeaderLine `xml:\"L9\"`\n}\n\n// PowerStatusResponse содержит ответ на команду GET POWER (См. п. 3.33)\ntype PowerStatusResponse struct {\n\tPower int `xml:\"POWER,attr\"`\n}\n\n// TimezoneResponse содержит ответ на команду GET TIMEZONE (См. п. 3.35)\ntype TimezoneResponse struct {\n\tTimezone string `xml:\"TIMEZONE,attr\"`\n}\n\n// CurrentDocumentTypeResponse содержит ответ на команду GET DOC='0'\ntype CurrentDocumentTypeResponse struct {\n\tType int `xml:\"TYPE,attr\"`\n}\n\n// DocumentInfoResponse содержит информацию о документе (OFFSET и LENGTH) для команды GET DOC='X:{fd}'\ntype DocumentInfoResponse struct {\n\tOffset string `xml:\"OFFSET,attr\"`\n\tLength int    `xml:\"LENGTH,attr\"`\n}\n\n// ReadBlockResponse содержит ответ на команду READ (См. получения документа из ФН)\ntype ReadBlockResponse struct {\n\tLength int    `xml:\"LENGTH,attr\"`\n\tData   string `xml:\",innerxml\"`\n}\n\n// DeviceOptions содержит настройки устройства (b0-b9).\ntype DeviceOptions struct {\n\tB0 int `xml:\"b0,attr\"` // Разделители\n\tB1 int `xml:\"b1,attr\"` // QR позиция\n\tB2 int `xml:\"b2,attr\"` // Округление\n\tB3 int `xml:\"b3,attr\"` // Авто-резак\n\tB4 int `xml:\"b4,attr\"` // Авто-тест\n\tB5 int `xml:\"b5,attr\"` // Открытие ящика (триггер)\n\tB6 int `xml:\"b6,attr\"` // Звук конца бумаги\n\tB7 int `xml:\"b7,attr\"` // Текст рядом с QR\n\tB8 int `xml:\"b8,attr\"` // Печать кол-ва покупок\n\tB9 int `xml:\"b9,attr\"` // Базовая СНО\n}\n",
}

if __name__ == '__main__':
    print('=== Дерево проекта ===')
    print(project_tree)
    print('\n=== Список файлов ===')
    for name in project_files:
        print(f'- {name}')
