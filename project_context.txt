<!-- Project: mitsuscanner -->
<!-- Files: 44, Lines: 9572, Size: 268KB -->

<tree>
.
├── cmd/
│   ├── debug/
│   │   └── main.go
│   └── mitsuscanner/
│       ├── main.go
│       └── profiles.json
├── driver/
│   ├── cmd_do.go
│   ├── cmd_flash.go
│   ├── cmd_get.go
│   ├── cmd_ofd.go
│   ├── cmd_reg.go
│   ├── cmd_set.go
│   ├── decode.go
│   ├── errors.go
│   ├── interface.go
│   ├── mitsu_driver.go
│   ├── types.go
│   ├── types_test.go
│   └── utils.go
├── gui/
│   ├── connection_profiles.go
│   ├── dialog_diff.go
│   ├── dialog_reasons.go
│   ├── dialog_report.go
│   ├── execution.go
│   ├── helpers.go
│   ├── image_utils.go
│   ├── kkt_monitor.go
│   ├── network_scanner.go
│   ├── ofd_transfer.go
│   ├── tab_main.go
│   ├── tab_registration.go
│   └── tab_service.go
├── helps/
├── internal/
│   ├── cliche/
│   │   └── cliche.go
│   └── service/
│       ├── comparator.go
│       ├── models.go
│       └── time_logic.go
├── pkg/
│   └── ofdclient/
│       ├── client.go
│       ├── client_test.go
│       ├── crc.go
│       ├── doc.go
│       ├── errors.go
│       ├── protocol.go
│       ├── protocol_test.go
│       ├── transport.go
│       └── types.go
├── go.mod
└── go.sum
</tree>

<file path="go.mod">
module mitsuscanner

go 1.25.1

require (
	github.com/lxn/walk v0.0.0-20210112085537-c389da54e794
	go.bug.st/serial v1.6.4
	golang.org/x/image v0.34.0
	golang.org/x/net v0.47.0
	golang.org/x/text v0.32.0
)

require (
	github.com/creack/goselect v0.1.2 // indirect
	github.com/lxn/win v0.0.0-20210218163916-a377121e959e // indirect
	golang.org/x/sys v0.38.0 // indirect
	gopkg.in/Knetic/govaluate.v3 v3.0.0 // indirect
)
</file>

<file path="go.sum">
github.com/creack/goselect v0.1.2 h1:2DNy14+JPjRBgPzAd1thbQp4BSIihxcBf0IXhQXDRa0=
github.com/creack/goselect v0.1.2/go.mod h1:a/NhLweNvqIYMuxcMOuWY516Cimucms3DglDzQP3hKY=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/lxn/walk v0.0.0-20210112085537-c389da54e794 h1:NVRJ0Uy0SOFcXSKLsS65OmI1sgCCfiDUPj+cwnH7GZw=
github.com/lxn/walk v0.0.0-20210112085537-c389da54e794/go.mod h1:E23UucZGqpuUANJooIbHWCufXvOcT6E7Stq81gU+CSQ=
github.com/lxn/win v0.0.0-20210218163916-a377121e959e h1:H+t6A/QJMbhCSEH5rAuRxh+CtW96g0Or0Fxa9IKr4uc=
github.com/lxn/win v0.0.0-20210218163916-a377121e959e/go.mod h1:KxxjdtRkfNoYDCUP5ryK7XJJNTnpC8atvtmTheChOtk=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
go.bug.st/serial v1.6.4 h1:7FmqNPgVp3pu2Jz5PoPtbZ9jJO5gnEnZIvnI1lzve8A=
go.bug.st/serial v1.6.4/go.mod h1:nofMJxTeNVny/m6+KaafC6vJGj3miwQZ6vW4BZUGJPI=
golang.org/x/image v0.34.0 h1:33gCkyw9hmwbZJeZkct8XyR11yH889EQt/QH4VmXMn8=
golang.org/x/image v0.34.0/go.mod h1:2RNFBZRB+vnwwFil8GkMdRvrJOFd1AzdZI6vOY+eJVU=
golang.org/x/net v0.47.0 h1:Mx+4dIFzqraBXUugkia1OOvlD6LemFo1ALMHjrXDOhY=
golang.org/x/net v0.47.0/go.mod h1:/jNxtkgq5yWUGYkaZGqo27cfGZ1c5Nen03aYrrKpVRU=
golang.org/x/sys v0.0.0-20201018230417-eeed37f84f13/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.38.0 h1:3yZWxaJjBmCWXqhN1qh02AkOnCQ1poK6oF+a7xWL6Gc=
golang.org/x/sys v0.38.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.32.0 h1:ZD01bjUt1FQ9WJ0ClOL5vxgxOI/sVCNgX1YtKwcY0mU=
golang.org/x/text v0.32.0/go.mod h1:o/rUWzghvpD5TXrTIBuJU77MTaN0ljMWE47kxGJQ7jY=
gopkg.in/Knetic/govaluate.v3 v3.0.0 h1:18mUyIt4ZlRlFZAAfVetz4/rzlJs9yhN+U02F4u1AOc=
gopkg.in/Knetic/govaluate.v3 v3.0.0/go.mod h1:csKLBORsPbafmSCGTEh3U7Ozmsuq8ZSIlKk1bcqph0E=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
</file>

<file path="cmd\debug\main.go">
package main

import (
	"log"

	"github.com/lxn/walk"
	d "github.com/lxn/walk/declarative"

	"mitsuscanner/driver"
	"mitsuscanner/gui"
)

func main() {
	// Для отладки интерфейса с реальным подключением к ККТ используем MitsuDriver
	log.Printf("[DEBUG] Запуск в режиме реального подключения (MitsuDriver)...")

	// Инициализируем драйвер с дефолтными настройками (COM порт)
	config := driver.Config{
		ConnectionType: 0, // COM
		ComName:        "COM9",
		BaudRate:       115200,
		Timeout:        3000,
		Logger: func(msg string) {
			log.Printf("[DEBUG] %s", msg)
		},
	}
	realDriver := driver.NewMitsuDriver(config)
	driver.SetActive(realDriver)

	// Создаем структуру окна
	mw := new(walk.MainWindow)

	// ВАЖНО: Инициализируем глобальную переменную в пакете GUI,
	// чтобы loadServiceInitial не падал с nil pointer.
	gui.SetMainWindow(mw)

	// Получаем вкладку сервиса
	// Внутри GetServiceTab запустятся горутины, которые будут обращаться к gui.mw
	tab := gui.GetServiceTab()

	err := d.MainWindow{
		AssignTo: &mw,
		Title:    "DEBUG SERVICE TAB (REAL MODE)",
		MinSize:  d.Size{Width: 900, Height: 600},
		Layout:   d.VBox{},
		Children: []d.Widget{
			d.TabWidget{
				Pages: []d.TabPage{
					tab,
				},
			},
		},
	}.Create()

	if err != nil {
		panic(err)
	}

	mw.Run()
}
</file>

<file path="cmd\mitsuscanner\main.go">
package main

import (
	"mitsuscanner/gui"
)

func main() {
	// driver.SetActive(driver.NewMitsuDriver(driver.Config{}))
	gui.RunApp()
}
</file>

<file path="cmd\mitsuscanner\profiles.json">
{
  "profiles": [
    {
      "serial_number": "065001241114310",
      "connection_type": 6,
      "com_name": "",
      "baud_rate": 0,
      "ip_address": "10.25.1.202",
      "tcp_port": 8200,
      "firmware_ver": "1.3.0",
      "model_name": "MITSU 1-F",
      "last_used": "2026-01-16T04:06:13.5829334+03:00"
    }
  ]
}
</file>

<file path="internal\cliche\cliche.go">
package cliche

import (
	"fmt"
	"strconv"
)

// Props описывает свойства форматирования строки клише.
// Формат F='xxxxxx' (6 цифр).
type Props struct {
	Invert    bool // 1 цифра: 0-нет, 1-да
	Width     int  // 2 цифра: 0-8
	Height    int  // 3 цифра: 0-8
	Font      int  // 4 цифра: 0-настройка, 1-A, 2-B
	Underline int  // 5 цифра: 0-нет, 1-текст, 2-вся строка
	Align     int  // 6 цифра: 0-лево, 1-центр, 2-право
}

// Line представляет одну строку клише с текстом и настройками.
type Line struct {
	Text   string
	Format string // Сырая строка формата "xxxxxx"
	Props  Props  // Распаршенные свойства
}

// ParseFormat разбирает строку формата "xxxxxx" в структуру Props.
func ParseFormat(fmtStr string) Props {
	p := Props{}
	runes := []rune(fmtStr)

	// Добиваем нулями если строка короче 6 символов или пустая
	for len(runes) < 6 {
		runes = append(runes, '0')
	}

	p.Invert = (runes[0] == '1')
	p.Width = parseInt(runes[1])
	p.Height = parseInt(runes[2])
	p.Font = parseInt(runes[3])
	p.Underline = parseInt(runes[4])
	p.Align = parseInt(runes[5])

	return p
}

// BuildFormat собирает строку формата "xxxxxx" из структуры Props.
func BuildFormat(p Props) string {
	inv := 0
	if p.Invert {
		inv = 1
	}

	// Валидация диапазонов согласно документации
	w := clamp(p.Width, 0, 8)
	h := clamp(p.Height, 0, 8)
	f := clamp(p.Font, 0, 2)
	u := clamp(p.Underline, 0, 2)
	a := clamp(p.Align, 0, 2)

	return fmt.Sprintf("%d%d%d%d%d%d", inv, w, h, f, u, a)
}

// DefaultProps возвращает настройки по умолчанию ("000000").
func DefaultProps() Props {
	return Props{}
}

// --- Helpers ---

func parseInt(r rune) int {
	val, err := strconv.Atoi(string(r))
	if err != nil {
		return 0
	}
	return val
}

func clamp(val, min, max int) int {
	if val < min {
		return min
	}
	if val > max {
		return max
	}
	return val
}
</file>

<file path="internal\service\comparator.go">
package service

import (
	"fmt"
	"mitsuscanner/driver"
)

// Compare сравнивает два снапшота и возвращает список атомарных изменений.
func Compare(initial, current *SettingsSnapshot) []Change {
	var changes []Change

	if initial == nil || current == nil {
		return changes
	}

	// --- 1. ПРИНТЕР ---
	pOld, pNew := initial.Printer, current.Printer
	if pOld.Model != pNew.Model {
		changes = append(changes, Change{
			ID: "Printer_Model", Description: "Модель принтера",
			OldValue: pOld.Model, NewValue: pNew.Model, Priority: PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetPrinterSettings(current.Printer) },
		})
	}
	if pOld.BaudRate != pNew.BaudRate {
		changes = append(changes, Change{
			ID: "Printer_Baud", Description: "Скорость печати",
			OldValue: pOld.BaudRate, NewValue: pNew.BaudRate, Priority: PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetPrinterSettings(current.Printer) },
		})
	}
	if pOld.Paper != pNew.Paper {
		changes = append(changes, Change{
			ID: "Printer_Paper", Description: "Ширина ленты",
			OldValue: fmt.Sprintf("%dмм", pOld.Paper), NewValue: fmt.Sprintf("%dмм", pNew.Paper), Priority: PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetPrinterSettings(current.Printer) },
		})
	}
	if pOld.Font != pNew.Font {
		changes = append(changes, Change{
			ID: "Printer_Font", Description: "Шрифт принтера",
			OldValue: pOld.Font, NewValue: pNew.Font, Priority: PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetPrinterSettings(current.Printer) },
		})
	}

	// --- 2. ДЕНЕЖНЫЙ ЯЩИК ---
	dOld, dNew := initial.Drawer, current.Drawer
	if dOld.Pin != dNew.Pin || dOld.Rise != dNew.Rise || dOld.Fall != dNew.Fall {
		changes = append(changes, Change{
			ID: "Drawer_Settings", Description: "Параметры ден. ящика",
			OldValue:  fmt.Sprintf("Pin:%d, R:%d, F:%d", dOld.Pin, dOld.Rise, dOld.Fall),
			NewValue:  fmt.Sprintf("Pin:%d, R:%d, F:%d", dNew.Pin, dNew.Rise, dNew.Fall),
			Priority:  PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetMoneyDrawerSettings(current.Drawer) },
		})
	}

	// --- 3. ЧАСОВОЙ ПОЯС ---
	if initial.Timezone != current.Timezone {
		changes = append(changes, Change{
			ID: "Timezone", Description: "Часовой пояс",
			OldValue: initial.Timezone, NewValue: current.Timezone, Priority: PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetTimezone(current.Timezone) },
		})
	}

	// --- 4. ОПЦИИ (b1-b9) ---
	checkOption := func(id, name string, optNum int, oldV, newV int) {
		if oldV != newV {
			changes = append(changes, Change{
				ID: id, Description: "Опция: " + name,
				OldValue: oldV, NewValue: newV, Priority: PriorityNormal,
				ApplyFunc: func(d driver.Driver) error { return d.SetOption(optNum, newV) },
			})
		}
	}
	oO, oN := initial.Options, current.Options
	checkOption("Opt_QRPos", "Позиция QR", 1, oO.B1, oN.B1)
	checkOption("Opt_Rounding", "Округление", 2, oO.B2, oN.B2)
	checkOption("Opt_Cut", "Автоотрез", 3, oO.B3, oN.B3)
	checkOption("Opt_AutoTest", "Автотест", 4, oO.B4, oN.B4)
	checkOption("Opt_DrawerTrig", "Триггер ящика", 5, oO.B5, oN.B5)
	checkOption("Opt_NearEnd", "Датчик бумаги", 6, oO.B6, oN.B6)
	checkOption("Opt_TextQR", "Текст у QR", 7, oO.B7, oN.B7)
	checkOption("Opt_CountInCheck", "Счетчик покупок", 8, oO.B8, oN.B8)
	checkOption("Opt_B9", "СНО по умолчанию (b9)", 9, oO.B9, oN.B9)

	// --- 5. ОФД ---
	ofdO, ofdN := initial.Ofd, current.Ofd
	if ofdO.Addr != ofdN.Addr || ofdO.Port != ofdN.Port {
		changes = append(changes, Change{
			ID: "Ofd_Addr", Description: "Адрес сервера ОФД",
			OldValue:  fmt.Sprintf("%s:%d", ofdO.Addr, ofdO.Port),
			NewValue:  fmt.Sprintf("%s:%d", ofdN.Addr, ofdN.Port),
			Priority:  PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetOfdSettings(current.Ofd) },
		})
	}
	if ofdO.Client != ofdN.Client {
		changes = append(changes, Change{
			ID: "Ofd_Client", Description: "Режим клиента ОФД",
			OldValue: ofdO.Client, NewValue: ofdN.Client, Priority: PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetOfdSettings(current.Ofd) },
		})
	}
	if ofdO.TimerFN != ofdN.TimerFN || ofdO.TimerOFD != ofdN.TimerOFD {
		changes = append(changes, Change{
			ID: "Ofd_Timers", Description: "Таймеры ОФД/ФН",
			OldValue:  fmt.Sprintf("ФН:%d, ОФД:%d", ofdO.TimerFN, ofdO.TimerOFD),
			NewValue:  fmt.Sprintf("ФН:%d, ОФД:%d", ofdN.TimerFN, ofdN.TimerOFD),
			Priority:  PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetOfdSettings(current.Ofd) },
		})
	}

	// --- 6. ОИСМ ---
	if initial.Oism.Addr != current.Oism.Addr || initial.Oism.Port != current.Oism.Port {
		changes = append(changes, Change{
			ID: "Oism_Addr", Description: "Адрес сервера ОИСМ",
			OldValue:  fmt.Sprintf("%s:%d", initial.Oism.Addr, initial.Oism.Port),
			NewValue:  fmt.Sprintf("%s:%d", current.Oism.Addr, current.Oism.Port),
			Priority:  PriorityNormal,
			ApplyFunc: func(d driver.Driver) error { return d.SetOismSettings(current.Oism) },
		})
	}

	// --- 7. LAN ---
	lO, lN := initial.Lan, current.Lan
	if lO.Addr != lN.Addr || lO.Port != lN.Port || lO.Mask != lN.Mask || lO.Gw != lN.Gw || lO.Dns != lN.Dns {
		changes = append(changes, Change{
			ID: "Lan_Settings", Description: "Сетевые настройки LAN",
			OldValue:  fmt.Sprintf("IP:%s, P:%d", lO.Addr, lO.Port),
			NewValue:  fmt.Sprintf("IP:%s, P:%d", lN.Addr, lN.Port),
			Priority:  PriorityNetwork,
			ApplyFunc: func(d driver.Driver) error { return d.SetLanSettings(current.Lan) },
		})
	}

	// --- 8. КЛИШЕ (Построчное сравнение и запись) ---
	// ИЗМЕНЕНО: Теперь генерируем отдельные команды для каждой строки, которая изменилась
	// и не является пустой.
	clicheNames := map[int]string{1: "Заголовок", 2: "После пользователя", 3: "Подвал", 4: "Конец чека"}

	for typeID := 1; typeID <= 4; typeID++ {
		oldLines := initial.Cliches[typeID]
		newLines := current.Cliches[typeID]

		// Получаем максимальную длину, чтобы проверить все строки
		maxLen := len(oldLines)
		if len(newLines) > maxLen {
			maxLen = len(newLines)
		}

		for i := 0; i < maxLen; i++ {
			var oldL, newL driver.ClicheLineData
			if i < len(oldLines) {
				oldL = oldLines[i]
			}
			if i < len(newLines) {
				newL = newLines[i]
			}

			// Проверяем изменение
			if oldL.Text != newL.Text || oldL.Format != newL.Format {
				// ВАЖНО: Пропускаем пустые строки согласно требованию
				// "не отправлять нулевые и неизменённые строки"
				if newL.Text == "" {
					continue
				}

				tid := typeID
				lineNum := i
				// Замыкаем значения для ApplyFunc
				finalText := newL.Text
				finalFormat := newL.Format

				// Формируем описание для диалога
				oldVal := fmt.Sprintf("\"%s-%s\"", oldL.Format, oldL.Text)
				newVal := fmt.Sprintf("\"%s-%s\"", newL.Format, newL.Text)

				changes = append(changes, Change{
					ID:          fmt.Sprintf("Cliche_%d_%d", tid, lineNum),
					Description: fmt.Sprintf("Клише \"%s\", Строка %d", clicheNames[tid], lineNum+1),
					OldValue:    oldVal,
					NewValue:    newVal,
					Priority:    PriorityCliche,
					ApplyFunc: func(d driver.Driver) error {
						// Вызываем атомарную команду записи строки
						return d.SetHeaderLine(tid, lineNum, finalText, finalFormat)
					},
				})
			}
		}
	}

	return changes
}
</file>

<file path="internal\service\models.go">
package service

import (
	"mitsuscanner/driver"
)

// Priority определяет порядок применения настроек.
type Priority int

const (
	PriorityNormal   Priority = 0 // Обычные настройки (Опции, Принтер)
	PriorityCliche   Priority = 1 // Клише (много данных, лучше отдельно)
	PriorityNetwork  Priority = 2 // Сеть (может разорвать соединение, строго в конце)
	PriorityCritical Priority = 3 // Критические операции (если появятся)
)

// SettingsSnapshot представляет собой полный слепок настроек вкладки "Сервис".
type SettingsSnapshot struct {
	// Сеть и связь
	Ofd      driver.OfdSettings
	Oism     driver.ServerSettings
	Lan      driver.LanSettings
	Timezone int

	// Оборудование
	Printer driver.PrinterSettings
	Drawer  driver.DrawerSettings

	// Опции (b0-b9)
	// Храним как плоскую структуру для удобства сравнения
	Options driver.DeviceOptions

	// Клише
	// Ключ map - номер типа клише (1..4). Значение - массив строк.
	Cliches map[int][]driver.ClicheLineData
}

// Change представляет одно атомарное (или групповое) изменение настроек.
type Change struct {
	ID          string      // Уникальный ID поля (для подсветки в GUI)
	Description string      // Человекочитаемое описание изменения
	OldValue    interface{} // Значение "Было" (для отображения)
	NewValue    interface{} // Значение "Стало" (для отображения)
	Priority    Priority    // Приоритет выполнения

	// ApplyFunc - замыкание, которое применит это изменение к драйверу.
	// Будет сформировано на этапе сравнения.
	ApplyFunc func(d driver.Driver) error
}

// NewSettingsSnapshot создает пустой снапшот с инициализированной картой клише.
func NewSettingsSnapshot() *SettingsSnapshot {
	return &SettingsSnapshot{
		Cliches: make(map[int][]driver.ClicheLineData),
	}
}

// IsZero проверяет, пустой ли снапшот (используется для проверки инициализации).
func (s *SettingsSnapshot) IsZero() bool {
	return s == nil || len(s.Cliches) == 0
}

// Helper: deepEqual для срезов клише
func clichesEqual(a, b []driver.ClicheLineData) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}
</file>

<file path="internal\service\time_logic.go">
package service

import (
	"math"
	"time"
)

const TimeLayout = "02.01.2006 15:04:05"

// TimeStatus описывает состояние синхронизации времени.
type TimeStatus int

const (
	TimeStatusOk       TimeStatus = iota // Разница <= 5 минут
	TimeStatusCritical                   // Разница > 5 минут
	TimeStatusError                      // Ошибка парсинга или нет данных
)

// TimeLogic содержит методы для работы со временем ККТ.
type TimeLogic struct{}

// NewTimeLogic создает экземпляр сервиса.
func NewTimeLogic() *TimeLogic {
	return &TimeLogic{}
}

// ParseTime парсит строку времени из интерфейса.
func (s *TimeLogic) ParseTime(val string) (time.Time, error) {
	return time.Parse(TimeLayout, val)
}

// FormatTime форматирует время для отображения.
func (s *TimeLogic) FormatTime(t time.Time) string {
	return t.Format(TimeLayout)
}

// CompareTimes возвращает разницу между временем ККТ и целевым временем, а также статус.
func (s *TimeLogic) CompareTimes(kktTimeStr string, targetTime time.Time) (time.Duration, TimeStatus) {
	kktTime, err := s.ParseTime(kktTimeStr)
	if err != nil {
		return 0, TimeStatusError
	}

	diff := targetTime.Sub(kktTime)
	// Берем модуль разницы
	absDiff := time.Duration(math.Abs(float64(diff)))

	if absDiff > 5*time.Minute {
		return absDiff, TimeStatusCritical
	}

	return absDiff, TimeStatusOk
}
</file>

<file path="pkg\ofdclient\client.go">
package ofdclient

import (
	"context"
	"fmt"
	"time"
)

// Client определяет интерфейс OFD-клиента
type Client interface {
	// Send отправляет контейнер с документом в ОФД и возвращает квитанцию
	Send(ctx context.Context, req SendRequest) (*SendResponse, error)

	// Ping проверяет доступность сервера ОФД (служебный режим без контейнера)
	Ping(ctx context.Context, ofdAddress string, fnNumber string) error

	// Close освобождает ресурсы клиента
	Close() error
}

// New создает новый OFD-клиент с заданной конфигурацией
func New(cfg Config) Client {
	if cfg.Timeout == 0 {
		cfg.Timeout = 300 * time.Second // По спецификации ФНС
	}
	return &ofdClient{
		cfg:       cfg,
		transport: NewTCPTransport(cfg.Timeout, cfg.RetryCount, cfg.RetryInterval, cfg.Logger),
	}
}

// NewWithTransport создает клиент с пользовательским транспортом (для тестов)
func NewWithTransport(cfg Config, transport Transport) Client {
	if cfg.Timeout == 0 {
		cfg.Timeout = 300 * time.Second
	}
	return &ofdClient{
		cfg:       cfg,
		transport: transport,
	}
}

type ofdClient struct {
	cfg       Config
	transport Transport
}

// Send реализует отправку контейнера с документом в ОФД
func (c *ofdClient) Send(ctx context.Context, req SendRequest) (*SendResponse, error) {
	// Валидация
	if req.FnNumber == "" || len(req.FnNumber) != 16 {
		return nil, ErrInvalidFnNumber
	}
	if req.FFDVersion == "" {
		return nil, ErrInvalidFFDVersion
	}
	if len(req.Container) == 0 {
		return nil, ErrEmptyContainer
	}

	// Создаем заголовок сообщения с версией ФФД из запроса
	header, err := CreateMessageHeader(
		req.FnNumber,
		req.FFDVersion, // Используем версию из запроса!
		FlagCRCFull|FlagHasContainer,
		uint16(len(req.Container)),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create message header: %w", err)
	}

	// Сериализуем сообщение
	message, err := SerializeMessage(header, req.Container)
	if err != nil {
		return nil, fmt.Errorf("failed to serialize message: %w", err)
	}

	// Логируем отправку
	if c.cfg.Logger != nil {
		c.cfg.Logger(fmt.Sprintf("Sending document to OFD, FN: %s, FFD: %s, size: %d bytes",
			req.FnNumber, req.FFDVersion, len(req.Container)))
	}

	// Отправляем сообщение через транспорт
	response, err := c.transport.Send(ctx, req.OfdAddress, message)
	if err != nil {
		return nil, fmt.Errorf("failed to send message: %w", err)
	}

	// Десериализуем ответ
	_, respBody, err := DeserializeMessage(response)
	if err != nil {
		return nil, fmt.Errorf("failed to deserialize response: %w", err)
	}

	// Проверяем, что ответ содержит контейнер (квитанцию)
	if len(respBody) == 0 {
		return nil, ErrNoContainer
	}

	// Возвращаем квитанцию
	return &SendResponse{
		Receipt:    respBody,
		RawMessage: response,
	}, nil
}

// Ping проверяет доступность сервера ОФД
func (c *ofdClient) Ping(ctx context.Context, ofdAddress string, fnNumber string) error {
	if len(fnNumber) != 16 {
		return ErrInvalidFnNumber
	}

	// Создаем тестовое сообщение (только заголовок без тела)
	header, err := CreateMessageHeader(fnNumber, "1.2", FlagCRCHeader, 0)
	if err != nil {
		return fmt.Errorf("failed to create message header: %w", err)
	}

	// Сериализуем сообщение
	message, err := SerializeMessage(header, nil)
	if err != nil {
		return fmt.Errorf("failed to serialize message: %w", err)
	}

	// Отправляем сообщение
	_, err = c.transport.Send(ctx, ofdAddress, message)
	return err
}

// Close освобождает ресурсы клиента
func (c *ofdClient) Close() error {
	return c.transport.Close()
}
</file>

<file path="pkg\ofdclient\client_test.go">
package ofdclient

import (
	"context"
	"testing"
	"time"
)

// MockTransport — мок-транспорт для тестирования
type MockTransport struct {
	OnSend  func(ctx context.Context, address string, message []byte) ([]byte, error)
	OnClose func() error
}

func (m *MockTransport) Send(ctx context.Context, address string, message []byte) ([]byte, error) {
	if m.OnSend != nil {
		return m.OnSend(ctx, address, message)
	}
	return nil, nil
}

func (m *MockTransport) Close() error {
	if m.OnClose != nil {
		return m.OnClose()
	}
	return nil
}

// createValidResponse создает корректный ответ согласно спецификации
func createValidResponse(bodyData []byte) []byte {
	// Заголовок 30 байт + тело
	response := make([]byte, 30+len(bodyData))

	// Сигнатура: 2A 08 41 0A
	copy(response[0:4], []byte{0x2A, 0x08, 0x41, 0x0A})

	// S-Proto: 81 A2
	copy(response[4:6], []byte{0x81, 0xA2})

	// P-Proto (FFD 1.2): 01 20
	copy(response[6:8], []byte{0x01, 0x20})

	// FN Number
	copy(response[8:24], []byte("1234567890123456"))

	// BodySize (Little Endian)
	bodySize := uint16(len(bodyData))
	response[24] = byte(bodySize & 0xFF)
	response[25] = byte(bodySize >> 8)

	// Flags (Little Endian) - FlagCRCFull | FlagHasContainer = 0x06
	response[26] = 0x06
	response[27] = 0x00

	// CRC (Little Endian) - вычисляем
	crcData := make([]byte, 28+len(bodyData))
	copy(crcData[:28], response[:28])
	copy(crcData[28:], bodyData)
	crc := calcCRC16(crcData)
	response[28] = byte(crc & 0xFF)
	response[29] = byte(crc >> 8)

	// Тело
	copy(response[30:], bodyData)

	return response
}

// TestClientSend проверяет отправку сообщения клиентом
func TestClientSend(t *testing.T) {
	mockTransport := &MockTransport{}
	client := NewWithTransport(Config{
		Timeout:    300 * time.Second,
		RetryCount: 3,
	}, mockTransport)

	t.Run("Successful send", func(t *testing.T) {
		receiptData := []byte("RECEIPT_DATA")
		mockTransport.OnSend = func(ctx context.Context, address string, message []byte) ([]byte, error) {
			return createValidResponse(receiptData), nil
		}

		req := SendRequest{
			OfdAddress: "127.0.0.1:8080",
			FnNumber:   "1234567890123456",
			FFDVersion: "1.2",
			Container:  []byte("test container"),
		}

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		resp, err := client.Send(ctx, req)
		if err != nil {
			t.Fatalf("Failed to send message: %v", err)
		}

		if string(resp.Receipt) != string(receiptData) {
			t.Errorf("Receipt mismatch: got %s, expected %s", string(resp.Receipt), string(receiptData))
		}
	})

	t.Run("Invalid FN number", func(t *testing.T) {
		req := SendRequest{
			OfdAddress: "127.0.0.1:8080",
			FnNumber:   "12345", // Слишком короткий
			FFDVersion: "1.2",
			Container:  []byte("test container"),
		}

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		_, err := client.Send(ctx, req)
		if err == nil {
			t.Error("Expected error for invalid FN number, got nil")
		}
	})

	t.Run("Empty container", func(t *testing.T) {
		req := SendRequest{
			OfdAddress: "127.0.0.1:8080",
			FnNumber:   "1234567890123456",
			FFDVersion: "1.2",
			Container:  []byte{}, // Пустой
		}

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		_, err := client.Send(ctx, req)
		if err == nil {
			t.Error("Expected error for empty container, got nil")
		}
	})

	t.Run("Invalid FFD version", func(t *testing.T) {
		req := SendRequest{
			OfdAddress: "127.0.0.1:8080",
			FnNumber:   "1234567890123456",
			FFDVersion: "2.0", // Несуществующая версия
			Container:  []byte("test container"),
		}

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		_, err := client.Send(ctx, req)
		if err == nil {
			t.Error("Expected error for invalid FFD version, got nil")
		}
	})
}

// TestClientPing проверяет проверку доступности сервера
func TestClientPing(t *testing.T) {
	mockTransport := &MockTransport{}
	client := NewWithTransport(Config{
		Timeout:    300 * time.Second,
		RetryCount: 3,
	}, mockTransport)

	t.Run("Successful ping", func(t *testing.T) {
		mockTransport.OnSend = func(ctx context.Context, address string, message []byte) ([]byte, error) {
			// Возвращаем минимальный валидный ответ (только заголовок)
			return createValidResponse(nil), nil
		}

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		err := client.Ping(ctx, "127.0.0.1:8080", "1234567890123456")
		if err != nil {
			t.Fatalf("Failed to ping: %v", err)
		}
	})

	t.Run("Invalid FN number", func(t *testing.T) {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		err := client.Ping(ctx, "127.0.0.1:8080", "12345")
		if err == nil {
			t.Error("Expected error for invalid FN number, got nil")
		}
	})
}

// TestMessageBytes проверяет конкретные байты отправляемого сообщения
func TestMessageBytes(t *testing.T) {
	var capturedMessage []byte

	mockTransport := &MockTransport{
		OnSend: func(ctx context.Context, address string, message []byte) ([]byte, error) {
			capturedMessage = message
			return createValidResponse([]byte("OK")), nil
		},
	}

	client := NewWithTransport(Config{}, mockTransport)

	req := SendRequest{
		OfdAddress: "127.0.0.1:8080",
		FnNumber:   "9999078900012345",
		FFDVersion: "1.2",
		Container:  []byte{0x01, 0x02, 0x03},
	}

	ctx := context.Background()
	_, err := client.Send(ctx, req)
	if err != nil {
		t.Fatalf("Send failed: %v", err)
	}

	// Проверяем байты сообщения
	if len(capturedMessage) < 30 {
		t.Fatalf("Message too short: %d bytes", len(capturedMessage))
	}

	// Сигнатура: 2A 08 41 0A
	if capturedMessage[0] != 0x2A || capturedMessage[1] != 0x08 ||
		capturedMessage[2] != 0x41 || capturedMessage[3] != 0x0A {
		t.Errorf("Wrong signature: %X", capturedMessage[0:4])
	}

	// S-Proto: 81 A2
	if capturedMessage[4] != 0x81 || capturedMessage[5] != 0xA2 {
		t.Errorf("Wrong S-proto: %X", capturedMessage[4:6])
	}

	// P-Proto (1.2): 01 20
	if capturedMessage[6] != 0x01 || capturedMessage[7] != 0x20 {
		t.Errorf("Wrong P-proto: %X", capturedMessage[6:8])
	}

	// BodySize = 3 в Little Endian: 03 00
	if capturedMessage[24] != 0x03 || capturedMessage[25] != 0x00 {
		t.Errorf("Wrong BodySize: %X (expected 03 00)", capturedMessage[24:26])
	}

	// Flags = 0x06 в Little Endian: 06 00
	if capturedMessage[26] != 0x06 || capturedMessage[27] != 0x00 {
		t.Errorf("Wrong Flags: %X (expected 06 00)", capturedMessage[26:28])
	}

	t.Logf("Message bytes: %X", capturedMessage)
}
</file>

<file path="pkg\ofdclient\crc.go">
package ofdclient

// CRC16-CCITT реализация для протокола ОФД
// Полином: 0x1021 (стандарт CCITT)
// Начальное значение: 0xFFFF
// Рефлексия: нет
// XOR на выходе: 0x0000

// crc16Table — предвычисленная таблица для CRC16-CCITT
var crc16Table [256]uint16

func init() {
	poly := uint16(0x1021)
	for i := 0; i < 256; i++ {
		crc := uint16(i) << 8
		for j := 0; j < 8; j++ {
			if crc&0x8000 != 0 {
				crc = (crc << 1) ^ poly
			} else {
				crc <<= 1
			}
		}
		crc16Table[i] = crc
	}
}

// calcCRC16 вычисляет CRC16-CCITT для произвольных данных
func calcCRC16(data []byte) uint16 {
	crc := uint16(0xFFFF)
	for _, b := range data {
		crc = (crc << 8) ^ crc16Table[(crc>>8)^uint16(b)]
	}
	return crc
}

// CalculateCRC16 — публичная функция для расчета CRC16-CCITT
func CalculateCRC16(data []byte) uint16 {
	return calcCRC16(data)
}
</file>

<file path="pkg\ofdclient\doc.go">
// Package ofdclient provides a client for interacting with OFD (Operator of Fiscal Data) servers.
// It includes functionality for sending and receiving messages, handling errors, and managing
// transport connections. The package supports TCP transport with retry mechanisms and logging.
//
// Key Features:
//   - TCP transport with configurable timeouts and retry logic
//   - Message serialization and deserialization
//   - CRC calculation and validation
//   - Error handling and logging support
//   - Protocol-specific message handling
//
// Example Usage:
//
//	// Create a new TCP transport
//	transport := ofdclient.NewTCPTransport(
//	    10*time.Second,  // timeout
//	    3,                // retry count
//	    1*time.Second,    // retry delay
//	    func(msg string) { fmt.Println(msg) }, // logger
//	)
//
//	// Create a new OFD client
//	client := ofdclient.NewClient(transport)
//
//	// Send a message to the OFD server
//	response, err := client.SendMessage(context.Background(), "192.168.1.1:10000", message)
//	if err != nil {
//	    log.Fatal(err)
//	}
//
//	// Process the response
//	fmt.Println("Received response:", response)
//
// The package is designed to be extensible, allowing for custom transport implementations
// and additional protocol support as needed.
package ofdclient
</file>

<file path="pkg\ofdclient\errors.go">
package ofdclient

import (
	"errors"
	"fmt"
)

var (
	ErrInvalidFnNumber   = errors.New("ofdclient: invalid FN number (must be 16 digits)")
	ErrInvalidFFDVersion = errors.New("ofdclient: invalid FFD version")
	ErrConnectionFailed  = errors.New("ofdclient: connection to OFD failed")
	ErrTimeout           = errors.New("ofdclient: timeout waiting for response")
	ErrInvalidResponse   = errors.New("ofdclient: invalid response from OFD")
	ErrCRCMismatch       = errors.New("ofdclient: CRC mismatch in response")
	ErrNoContainer       = errors.New("ofdclient: response contains no container")
	ErrEmptyContainer    = errors.New("ofdclient: container is empty")
	ErrServerRejected    = errors.New("ofdclient: server rejected message")
)

// OfdError представляет ошибку от сервера ОФД
type OfdError struct {
	Code    int
	Message string
}

func (e *OfdError) Error() string {
	return fmt.Sprintf("ofdclient: OFD error %d: %s", e.Code, e.Message)
}
</file>

<file path="pkg\ofdclient\protocol.go">
package ofdclient

import (
	"encoding/binary"
	"errors"
	"fmt"
)

// MessageHeaderSize — размер заголовка сообщения в байтах
const MessageHeaderSize = 30

// SerializeMessage сериализует сообщение в байтовый поток согласно спецификации ФНС
// Порядок байт:
//   - Signature, SProtoVersion, PProtoVersion, FnNumber — порядок нумерации
//   - BodySize, Flags, CRC — Little Endian
//
// [0:4]   = 2A 08 41 0A     (сигнатура — порядок нумерации)
// [4:6]   = 81 A2           (S-proto — порядок нумерации)
// [6:8]   = 01 20           (FFD 1.2 — порядок нумерации)
// [24:26] = Little Endian   (BodySize)
// [26:28] = Little Endian   (Flags)
// [28:30] = Little Endian   (CRC)
func SerializeMessage(header *MessageHeader, body []byte) ([]byte, error) {
	if header == nil {
		return nil, errors.New("header cannot be nil")
	}

	buf := make([]byte, MessageHeaderSize+len(body))

	// Сигнатура — массив байт, порядок нумерации (копируем как есть)
	copy(buf[0:4], header.Signature[:])

	// Версия S-протокола — массив байт, порядок нумерации
	copy(buf[4:6], header.SProtoVersion[:])

	// Версия P-протокола — массив байт, порядок нумерации
	copy(buf[6:8], header.PProtoVersion[:])

	// Номер ФН — 16 байт ASCII
	copy(buf[8:24], header.FnNumber[:])

	// Размер тела — Little Endian!
	binary.LittleEndian.PutUint16(buf[24:26], header.BodySize)

	// Флаги — Little Endian!
	binary.LittleEndian.PutUint16(buf[26:28], uint16(header.Flags))

	// Тело сообщения
	if len(body) > 0 {
		copy(buf[MessageHeaderSize:], body)
	}

	// Вычисляем CRC в зависимости от флагов
	var crc uint16
	if header.Flags&FlagCRCFull != 0 {
		// CRC по заголовку (без поля CRC) + тело
		crc = calculateMessageCRC(buf[:28], body)
	} else if header.Flags&FlagCRCHeader != 0 {
		// CRC только по заголовку (без поля CRC)
		crc = calculateMessageCRC(buf[:28], nil)
	}

	// Записываем CRC — Little Endian!
	binary.LittleEndian.PutUint16(buf[28:30], crc)

	return buf, nil
}

// DeserializeMessage десериализует байтовый поток в сообщение
func DeserializeMessage(data []byte) (*MessageHeader, []byte, error) {
	if len(data) < MessageHeaderSize {
		return nil, nil, fmt.Errorf("message too short: %d < %d bytes", len(data), MessageHeaderSize)
	}

	header := &MessageHeader{}

	// Сигнатура — массив байт
	copy(header.Signature[:], data[0:4])

	// Версии — массивы байт
	copy(header.SProtoVersion[:], data[4:6])
	copy(header.PProtoVersion[:], data[6:8])

	// Номер ФН
	copy(header.FnNumber[:], data[8:24])

	// Размер тела — Little Endian!
	header.BodySize = binary.LittleEndian.Uint16(data[24:26])

	// Флаги — Little Endian!
	header.Flags = MessageFlags(binary.LittleEndian.Uint16(data[26:28]))

	// CRC — Little Endian!
	header.CRC = binary.LittleEndian.Uint16(data[28:30])

	// Тело
	var body []byte
	if header.BodySize > 0 && len(data) > MessageHeaderSize {
		bodyEnd := MessageHeaderSize + int(header.BodySize)
		if bodyEnd > len(data) {
			bodyEnd = len(data)
		}
		body = data[MessageHeaderSize:bodyEnd]
	}

	// Проверка CRC
	if header.Flags&FlagCRCFull != 0 {
		expectedCRC := calculateMessageCRC(data[:28], body)
		if header.CRC != expectedCRC {
			return nil, nil, fmt.Errorf("%w: got %04X, expected %04X", ErrCRCMismatch, header.CRC, expectedCRC)
		}
	} else if header.Flags&FlagCRCHeader != 0 {
		expectedCRC := calculateMessageCRC(data[:28], nil)
		if header.CRC != expectedCRC {
			return nil, nil, fmt.Errorf("%w: got %04X, expected %04X", ErrCRCMismatch, header.CRC, expectedCRC)
		}
	}

	return header, body, nil
}

// CreateMessageHeader создает заголовок сообщения с заданными параметрами
func CreateMessageHeader(fnNumber string, ffdVersion string, flags MessageFlags, bodySize uint16) (*MessageHeader, error) {
	if len(fnNumber) != 16 {
		return nil, fmt.Errorf("%w: got %d chars", ErrInvalidFnNumber, len(fnNumber))
	}

	pProtoBytes, err := FFDVersionToBytes(ffdVersion)
	if err != nil {
		return nil, err
	}

	header := &MessageHeader{
		Signature:     SignatureOFDBytes,
		SProtoVersion: SProtoVersionOFDBytes,
		PProtoVersion: pProtoBytes,
		BodySize:      bodySize,
		Flags:         flags,
	}

	copy(header.FnNumber[:], []byte(fnNumber))

	return header, nil
}

// SerializeContainer сериализует контейнер в байтовый поток
// Все поля в Little Endian
func SerializeContainer(header *ContainerHeader, data []byte) ([]byte, error) {
	if header == nil {
		return nil, errors.New("container header cannot be nil")
	}

	// Длина контейнера = заголовок (7 байт) + данные
	header.Length = uint16(7 + len(data))

	buf := make([]byte, 7+len(data))

	// Length — Little Endian
	binary.LittleEndian.PutUint16(buf[0:2], header.Length)

	// CRC вычисляем позже, пока пропускаем (байты 2-3)

	buf[4] = header.ContainerType
	buf[5] = header.DataType
	buf[6] = header.FormatVersion

	// Данные
	if len(data) > 0 {
		copy(buf[7:], data)
	}

	// Вычисляем CRC контейнера (по Length + Type + DataType + FormatVersion + Data, без CRC)
	crcData := make([]byte, 2+3+len(data))
	copy(crcData[0:2], buf[0:2]) // Length
	copy(crcData[2:5], buf[4:7]) // Type, DataType, FormatVersion
	copy(crcData[5:], buf[7:])   // Data
	crc := calcCRC16(crcData)

	// CRC — Little Endian
	binary.LittleEndian.PutUint16(buf[2:4], crc)

	return buf, nil
}

// DeserializeContainer десериализует байтовый поток в контейнер
func DeserializeContainer(data []byte) (*ContainerHeader, []byte, error) {
	if len(data) < 7 {
		return nil, nil, errors.New("container too short, must be at least 7 bytes")
	}

	header := &ContainerHeader{}

	// Little Endian
	header.Length = binary.LittleEndian.Uint16(data[0:2])
	header.CRC = binary.LittleEndian.Uint16(data[2:4])
	header.ContainerType = data[4]
	header.DataType = data[5]
	header.FormatVersion = data[6]

	// Данные
	var containerData []byte
	if len(data) > 7 {
		containerData = data[7:]
	}

	// Проверяем CRC
	crcData := make([]byte, 2+3+len(containerData))
	copy(crcData[0:2], data[0:2])
	copy(crcData[2:5], data[4:7])
	copy(crcData[5:], containerData)
	expectedCRC := calcCRC16(crcData)

	if header.CRC != expectedCRC {
		return nil, nil, fmt.Errorf("container CRC mismatch: got %04X, expected %04X", header.CRC, expectedCRC)
	}

	return header, containerData, nil
}

// CreateContainerHeader создает заголовок контейнера
func CreateContainerHeader(containerType byte, dataType byte, formatVersion byte) *ContainerHeader {
	return &ContainerHeader{
		ContainerType: containerType,
		DataType:      dataType,
		FormatVersion: formatVersion,
	}
}

// calculateMessageCRC вычисляет CRC для заголовка сообщения (и опционально тела)
// headerWithoutCRC должен быть 28 байт (заголовок без поля CRC)
func calculateMessageCRC(headerWithoutCRC []byte, body []byte) uint16 {
	if body == nil {
		return calcCRC16(headerWithoutCRC)
	}
	data := make([]byte, len(headerWithoutCRC)+len(body))
	copy(data, headerWithoutCRC)
	copy(data[len(headerWithoutCRC):], body)
	return calcCRC16(data)
}
</file>

<file path="pkg\ofdclient\protocol_test.go">
package ofdclient

import (
	"testing"
)

// TestMessageFormat проверяет формат сообщения согласно спецификации ФНС
func TestMessageFormat(t *testing.T) {
	t.Run("Valid message format per FNS spec", func(t *testing.T) {
		fnNumber := "9999078900012345"
		header, err := CreateMessageHeader(fnNumber, "1.2", FlagCRCFull|FlagHasContainer, 100)
		if err != nil {
			t.Fatalf("Failed to create message header: %v", err)
		}

		body := make([]byte, 100)
		message, err := SerializeMessage(header, body)
		if err != nil {
			t.Fatalf("Failed to serialize message: %v", err)
		}

		// Проверяем длину сообщения
		expectedLen := 30 + 100
		if len(message) != expectedLen {
			t.Errorf("Wrong message length: got %d, expected %d", len(message), expectedLen)
		}

		// === Проверяем сигнатуру ===
		// По спецификации: '2A08410A'h → байты [0x2A, 0x08, 0x41, 0x0A]
		expectedSignature := []byte{0x2A, 0x08, 0x41, 0x0A}
		for i, b := range expectedSignature {
			if message[i] != b {
				t.Errorf("Wrong signature byte[%d]: got %02X, expected %02X", i, message[i], b)
			}
		}

		// === Проверяем версию S-протокола ===
		// По спецификации: '81A2'h → байты [0x81, 0xA2]
		expectedSProto := []byte{0x81, 0xA2}
		for i, b := range expectedSProto {
			if message[4+i] != b {
				t.Errorf("Wrong S-proto byte[%d]: got %02X, expected %02X", i, message[4+i], b)
			}
		}

		// === Проверяем версию P-протокола (FFD 1.2) ===
		// По спецификации: '0120'h → байты [0x01, 0x20]
		expectedPProto := []byte{0x01, 0x20}
		for i, b := range expectedPProto {
			if message[6+i] != b {
				t.Errorf("Wrong P-proto byte[%d]: got %02X, expected %02X", i, message[6+i], b)
			}
		}

		// === Проверяем номер ФН ===
		expectedFnBytes := []byte("9999078900012345")
		for i := 0; i < 16; i++ {
			if message[8+i] != expectedFnBytes[i] {
				t.Errorf("Wrong FN byte[%d]: got %02X, expected %02X", i, message[8+i], expectedFnBytes[i])
			}
		}

		// === Проверяем BodySize в Little Endian ===
		// 100 = 0x0064 → в LE: [0x64, 0x00]
		if message[24] != 0x64 || message[25] != 0x00 {
			t.Errorf("Wrong BodySize: got %02X %02X, expected 64 00 (Little Endian)", message[24], message[25])
		}

		// === Проверяем флаги в Little Endian ===
		// FlagCRCFull|FlagHasContainer = 0x06 → в LE: [0x06, 0x00]
		expectedFlags := uint16(FlagCRCFull | FlagHasContainer)
		if message[26] != byte(expectedFlags&0xFF) || message[27] != byte(expectedFlags>>8) {
			t.Errorf("Wrong flags: got %02X %02X, expected %02X %02X (Little Endian)",
				message[26], message[27], byte(expectedFlags&0xFF), byte(expectedFlags>>8))
		}

		// === Проверяем что CRC записан (не проверяем значение, только что не нули) ===
		// CRC должен быть вычислен и записан
		crcBytes := message[28:30]
		t.Logf("CRC bytes: %02X %02X", crcBytes[0], crcBytes[1])
	})
}

// TestFFDVersions проверяет конвертацию версий ФФД
func TestFFDVersions(t *testing.T) {
	tests := []struct {
		version  string
		expected [2]byte
	}{
		{"1.0", [2]byte{0x01, 0x00}},
		{"1.05", [2]byte{0x01, 0x05}},
		{"1.1", [2]byte{0x01, 0x10}},
		{"1.2", [2]byte{0x01, 0x20}},
	}

	for _, tt := range tests {
		t.Run(tt.version, func(t *testing.T) {
			result, err := FFDVersionToBytes(tt.version)
			if err != nil {
				t.Fatalf("FFDVersionToBytes(%s) error: %v", tt.version, err)
			}
			if result != tt.expected {
				t.Errorf("FFDVersionToBytes(%s) = %v, expected %v", tt.version, result, tt.expected)
			}
		})
	}
}

// TestSerializeDeserializeRoundtrip проверяет что сериализация/десериализация работает корректно
func TestSerializeDeserializeRoundtrip(t *testing.T) {
	fnNumber := "1234567890123456"
	header, err := CreateMessageHeader(fnNumber, "1.2", FlagCRCFull|FlagHasContainer, 10)
	if err != nil {
		t.Fatalf("CreateMessageHeader error: %v", err)
	}

	body := []byte("0123456789")
	message, err := SerializeMessage(header, body)
	if err != nil {
		t.Fatalf("SerializeMessage error: %v", err)
	}

	// Десериализуем
	parsedHeader, parsedBody, err := DeserializeMessage(message)
	if err != nil {
		t.Fatalf("DeserializeMessage error: %v", err)
	}

	// Проверяем заголовок
	if parsedHeader.Signature != header.Signature {
		t.Errorf("Signature mismatch: %v != %v", parsedHeader.Signature, header.Signature)
	}
	if parsedHeader.SProtoVersion != header.SProtoVersion {
		t.Errorf("SProtoVersion mismatch: %v != %v", parsedHeader.SProtoVersion, header.SProtoVersion)
	}
	if parsedHeader.PProtoVersion != header.PProtoVersion {
		t.Errorf("PProtoVersion mismatch: %v != %v", parsedHeader.PProtoVersion, header.PProtoVersion)
	}
	if parsedHeader.FnNumber != header.FnNumber {
		t.Errorf("FnNumber mismatch: %v != %v", parsedHeader.FnNumber, header.FnNumber)
	}
	if parsedHeader.BodySize != header.BodySize {
		t.Errorf("BodySize mismatch: %d != %d", parsedHeader.BodySize, header.BodySize)
	}
	if parsedHeader.Flags != header.Flags {
		t.Errorf("Flags mismatch: %v != %v", parsedHeader.Flags, header.Flags)
	}

	// Проверяем тело
	if string(parsedBody) != string(body) {
		t.Errorf("Body mismatch: %s != %s", string(parsedBody), string(body))
	}
}

// TestCRCMismatch проверяет что неверный CRC вызывает ошибку
func TestCRCMismatch(t *testing.T) {
	fnNumber := "1234567890123456"
	header, _ := CreateMessageHeader(fnNumber, "1.2", FlagCRCFull, 5)
	body := []byte("12345")
	message, _ := SerializeMessage(header, body)

	// Портим CRC
	message[28] ^= 0xFF
	message[29] ^= 0xFF

	_, _, err := DeserializeMessage(message)
	if err == nil {
		t.Error("Expected CRC mismatch error, got nil")
	}
}

// TestInvalidFnNumber проверяет валидацию номера ФН
func TestInvalidFnNumber(t *testing.T) {
	tests := []string{
		"",
		"123",
		"12345678901234567", // 17 символов
		"123456789012345",   // 15 символов
	}

	for _, fn := range tests {
		t.Run(fn, func(t *testing.T) {
			_, err := CreateMessageHeader(fn, "1.2", FlagCRCHeader, 0)
			if err == nil {
				t.Errorf("Expected error for FN '%s', got nil", fn)
			}
		})
	}
}
</file>

<file path="pkg\ofdclient\transport.go">
package ofdclient

import (
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"
	"time"
)

// Transport определяет интерфейс транспорта для связи с ОФД
type Transport interface {
	// Send отправляет сообщение и возвращает ответ
	Send(ctx context.Context, address string, message []byte) ([]byte, error)

	// Close закрывает соединение
	Close() error
}

// TCPTransport реализует транспорт на основе TCP
type TCPTransport struct {
	conn       net.Conn
	timeout    time.Duration
	retryCount int
	retryDelay time.Duration
	logger     func(string)
}

// NewTCPTransport создает новый TCP транспорт
func NewTCPTransport(timeout time.Duration, retryCount int, retryDelay time.Duration, logger func(string)) *TCPTransport {
	return &TCPTransport{
		timeout:    timeout,
		retryCount: retryCount,
		retryDelay: retryDelay,
		logger:     logger,
	}
}

// Send реализует отправку сообщения через TCP
func (t *TCPTransport) Send(ctx context.Context, address string, message []byte) ([]byte, error) {
	var err error

	// Логируем попытку соединения
	if t.logger != nil {
		t.logger(fmt.Sprintf("Connecting to %s", address))
	}

	// Устанавливаем соединение с повторными попытками
	for i := 0; i <= t.retryCount; i++ {
		// Проверяем контекст на отмену
		if ctx.Err() != nil {
			return nil, ctx.Err()
		}

		// Устанавливаем соединение
		dialer := &net.Dialer{
			Timeout: t.timeout,
		}

		t.conn, err = dialer.DialContext(ctx, "tcp", address)
		if err == nil {
			break // Успешно подключились
		}

		// Логируем ошибку подключения
		if t.logger != nil {
			t.logger(fmt.Sprintf("Connection attempt %d failed: %v", i+1, err))
		}

		// Если это не последняя попытка, ждем перед повторной попыткой
		if i < t.retryCount {
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			case <-time.After(t.retryDelay):
			}
		}
	}

	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrConnectionFailed, err)
	}
	defer t.conn.Close()

	// Логируем успешное подключение
	if t.logger != nil {
		t.logger(fmt.Sprintf("Connected to %s", address))
	}

	// Устанавливаем таймаут для соединения
	if err := t.conn.SetDeadline(time.Now().Add(t.timeout)); err != nil {
		return nil, fmt.Errorf("failed to set deadline: %w", err)
	}

	// Отправляем сообщение
	if t.logger != nil {
		t.logger(fmt.Sprintf("Sending %d bytes", len(message)))
	}

	n, err := t.conn.Write(message)
	if err != nil {
		return nil, fmt.Errorf("failed to send message: %w", err)
	}

	if n != len(message) {
		return nil, errors.New("failed to send complete message")
	}

	// Логируем успешную отправку
	if t.logger != nil {
		t.logger("Message sent successfully")
	}

	// === ИСПРАВЛЕНО: Читаем ответ согласно спецификации ===
	// Шаг 1: Читаем заголовок ответа (30 байт)
	headerBuf := make([]byte, MessageHeaderSize)
	if _, err := io.ReadFull(t.conn, headerBuf); err != nil {
		return nil, fmt.Errorf("failed to read response header: %w", err)
	}

	// Шаг 2: Извлекаем размер тела из байтов 24-25 (Little Endian!)
	bodySize := binary.LittleEndian.Uint16(headerBuf[24:26])

	if t.logger != nil {
		t.logger(fmt.Sprintf("Response header received, body size: %d bytes", bodySize))
	}

	// Шаг 3: Читаем тело если есть
	var response []byte
	if bodySize > 0 {
		bodyBuf := make([]byte, bodySize)
		if _, err := io.ReadFull(t.conn, bodyBuf); err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
		// Собираем полное сообщение: заголовок + тело
		response = make([]byte, MessageHeaderSize+int(bodySize))
		copy(response[:MessageHeaderSize], headerBuf)
		copy(response[MessageHeaderSize:], bodyBuf)
	} else {
		// Только заголовок
		response = headerBuf
	}

	// Логируем успешное получение ответа
	if t.logger != nil {
		t.logger(fmt.Sprintf("Received complete response: %d bytes", len(response)))
	}

	return response, nil
}

// Close закрывает соединение
func (t *TCPTransport) Close() error {
	if t.conn != nil {
		return t.conn.Close()
	}
	return nil
}

// Ping проверяет доступность сервера ОФД
func (t *TCPTransport) Ping(ctx context.Context, address string, fnNumber string) error {
	// Создаем тестовое сообщение (только заголовок без тела)
	header, err := CreateMessageHeader(fnNumber, "1.2", FlagCRCHeader, 0)
	if err != nil {
		return err
	}

	// Сериализуем сообщение
	message, err := SerializeMessage(header, nil)
	if err != nil {
		return err
	}

	// Отправляем сообщение
	_, err = t.Send(ctx, address, message)
	return err
}
</file>

<file path="pkg\ofdclient\types.go">
package ofdclient

import (
	"fmt"
	"time"
)

// Константы сигнатур — байты в порядке нумерации согласно спецификации
// Сигнатура ОФД: '2A08410A'h → байты [0x2A, 0x08, 0x41, 0x0A]
var SignatureOFDBytes = [4]byte{0x2A, 0x08, 0x41, 0x0A}

// Сигнатура ОИСМ: 'DD80CAA1'h → байты [0xDD, 0x80, 0xCA, 0xA1]
var SignatureOISMBytes = [4]byte{0xDD, 0x80, 0xCA, 0xA1}

// Константы версий S-протокола — байты в порядке нумерации
// '81A2'h → байты [0x81, 0xA2]
var SProtoVersionOFDBytes = [2]byte{0x81, 0xA2}

// '82FB'h → байты [0x82, 0xFB] — тестовые посылки
var SProtoVersionOFDTestBytes = [2]byte{0x82, 0xFB}

// '82A2'h → байты [0x82, 0xA2]
var SProtoVersionOISMBytes = [2]byte{0x82, 0xA2}

// Версии P-протокола (ФФД) — байты в порядке нумерации
// ФФД 1.0:  '0100'h → [0x01, 0x00]
// ФФД 1.05: '0105'h → [0x01, 0x05]
// ФФД 1.1:  '0110'h → [0x01, 0x10]
// ФФД 1.2:  '0120'h → [0x01, 0x20]
var (
	PProtoFFD10Bytes  = [2]byte{0x01, 0x00}
	PProtoFFD105Bytes = [2]byte{0x01, 0x05}
	PProtoFFD11Bytes  = [2]byte{0x01, 0x10}
	PProtoFFD12Bytes  = [2]byte{0x01, 0x20}
)

// Флаги сообщения (Little Endian при сериализации)
type MessageFlags uint16

const (
	FlagCRCNone        MessageFlags = 0b00     // Биты 0-1: без CRC
	FlagCRCHeader      MessageFlags = 0b01     // CRC только заголовка
	FlagCRCFull        MessageFlags = 0b10     // CRC заголовка + тела
	FlagHasContainer   MessageFlags = 0b0100   // Бит 2: есть контейнер
	FlagExpectResponse MessageFlags = 0b010000 // Биты 4-5: ожидаем ответ
)

// MessageHeader — заголовок сообщения протокола (30 байт)
// Порядок байт:
//   - Signature, SProtoVersion, PProtoVersion, FnNumber — порядок нумерации (как массивы байт)
//   - BodySize, Flags, CRC — Little Endian
type MessageHeader struct {
	Signature     [4]byte      // 4 байта, порядок нумерации
	SProtoVersion [2]byte      // 2 байта, порядок нумерации
	PProtoVersion [2]byte      // 2 байта, порядок нумерации
	FnNumber      [16]byte     // 16 байт ASCII
	BodySize      uint16       // 2 байта, Little Endian
	Flags         MessageFlags // 2 байта, Little Endian
	CRC           uint16       // 2 байта, Little Endian
}

// FFDVersionToBytes конвертирует строковую версию ФФД в байты протокола
func FFDVersionToBytes(version string) ([2]byte, error) {
	switch version {
	case "1.0", "1.00", "1":
		return PProtoFFD10Bytes, nil
	case "1.05":
		return PProtoFFD105Bytes, nil
	case "1.1", "1.10":
		return PProtoFFD11Bytes, nil
	case "1.2", "1.20":
		return PProtoFFD12Bytes, nil
	default:
		return [2]byte{}, fmt.Errorf("%w: %s", ErrInvalidFFDVersion, version)
	}
}

// FnFFDCodeToVersion конвертирует код ФФД из статуса ФН в строку версии
// Коды из ФН: "2" = 1.05, "3" = 1.1, "4" = 1.2
func FnFFDCodeToVersion(ffdCode string) string {
	switch ffdCode {
	case "2":
		return "1.05"
	case "3":
		return "1.1"
	case "4":
		return "1.2"
	default:
		return "1.0"
	}
}

// ContainerHeader — заголовок контейнера (минимум 7 байт)
// Все поля в Little Endian
type ContainerHeader struct {
	Length        uint16 // Little Endian
	CRC           uint16 // Little Endian
	ContainerType byte
	DataType      byte
	FormatVersion byte
}

// SendRequest — запрос на отправку документа
type SendRequest struct {
	OfdAddress string // host:port
	FnNumber   string // 16-значный номер ФН
	FFDVersion string // "1.0", "1.05", "1.1", "1.2"
	Container  []byte // Контейнер с документом (получен от ККТ)
}

// SendResponse — ответ от ОФД
type SendResponse struct {
	Receipt    []byte // Квитанция для записи в ФН
	RawMessage []byte // Полное сырое сообщение (для отладки)
}

// Config — конфигурация клиента
type Config struct {
	Timeout       time.Duration // Таймаут ожидания ответа (по умолчанию 300с)
	RetryCount    int           // Количество попыток переподключения
	RetryInterval time.Duration // Интервал между попытками
	Logger        func(string)  // Опциональный логгер
}
</file>

<file path="driver\cmd_do.go">
package driver

import (
	"fmt"
)

// OpenShift открывает смену.
func (d *mitsuDriver) OpenShift(operator string) error {
	// Устанавливаем кассира перед открытием смены
	if operator != "" {
		if err := d.SetCashier(operator, ""); err != nil {
			return fmt.Errorf("ошибка установки кассира: %w", err)
		}
	}

	// Открываем смену
	_, err := d.sendCommand("<Do SHIFT='OPEN'/>")
	return err
}

// CloseShift закрывает смену.
func (d *mitsuDriver) CloseShift(operator string) error {
	// Устанавливаем кассира перед закрытием смены
	if operator != "" {
		if err := d.SetCashier(operator, ""); err != nil {
			return fmt.Errorf("ошибка установки кассира: %w", err)
		}
	}

	// Закрываем смену
	_, err := d.sendCommand("<Do SHIFT='CLOSE'/>")
	return err
}

// PrintXReport печатает X-отчет.
func (d *mitsuDriver) PrintXReport() error {
	// Формируем отчет
	_, err := d.sendCommand("<MAKE REPORT='X'/>")
	if err != nil {
		return err
	}

	// Печатаем отчет
	_, err = d.sendCommand("<PRINT/>")
	return err
}

// PrintZReport печатает отчет по расчетам (Этот отчет не закрывает смену!).
func (d *mitsuDriver) PrintZReport() error {
	// Формируем отчет
	_, err := d.sendCommand("<MAKE REPORT='Z'/>")
	if err != nil {
		return err
	}

	// Печатаем отчет
	_, err = d.sendCommand("<PRINT/>")
	return err
}

// OpenCheck открывает чек.
func (d *mitsuDriver) OpenCheck(checkType int, taxSystem int) error {
	cmd := fmt.Sprintf("<Do CHECK='OPEN' TYPE='%d' TAX='%d' MERGE='0'/>", checkType, taxSystem)
	_, err := d.sendCommand(cmd)
	return err
}

// AddPosition добавляет позицию в чек.
func (d *mitsuDriver) AddPosition(pos ItemPosition) error {
	// Маппинг TaxRate: 0->6 (Без НДС), 1->1 (20%), 2->2 (10%), 3->3 (20/120), 4->4 (10/110), 5->5 (0%), 6->6 (Без НДС)
	taxMap := map[int]int{
		0: 6, // Без НДС
		1: 1, // 20%
		2: 2, // 10%
		3: 3, // 20/120
		4: 4, // 10/110
		5: 5, // 0%
		6: 6, // Без НДС
	}
	tax := taxMap[pos.Tax]
	if tax == 0 {
		tax = 6 // по умолчанию Без НДС
	}

	total := pos.Price * pos.Quantity
	safeName := escapeXMLText(pos.Name)

	cmd := fmt.Sprintf("<ADD ITEM='%.3f' TAX='%d' UNIT='0' PRICE='%.2f' TOTAL='%.2f' TYPE='1' MODE='4'><NAME>%s</NAME></ADD>",
		pos.Quantity, tax, pos.Price, total, safeName)
	_, err := d.sendCommand(cmd)
	return err
}

// Subtotal рассчитывает промежуточный итог.
func (d *mitsuDriver) Subtotal() error {
	_, err := d.sendCommand("<Do CHECK='TOTAL'/>")
	return err
}

// Payment производит оплату.
func (d *mitsuDriver) Payment(pay PaymentInfo) error {
	var pa, pb, pc, pd, pe float64
	switch pay.Type {
	case 0: // наличные
		pa = pay.Sum
	case 1: // безналичные
		pb = pay.Sum
	case 2: // аванс
		pc = pay.Sum
	case 3: // кредит
		pd = pay.Sum
	case 4: // иная
		pe = pay.Sum
	default:
		pb = pay.Sum // по умолчанию безналичные
	}

	cmd := fmt.Sprintf("<Do CHECK='PAY' PA='%.2f' PB='%.2f' PC='%.2f' PD='%.2f' PE='%.2f'/></Do>",
		pa, pb, pc, pd, pe)
	_, err := d.sendCommand(cmd)
	return err
}

// CloseCheck закрывает чек.
func (d *mitsuDriver) CloseCheck() error {
	// Завершаем формирование чека
	_, err := d.sendCommand("<Do CHECK='END'/>")
	if err != nil {
		return err
	}

	// Закрываем чек и печатаем
	_, err = d.sendCommand("<Do CHECK='CLOSE'/>")
	if err != nil {
		return err
	}

	// Печатаем чек
	_, err = d.sendCommand("<PRINT/>")
	return err
}

// CancelCheck отменяет чек.
func (d *mitsuDriver) CancelCheck() error {
	_, err := d.sendCommand("<Do CHECK='CANCEL'/>")
	return err
}

// OpenCorrectionCheck открывает чек коррекции.
func (d *mitsuDriver) OpenCorrectionCheck(checkType int, taxSystem int) error {
	cmd := fmt.Sprintf("<Do CHECK='CORR' TYPE='%d' TAX='%d'/>", checkType, taxSystem)
	_, err := d.sendCommand(cmd)
	return err
}

// RebootDevice перезапускает устройство.
func (d *mitsuDriver) RebootDevice() error {
	_, err := d.sendCommand("<DEVICE JOB='0'/>")
	return err
}

// PrintDiagnostics печатает диагностическую информацию.
func (d *mitsuDriver) PrintDiagnostics() error {
	// Формируем отчет
	_, err := d.sendCommand("<MAKE REPORT='X'/>")
	if err != nil {
		return err
	}

	// Печатаем отчет
	_, err = d.sendCommand("<PRINT/>")
	return err
}

// DeviceJob выполняет задачу устройства.
func (d *mitsuDriver) DeviceJob(job int) error {
	cmd := fmt.Sprintf("<DEVICE JOB='%d'/>", job)
	_, err := d.sendCommand(cmd)
	return err
}

// Feed проматывает бумагу на указанное количество строк.
func (d *mitsuDriver) Feed(lines int) error {
	cmd := fmt.Sprintf("<FEED N='%d'/>", lines)
	_, err := d.sendCommand(cmd)
	return err
}

// Cut выполняет отрезку чека.
func (d *mitsuDriver) Cut() error {
	_, err := d.sendCommand("<CUT/>")
	return err
}

// PrintLastDocument печатает последний сформированный документ (копию).
func (d *mitsuDriver) PrintLastDocument() error {
	_, err := d.sendCommand("<PRINT/>")
	return err
}

func (d *mitsuDriver) ResetMGM() error {
	_, err := d.sendCommand("<MAKE FISCAL='RESET'/>")
	return err
}
</file>

<file path="driver\cmd_flash.go">
package driver

import (
	"encoding/hex"
	"fmt"
)

// UploadImage реализует загрузку изображения с разбивкой на пакеты (Chunking).
// Это необходимо, так как буфер COM-порта ограничен 2040 байтами.
func (d *mitsuDriver) UploadImage(index int, data []byte) error {
	if len(data) == 0 {
		return fmt.Errorf("файл изображения пуст")
	}

	// Максимальный размер полезной нагрузки (бинарной) в одном пакете.
	// 512 байт bin -> 1024 байт hex.
	// 1024 + ~60 байт XML-обвязки < 2040 байт (лимит протокола).
	const maxChunkSize = 512

	// OFFSET в данном контексте - это ID слота (100 + номер).
	// Мы предполагаем, что последовательные команды MODE='1' в один и тот же слот
	// дописывают данные в буфер устройства.
	offset := 100 + index

	totalLen := len(data)
	sent := 0

	for sent < totalLen {
		// 1. Определяем размер текущего куска
		chunkSize := maxChunkSize
		if sent+chunkSize > totalLen {
			chunkSize = totalLen - sent
		}

		// 2. Выделяем данные и кодируем в HEX
		chunk := data[sent : sent+chunkSize]
		hexData := hex.EncodeToString(chunk)

		// 3. Формируем команду записи части
		// LENGTH - указывает размер текущей порции данных
		cmdWrite := fmt.Sprintf("<FLASH MODE='1' LENGTH='%d' OFFSET='%d'>%s</FLASH>", len(chunk), offset, hexData)

		if d.config.Logger != nil {
			d.config.Logger(fmt.Sprintf("Загрузка пакета: %d/%d байт...", sent+chunkSize, totalLen))
		}

		// 4. Отправляем
		if _, err := d.sendCommand(cmdWrite); err != nil {
			return fmt.Errorf("ошибка записи блока (offset %d): %w", sent, err)
		}

		sent += chunkSize
	}

	// 5. Фиксация (Commit)
	// MODE='3' завершает загрузку и сохраняет буфер во флеш-память.
	cmdCommit := "<FLASH MODE='3' LENGTH='0' OFFSET='0'/>"
	if _, err := d.sendCommand(cmdCommit); err != nil {
		return fmt.Errorf("ошибка фиксации изображения (MODE=3): %w", err)
	}

	return nil
}
</file>

<file path="driver\cmd_get.go">
package driver

import (
	"encoding/hex"
	"errors"
	"fmt"
	"strconv"
	"time"
)

// GetFiscalInfo собирает полную информацию о ККТ, последовательно вызывая команды протокола.
func (d *mitsuDriver) GetFiscalInfo() (*FiscalInfo, error) {
	info := &FiscalInfo{}

	// 1. Получение модели (<GET DEV='?'/>)
	// Стр. 9
	if resp, err := d.sendCommand("<GET DEV='?'/>"); err != nil {
		return nil, fmt.Errorf("ошибка получения модели: %w", err)
	} else {
		var r struct {
			Dev string `xml:"DEV,attr"`
		}
		if err := decodeXML(resp, &r); err == nil {
			info.ModelName = r.Dev
		}
	}

	// 2. Получение версии и серийного номера (<GET VER='?'/>)
	// Стр. 10
	if resp, err := d.sendCommand("<GET VER='?'/>"); err != nil {
		return nil, fmt.Errorf("ошибка получения версии: %w", err)
	} else {
		var r struct {
			Serial string `xml:"SERIAL,attr"`
			Ver    string `xml:"VER,attr"`
		}
		if err := decodeXML(resp, &r); err == nil {
			info.SerialNumber = r.Serial
			info.SoftwareDate = r.Ver // В Mitsu версия строковая (напр. "1.2.02")
		}
	}

	// 3. Получение регистрационных данных (<GET REG='?'/>)
	// Стр. 11-12
	// Эта команда возвращает основные параметры регистрации.
	if resp, err := d.sendCommand("<GET REG='?'/>"); err != nil {
		return nil, fmt.Errorf("ошибка получения рег. данных: %w", err)
	} else {
		var r struct {
			// Атрибуты
			Rnm        string `xml:"T1037,attr"`
			Inn        string `xml:"T1018,attr"`
			FfdVer     string `xml:"T1209,attr"`
			RegDate    string `xml:"DATE,attr"`
			FdNumber   string `xml:"FD,attr"`    // Номер фискального документа
			MarkAttr   string `xml:"MARK,attr"`  // Признак маркировки ('1' - да)
			ExciseAttr string `xml:"T1207,attr"` // Признак подакцизных ('1' - да)
			// Вложенные теги
			OrgName string `xml:"T1048"`
			Address string `xml:"T1009"`
			OfdName string `xml:"T1046"`
		}
		if err := decodeXML(resp, &r); err != nil {
			return nil, fmt.Errorf("ошибка разбора рег. данных: %w", err)
		}

		info.RNM = r.Rnm
		info.Inn = r.Inn
		info.FfdVersion = r.FfdVer
		info.RegistrationDate = r.RegDate
		info.FdNumber = r.FdNumber
		info.OrganizationName = r.OrgName
		info.Address = r.Address
		info.OfdName = r.OfdName

		// Обработка флагов (в XML они приходят как "1" или "0")
		info.AttributeMarked = r.MarkAttr == "1"
		info.AttributeExcise = r.ExciseAttr == "1"
	}

	// 4. Получение статуса ФН (<GET INFO='F'/>)
	// Стр. 15. Команда может принимать вид INFO='F' или INFO='FN'
	if resp, err := d.sendCommand("<GET INFO='F'/>"); err != nil {
		return nil, fmt.Errorf("ошибка получения статуса ФН: %w", err)
	} else {
		var r struct {
			FnSerial string `xml:"FN,attr"`    // Заводской номер ФН (атрибут FN, см пример стр 15)
			FnValid  string `xml:"VALID,attr"` // Срок действия
			FnFfd    string `xml:"FFD,attr"`   // Версия ФФД ФН
			Edition  string `xml:"EDITION,attr"`
		}
		if err := decodeXML(resp, &r); err != nil {
			return nil, fmt.Errorf("ошибка разбора статуса ФН: %w", err)
		}
		info.FnSerial = r.FnSerial
		info.FnEndDate = r.FnValid
		info.FnExecution = r.FnFfd
		info.FnEdition = r.Edition
	}

	return info, nil
}

// --- Реализация методов GET ---

// GetModel (3.3)
func (d *mitsuDriver) GetModel() (string, error) {
	resp, err := d.sendCommand("<GET DEV='?'/>")
	if err != nil {
		return "", err
	}
	var r struct {
		Dev string `xml:"DEV,attr"`
	}
	if err := decodeXML(resp, &r); err != nil {
		return "", err
	}
	return r.Dev, nil
}

// GetVersion (3.4)

func (d *mitsuDriver) GetVersion() (string, string, string, error) {
	resp, err := d.sendCommand("<GET VER='?'/>")
	if err != nil {
		return "", "", "", err
	}
	var r struct {
		Serial string `xml:"SERIAL,attr"`
		Ver    string `xml:"VER,attr"`
		Mac    string `xml:"MAC,attr"`
	}
	if err := decodeXML(resp, &r); err != nil {
		return "", "", "", err
	}
	return r.Ver, r.Serial, r.Mac, nil
}

// GetDateTime (3.5)
func (d *mitsuDriver) GetDateTime() (time.Time, error) {
	// Запрашиваем дату и время одной командой
	resp, err := d.sendCommand("<GET DATE='?' TIME='?'/>")
	if err != nil {
		return time.Time{}, err
	}
	var r struct {
		Date string `xml:"DATE,attr"` // гггг-мм-дд
		Time string `xml:"TIME,attr"` // чч:мм:сс
	}
	if err := decodeXML(resp, &r); err != nil {
		return time.Time{}, err
	}

	// Парсинг
	fullTime := fmt.Sprintf("%sT%s", r.Date, r.Time)
	return time.Parse("2006-01-02T15:04:05", fullTime)
}

// GetCashier (3.6)
func (d *mitsuDriver) GetCashier() (string, string, error) {
	resp, err := d.sendCommand("<GET CASHIER='?'/>")
	if err != nil {
		return "", "", err
	}
	var r struct {
		Name string `xml:"CASHIER,attr"`
		Inn  string `xml:"INN,attr"`
	}
	if err := decodeXML(resp, &r); err != nil {
		return "", "", err
	}
	return r.Name, r.Inn, nil
}

// GetPrinterSettings (3.7)
func (d *mitsuDriver) GetPrinterSettings() (*PrinterSettings, error) {
	resp, err := d.sendCommand("<GET PRINTER='?'/>")
	if err != nil {
		return nil, err
	}
	var s PrinterSettings
	if err := decodeXML(resp, &s); err != nil {
		return nil, err
	}
	return &s, nil
}

// GetMoneyDrawerSettings (3.8)
func (d *mitsuDriver) GetMoneyDrawerSettings() (*DrawerSettings, error) {
	resp, err := d.sendCommand("<GET CD='?'/>")
	if err != nil {
		return nil, err
	}
	// Тут нужно быть внимательным с XML.
	// Ответ: <OK CD='контакт' RISE='фронт' FALL='спад' />
	// Но пример: <OK CD:PIN='5' ... /> - это опечатка в доке или реальный формат?
	// Судя по разделу 3.8: <OK CD='контакт' ...>
	// Попробуем распарсить стандартно.
	var s DrawerSettings
	if err := decodeXML(resp, &s); err != nil {
		return nil, err
	}
	return &s, nil
}

// GetComSettings (3.9)
func (d *mitsuDriver) GetComSettings() (int32, error) {
	resp, err := d.sendCommand("<GET COM='?'/>")
	if err != nil {
		return 0, err
	}
	var r struct {
		Speed int32 `xml:"COM,attr"`
	}
	if err := decodeXML(resp, &r); err != nil {
		return 0, err
	}
	return r.Speed, nil
}

// GetHeader (3.10)
func (d *mitsuDriver) GetHeader(n int) ([]ClicheLineData, error) {
	cmd := fmt.Sprintf("<GET HEADER='%d'/>", n)
	resp, err := d.sendCommand(cmd)
	if err != nil {
		return nil, err
	}

	// В документации F, по факту FORM. Поддерживаем оба варианта.
	type Line struct {
		Text string `xml:",chardata"`
		F    string `xml:"F,attr"`    // Старый вариант/Дока
		Form string `xml:"FORM,attr"` // Реальный вариант
	}
	// Вспомогательная функция выбора непустого формата
	getFmt := func(l Line) string {
		if l.Form != "" {
			return l.Form
		}
		if l.F != "" {
			return l.F
		}
		return "000000"
	}

	type HeaderResp struct {
		L0 Line `xml:"L0"`
		L1 Line `xml:"L1"`
		L2 Line `xml:"L2"`
		L3 Line `xml:"L3"`
		L4 Line `xml:"L4"`
		L5 Line `xml:"L5"`
		L6 Line `xml:"L6"`
		L7 Line `xml:"L7"`
		L8 Line `xml:"L8"`
		L9 Line `xml:"L9"`
	}
	var r HeaderResp
	if err := decodeXML(resp, &r); err != nil {
		return nil, err
	}

	lines := make([]ClicheLineData, 10)

	lines[0] = ClicheLineData{Text: r.L0.Text, Format: getFmt(r.L0)}
	lines[1] = ClicheLineData{Text: r.L1.Text, Format: getFmt(r.L1)}
	lines[2] = ClicheLineData{Text: r.L2.Text, Format: getFmt(r.L2)}
	lines[3] = ClicheLineData{Text: r.L3.Text, Format: getFmt(r.L3)}
	lines[4] = ClicheLineData{Text: r.L4.Text, Format: getFmt(r.L4)}
	lines[5] = ClicheLineData{Text: r.L5.Text, Format: getFmt(r.L5)}
	lines[6] = ClicheLineData{Text: r.L6.Text, Format: getFmt(r.L6)}
	lines[7] = ClicheLineData{Text: r.L7.Text, Format: getFmt(r.L7)}
	lines[8] = ClicheLineData{Text: r.L8.Text, Format: getFmt(r.L8)}
	lines[9] = ClicheLineData{Text: r.L9.Text, Format: getFmt(r.L9)}

	return lines, nil
}

// GetLanSettings (3.11)
func (d *mitsuDriver) GetLanSettings() (*LanSettings, error) {
	resp, err := d.sendCommand("<GET LAN='?'/>")
	if err != nil {
		return nil, err
	}
	var s LanSettings
	if err := decodeXML(resp, &s); err != nil {
		return nil, err
	}
	return &s, nil
}

// GetOfdSettings (3.12)
func (d *mitsuDriver) GetOfdSettings() (*OfdSettings, error) {
	resp, err := d.sendCommand("<GET OFD='?'/>")
	if err != nil {
		return nil, err
	}
	var s OfdSettings
	if err := decodeXML(resp, &s); err != nil {
		return nil, err
	}
	return &s, nil
}

// GetOismSettings (3.13)
func (d *mitsuDriver) GetOismSettings() (*OismSettings, error) {
	resp, err := d.sendCommand("<GET OISM='?'/>")
	if err != nil {
		return nil, err
	}
	var s OismSettings
	// OISM возвращает ADDR
	if err := decodeXML(resp, &s); err != nil {
		return nil, err
	}
	return &s, nil
}

// GetOkpSettings (3.14)
func (d *mitsuDriver) GetOkpSettings() (*ServerSettings, error) {
	resp, err := d.sendCommand("<GET OKP='?'/>")
	if err != nil {
		return nil, err
	}
	var s ServerSettings
	// OKP возвращает атрибут OKP вместо ADDR (стр. 11: <OK OKP='IP/URL...' ...>)
	// Наша структура ServerSettings имеет тег OKP
	if err := decodeXML(resp, &s); err != nil {
		return nil, err
	}
	// Унификация: если заполнено поле Okp, переносим в Addr
	if s.Okp != "" && s.Addr == "" {
		s.Addr = s.Okp
	}
	return &s, nil
}

// GetTaxRates (3.15)
func (d *mitsuDriver) GetTaxRates() (*TaxRates, error) {
	resp, err := d.sendCommand("<GET TAX='?'/>")
	if err != nil {
		return nil, err
	}
	var t TaxRates
	if err := decodeXML(resp, &t); err != nil {
		return nil, err
	}
	return &t, nil
}

// GetRegistrationData (3.16) выполняет только команду <GET REG='?'/>.
// Возвращает данные последней регистрации БЕЗ дополнительных запросов.
// Для получения полных данных (включая FnSerial, PrinterSerial) используйте
// хелпер GetFullRegistrationData из пакета gui.
func (d *mitsuDriver) GetRegistrationData() (*RegData, error) {
	resp, err := d.sendCommand("<GET REG='?'/>")
	if err != nil {
		return nil, err
	}
	var r RegData
	if err := decodeXML(resp, &r); err != nil {
		return nil, err
	}
	return &r, nil
}

// GetShiftStatus (3.17)
func (d *mitsuDriver) GetShiftStatus() (*ShiftStatus, error) {
	resp, err := d.sendCommand("<GET INFO='0'/>")
	if err != nil {
		return nil, err
	}
	var s ShiftStatus
	if err := decodeXML(resp, &s); err != nil {
		return nil, err
	}
	return &s, nil
}

// GetShiftTotals (3.18)
func (d *mitsuDriver) GetShiftTotals() (*ShiftTotals, error) {
	resp, err := d.sendCommand("<GET INFO='1'/>")
	if err != nil {
		return nil, err
	}
	var s ShiftTotals
	if err := decodeXML(resp, &s); err != nil {
		return nil, err
	}
	return &s, nil
}

// GetFnStatus (3.22)
func (d *mitsuDriver) GetFnStatus() (*FnStatus, error) {
	resp, err := d.sendCommand("<GET INFO='F'/>")
	if err != nil {
		return nil, err
	}
	var f FnStatus
	if err := decodeXML(resp, &f); err != nil {
		return nil, err
	}
	return &f, nil
}

// GetOfdExchangeStatus (3.23)
func (d *mitsuDriver) GetOfdExchangeStatus() (*OfdExchangeStatus, error) {
	resp, err := d.sendCommand("<GET INFO='O'/>")
	if err != nil {
		return nil, err
	}
	var s OfdExchangeStatus
	if err := decodeXML(resp, &s); err != nil {
		return nil, err
	}
	return &s, nil
}

// GetMarkingStatus (3.24)
func (d *mitsuDriver) GetMarkingStatus() (*MarkingStatus, error) {
	resp, err := d.sendCommand("<GET INFO='M'/>")
	if err != nil {
		return nil, err
	}
	var m MarkingStatus
	if err := decodeXML(resp, &m); err != nil {
		return nil, err
	}
	return &m, nil
}

// GetPowerStatus (3.33)
// Возвращает 1 (был сбой) или 0 (ок/сброшен).
func (d *mitsuDriver) GetPowerStatus() (int, error) {
	resp, err := d.sendCommandSilent("<GET POWER='?'/>")
	if err != nil {
		return 0, err
	}
	var r struct {
		Val int `xml:"POWER,attr"`
	}
	if err := decodeXML(resp, &r); err != nil {
		return 0, err
	}
	return r.Val, nil
}

// GetPowerFlag возвращает состояние флага питания ФН.
// Флаг устанавливается ФН при подаче питания и сохраняется до следующего обесточивания.
// Используется для отслеживания перезагрузок ККТ.
// Возвращает:
//   - true: флаг установлен (питание было подано)
//   - false: флаг не установлен или сброшен
func (d *mitsuDriver) GetPowerFlag() (bool, error) {
	status, err := d.GetPowerStatus()
	if err != nil {
		return false, err
	}
	return status == 1, nil
}

// GetTimezone (3.35)
func (d *mitsuDriver) GetTimezone() (int, error) {
	resp, err := d.sendCommand("<GET TIMEZONE='?'/>")
	if err != nil {
		return 0, err
	}
	var r struct {
		Tz string `xml:"TIMEZONE,attr"`
	}
	if err := decodeXML(resp, &r); err != nil {
		return 0, err
	}
	if r.Tz == "" {
		return 0, errors.New("часовая зона не возвращена")
	}
	var tz int
	_, err = fmt.Sscanf(r.Tz, "%d", &tz)
	return tz, err
}

// GetOptions читает все опции устройства (4.13)
func (d *mitsuDriver) GetOptions() (*DeviceOptions, error) {
	resp, err := d.sendCommand("<OPTION/>")
	if err != nil {
		return nil, err
	}
	var opts DeviceOptions
	if err := decodeXML(resp, &opts); err != nil {
		return nil, err
	}
	return &opts, nil
}

// GetCurrentDocumentType получает тип текущего документа.
func (d *mitsuDriver) GetCurrentDocumentType() (int, error) {
	resp, err := d.sendCommand("<GET DOC='0'/>")
	if err != nil {
		return 0, err
	}
	var r struct {
		Type int `xml:"TYPE,attr"`
	}
	if err := decodeXML(resp, &r); err != nil {
		return 0, err
	}
	return r.Type, nil
}

// GetDocumentXMLFromFN получает полную XML-строку документа из ФН по номеру FD.
func (d *mitsuDriver) GetDocumentXMLFromFN(fd int) (string, error) {
	// 1. Получить OFFSET и LENGTH
	resp, err := d.sendCommand(fmt.Sprintf("<GET DOC='X:%d'/>", fd))
	if err != nil {
		return "", err
	}
	var docInfo struct {
		Offset string `xml:"OFFSET,attr"`
		Length int    `xml:"LENGTH,attr"`
	}
	if err := decodeXML(resp, &docInfo); err != nil {
		return "", fmt.Errorf("ошибка парсинга информации о документе: %w", err)
	}

	// Парсить OFFSET как hex
	offset, err := strconv.ParseInt(docInfo.Offset, 16, 64)
	if err != nil {
		return "", fmt.Errorf("ошибка парсинга OFFSET как hex: %w", err)
	}

	// 2. Читать блоки
	const blockSize = 512
	var xmlData []byte
	remaining := docInfo.Length

	for remaining > 0 {
		chunkSize := blockSize
		if chunkSize > remaining {
			chunkSize = remaining
		}

		// Отправить <READ OFFSET='HEXOFFSET' LENGTH='CHUNKSIZE'/>
		cmd := fmt.Sprintf("<READ OFFSET='%X' LENGTH='%d'/>", offset, chunkSize)
		resp, err := d.sendCommand(cmd)
		if err != nil {
			return "", fmt.Errorf("ошибка чтения блока offset=%X length=%d: %w", offset, chunkSize, err)
		}

		// Парсить ответ как <OK LENGTH='n'>HEXDATA</OK>
		var blockResp struct {
			Length int    `xml:"LENGTH,attr"`
			Data   string `xml:",innerxml"`
		}
		if err := decodeXML(resp, &blockResp); err != nil {
			return "", fmt.Errorf("ошибка парсинга блока: %w", err)
		}

		// Декодировать HEX
		chunk, err := hex.DecodeString(blockResp.Data)
		if err != nil {
			return "", fmt.Errorf("ошибка декодирования HEX блока: %w", err)
		}

		// Проверить, что декодировано chunkSize байт
		if len(chunk) != chunkSize {
			return "", fmt.Errorf("ожидалось %d байт, декодировано %d", chunkSize, len(chunk))
		}

		xmlData = append(xmlData, chunk...)
		offset += int64(chunkSize)
		remaining -= chunkSize
	}

	// 3. Конвертировать собранные данные в UTF8
	utf8XML, err := toUTF8(xmlData)
	if err != nil {
		return "", fmt.Errorf("ошибка конвертации XML в UTF8: %w", err)
	}

	return string(utf8XML), nil
}
</file>

<file path="driver\cmd_ofd.go">
package driver

import (
	"encoding/hex"
	"fmt"
)

// OfdBeginRead начинает процедуру чтения первого непереданного документа для отправки в ОФД.
// Возвращает размер сообщения в байтах.
// Команда: <Do OFD='BEGIN'/>
// Ответ: <OK LENGTH='размер'/>
func (d *mitsuDriver) OfdBeginRead() (int, error) {
	resp, err := d.sendCommand("<Do OFD='BEGIN'/>")
	if err != nil {
		return 0, fmt.Errorf("ошибка начала чтения документа ОФД: %w", err)
	}

	var r struct {
		Length int `xml:"LENGTH,attr"`
	}
	if err := decodeXML(resp, &r); err != nil {
		return 0, fmt.Errorf("ошибка разбора ответа OFD BEGIN: %w", err)
	}

	return r.Length, nil
}

// OfdReadBlock считывает блок сообщения заданной длины, начиная с заданной позиции.
// offset - смещение в байтах от начала сообщения
// length - число байт блока данных, не более 1000 байт
// Возвращает: фактический размер прочитанного блока и данные в бинарном виде.
// Команда: <Do OFD='READ' OFFSET='позиция' LENGTH='размер'/>
// Ответ: <OK LENGTH='размер'>БЛОК ДАННЫХ В HEX</OK>
func (d *mitsuDriver) OfdReadBlock(offset, length int) ([]byte, int, error) {
	if length > 1000 {
		length = 1000
	}

	cmd := fmt.Sprintf("<Do OFD='READ' OFFSET='%d' LENGTH='%d'/>", offset, length)
	resp, err := d.sendCommand(cmd)
	if err != nil {
		return nil, 0, fmt.Errorf("ошибка чтения блока OFD offset=%d length=%d: %w", offset, length, err)
	}

	var r struct {
		Length int    `xml:"LENGTH,attr"`
		Data   string `xml:",innerxml"`
	}
	if err := decodeXML(resp, &r); err != nil {
		return nil, 0, fmt.Errorf("ошибка разбора ответа OFD READ: %w", err)
	}

	// Декодируем HEX данные
	data, err := hex.DecodeString(r.Data)
	if err != nil {
		return nil, 0, fmt.Errorf("ошибка декодирования HEX данных OFD: %w", err)
	}

	return data, r.Length, nil
}

// OfdEndRead завершает чтение документа.
// Команда: <Do OFD='END'/>
func (d *mitsuDriver) OfdEndRead() error {
	_, err := d.sendCommand("<Do OFD='END'/>")
	if err != nil {
		return fmt.Errorf("ошибка завершения чтения документа ОФД: %w", err)
	}
	return nil
}

// OfdLoadReceipt записывает квитанцию от ОФД в ФН.
// receipt - бинарные данные квитанции
// Команда: <Do OFD='LOAD' LENGTH='размер'>КВИТАНЦИЯ В HEX</OK>
func (d *mitsuDriver) OfdLoadReceipt(receipt []byte) error {
	hexData := hex.EncodeToString(receipt)
	cmd := fmt.Sprintf("<Do OFD='LOAD' LENGTH='%d'>%s</OK>", len(receipt), hexData)

	_, err := d.sendCommand(cmd)
	if err != nil {
		return fmt.Errorf("ошибка записи квитанции ОФД: %w", err)
	}
	return nil
}

// OfdCancelRead отменяет чтение документа.
// Команда: <Do OFD='CANCEL'/>
func (d *mitsuDriver) OfdCancelRead() error {
	_, err := d.sendCommand("<Do OFD='CANCEL'/>")
	if err != nil {
		return fmt.Errorf("ошибка отмены чтения документа ОФД: %w", err)
	}
	return nil
}

// OfdReadFullDocument читает полный документ для отправки в ОФД.
// Возвращает бинарные данные документа (с обёрткой для ОФД).
func (d *mitsuDriver) OfdReadFullDocument() ([]byte, error) {
	// 1. Начинаем чтение, получаем размер
	totalLength, err := d.OfdBeginRead()
	if err != nil {
		return nil, err
	}

	if totalLength == 0 {
		d.OfdEndRead()
		return nil, fmt.Errorf("документ пуст или отсутствует")
	}

	// 2. Читаем блоками
	const blockSize = 1000 // Максимальный размер блока согласно документации
	var fullData []byte
	offset := 0

	for offset < totalLength {
		remaining := totalLength - offset
		chunkSize := blockSize
		if chunkSize > remaining {
			chunkSize = remaining
		}

		data, actualLen, err := d.OfdReadBlock(offset, chunkSize)
		if err != nil {
			d.OfdCancelRead() // Отменяем при ошибке
			return nil, err
		}

		fullData = append(fullData, data...)
		offset += actualLen

		// Защита от бесконечного цикла
		if actualLen == 0 {
			break
		}
	}

	// 3. Завершаем чтение
	if err := d.OfdEndRead(); err != nil {
		return nil, err
	}

	return fullData, nil
}
</file>

<file path="driver\cmd_reg.go">
package driver

import (
	"fmt"
	"strings"
)

// RegistrationRequest содержит параметры для регистрации/перерегистрации ККТ.
// Поля соответствуют атрибутам и тегам команды <REG> (стр. 23 документации).

// Register выполняет первичную регистрацию ККТ (5.1).
func (d *mitsuDriver) Register(req RegistrationRequest) (*RegResponse, error) {
	req.IsReregistration = false
	req.Base = "0" // Для первичной регистрации BASE всегда '0'
	return d.performRegistration(req)
}

// Reregister выполняет перерегистрацию ККТ (5.2).
// reasons - список кодов причин (см. стр 12, например: 1 - замена ФН, 3 - смена реквизитов).
func (d *mitsuDriver) Reregister(req RegistrationRequest, reasons []int) (*RegResponse, error) {
	req.IsReregistration = true
	// Формируем строку BASE="1,3,..."
	var strReasons []string
	for _, r := range reasons {
		strReasons = append(strReasons, fmt.Sprintf("%d", r))
	}
	req.Base = strings.Join(strReasons, ",")
	if req.Base == "" {
		return nil, fmt.Errorf("не указаны причины перерегистрации")
	}

	return d.performRegistration(req)
}

// performRegistration формирует XML команду <REG> и отправляет её.
func (d *mitsuDriver) performRegistration(req RegistrationRequest) (*RegResponse, error) {
	// Сборка атрибутов
	// Обязательные атрибуты согласно стр. 23
	attrs := fmt.Sprintf("BASE='%s' T1062='%s'", req.Base, req.TaxSystems)

	if req.TaxSystemBase != "" {
		attrs += fmt.Sprintf(" T1062_Base='%s'", req.TaxSystemBase)
	}

	// Добавляем опциональные атрибуты (флаги режимов)
	if req.InternetCalc {
		attrs += " T1108='1'"
	}
	if req.Service {
		attrs += " T1109='1'"
	}
	if req.BSO {
		attrs += " T1110='1'"
	}
	if req.Lottery {
		attrs += " T1126='1'"
	}
	if req.Gambling {
		attrs += " T1193='1'"
	}
	if req.Excise {
		attrs += " T1207='1'"
	}
	if req.Marking {
		attrs += " MARK='1'"
	}
	if req.PawnShop {
		attrs += " PAWN='1'"
	}
	if req.Insurance {
		attrs += " INS='1'"
	}
	if req.Catering {
		attrs += " DINE='1'"
	}
	if req.Wholesale {
		attrs += " OPT='1'"
	}
	if req.Vending {
		attrs += " VEND='1'"
	}
	if req.AutomatMode {
		attrs += " T1001='1'"
	}
	if req.AutonomousMode {
		attrs += " T1002='1'"
	}
	if req.Encryption {
		attrs += " T1056='1'"
	}
	if req.PrinterAutomat {
		attrs += " T1221='1'"
	}

	// Версия ФФД
	if req.FfdVer != "" {
		attrs += fmt.Sprintf(" T1209='%s'", req.FfdVer)
	}
	// Номер автомата
	if req.AutomatNumber != "" {
		attrs += fmt.Sprintf(" T1036='%s'", req.AutomatNumber)
	}

	// Сборка вложенных тегов
	tags := ""
	tags += fmt.Sprintf("<T1048>%s</T1048>", escapeXMLText(req.OrgName))
	tags += fmt.Sprintf("<T1009>%s</T1009>", escapeXMLText(req.Address))
	tags += fmt.Sprintf("<T1187>%s</T1187>", escapeXMLText(req.Place))
	tags += fmt.Sprintf("<T1046>%s</T1046>", escapeXMLText(req.OfdName))
	// ИНН ОФД
	tags += fmt.Sprintf("<T1017>%s</T1017>", req.OfdInn)

	// Согласно стр. 24, при перерегистрации ИНН (1018) и РНМ (1037) НЕ передаются.
	if !req.IsReregistration {
		tags += fmt.Sprintf("<T1018>%s</T1018>", req.Inn)
		tags += fmt.Sprintf("<T1037>%s</T1037>", req.RNM)
	}

	tags += fmt.Sprintf("<T1060>%s</T1060>", escapeXMLText(req.FnsSite))
	tags += fmt.Sprintf("<T1117>%s</T1117>", escapeXMLText(req.SenderEmail))

	// Номер автомата также дублируется в тегах в примере
	if req.AutomatNumber != "" {
		tags += fmt.Sprintf("<T1036>%s</T1036>", escapeXMLText(req.AutomatNumber))
	}

	// Итоговая команда
	xmlCmd := fmt.Sprintf("<REG %s>%s</REG>", attrs, tags)

	respData, err := d.sendCommand(xmlCmd)
	if err != nil {
		return nil, err
	}

	// Парсинг ответа <OK FD='...' FP='...' />
	var resp RegResponse
	if err := decodeXML(respData, &resp); err != nil {
		return nil, fmt.Errorf("ошибка парсинга ответа регистрации: %w", err)
	}

	return &resp, nil
}

// CloseFiscalArchive закрывает фискальный режим (5.4).
func (d *mitsuDriver) CloseFiscalArchive() (*CloseFnResult, error) {
	// Для закрытия ФН нужно отправить MAKE FISCAL='CLOSE'
	// Для P0 отправляем без тегов (пустые)
	cmd := "<MAKE FISCAL='CLOSE'></MAKE>"
	respData, err := d.sendCommand(cmd)
	if err != nil {
		return nil, err
	}

	// Парсинг ответа MAKE: FD и FP
	var resp struct {
		FD int    `xml:"FD,attr"`
		FP string `xml:"FP,attr"`
	}
	if err := decodeXML(respData, &resp); err != nil {
		return nil, fmt.Errorf("ошибка парсинга ответа закрытия ФН: %w", err)
	}

	// Отправить <PRINT/>
	_, err = d.sendCommand("<PRINT/>")
	if err != nil {
		return nil, fmt.Errorf("ошибка печати отчета о закрытии ФН: %w", err)
	}

	return &CloseFnResult{FD: resp.FD, FP: resp.FP}, nil
}
</file>

<file path="driver\cmd_set.go">
package driver

import (
	"fmt"
	"strings"
	"time"
)

// SetTimezone (3.35, добавлено в FW 1.2.18)
func (d *mitsuDriver) SetTimezone(value int) error {
	cmd := fmt.Sprintf("<SET TIMEZONE='%d'/>", value)
	_, err := d.sendCommand(cmd)
	return err
}

// --- Реализация методов SET ---

// SetDateTime (4.3)
// ВНИМАНИЕ! Если часы кассы установлены по ошибке на будущую дату/время и оформлен
// хотя бы один фискальный документ, вернуть назад часы невозможно.
// В этом случае потребуется замена ФН.
func (d *mitsuDriver) SetDateTime(t time.Time) error {
	dateStr := t.Format("2006-01-02")
	timeStr := t.Format("15:04:05")
	cmd := fmt.Sprintf("<SET DATE='%s' TIME='%s' />", dateStr, timeStr)

	// Ответ на эту команду содержит установленные дату и время, но если нет ошибки протокола,
	// считаем операцию успешной.
	_, err := d.sendCommand(cmd)
	return err
}

// SetCashier (4.4)
// name: Идентификатор (ФИО, должность), макс 64 символа.
// inn: ИНН кассира (необязательно).
// Необходимо устанавливать кассира перед открытием каждого чека.
func (d *mitsuDriver) SetCashier(name string, inn string) error {
	// Экранируем имя, так как оно может содержать кавычки и т.д.
	safeName := escapeXMLText(name)
	cmd := fmt.Sprintf("<SET CASHIER='%s' INN='%s'/>", safeName, inn)
	_, err := d.sendCommand(cmd)
	return err
}

// SetComSettings (4.5)
func (d *mitsuDriver) SetComSettings(speed int32) error {
	cmd := fmt.Sprintf("<SET COM='%d'/>", speed)
	_, err := d.sendCommand(cmd)
	return err
}

// Модель принтера (0 – нет принтера; 1 – Mitsu RP-809; 2 – Mitsu F80)

// SetPrinterSettings (4.6)
func (d *mitsuDriver) SetPrinterSettings(s PrinterSettings) error {
	cmd := fmt.Sprintf(
		"<SET PRINTER='%s' BAUDRATE='%d' PAPER='%d' FONT='%d'/>",
		s.Model, s.BaudRate, s.Paper, s.Font,
	)
	_, err := d.sendCommand(cmd)
	return err
}

// SetMoneyDrawerSettings (4.7)
func (d *mitsuDriver) SetMoneyDrawerSettings(s DrawerSettings) error {
	cmd := fmt.Sprintf(
		"<SET CD='%d' RISE='%d' FALL='%d'/>",
		s.Pin, s.Rise, s.Fall,
	)
	_, err := d.sendCommand(cmd)
	return err
}

// SetHeader (4.8)
// Установка клише и подвала.
// headerNum:
// 1 - клише №1, печатается в заголовке в самом верху документа
// 2 - клише №2, печатается после строк с наименованием пользователя и адреса расчетов
// 3 - клише №3, печатается внизу чека перед QR кодом и реквизитами
// 4 - клише №4, печатается в самом конце чека
// Суммарная длина всех строк каждого клише до 1000 символов
// lineNum: 0..9
// format: "xxxxxx" (6 цифр).
// 1 цифра: инверсия (0 – нет инверсии: черный текст на белом фоне, 1 – инверсия: белый текст на черном фоне)
// 2 цифра: размер текста по горизонтали (ширина) (0 – размер, установленный в настройках, 1 - обычный, 2-8 масштаб)
// 3 цифра: размер текста по вертикали (высота) (0 – размер, установленный в настройках, 1 - обычный, 2-8 масштаб)
// 4 цифра: шрифт (0-шрифт, установленный настройкой <Setup><Font>, 1-А, 2-B)
// 5 цифра: подчеркивание (0-нет, 1-текст, 2-строка)
// 6 цифра: выравнивание (0-лево, 1-центр, 2-право)
// Строки каждого клише надо программировать по одной, подряд без пропуска. Например, если задать строки L0 и L2, то установися только строка L0.
// Установка каждой строки стирает все последующие внутри клише. Например, если сначала задать строки с L0 по L3, а затем повторно задать строки L0 и L1, то строки L2 и L3 сотрутся
func (d *mitsuDriver) SetHeader(headerNum int, lines []ClicheLineData) error {
	var sb strings.Builder

	// Открываем тег команды
	sb.WriteString(fmt.Sprintf("<SET HEADER='%d'>", headerNum))

	// Добавляем строки L0..Ln
	for i, line := range lines {
		// Ограничение: максимум 10 строк (0-9)
		if i > 9 {
			break
		}

		format := line.Format
		if format == "" {
			format = "000000"
		}

		// Экранируем текст
		safeText := escapeXMLText(line.Text)

		// Используем атрибут FORM
		sb.WriteString(fmt.Sprintf("<L%d FORM='%s'>%s</L%d>", i, format, safeText, i))
	}

	sb.WriteString("</SET>")

	_, err := d.sendCommand(sb.String())
	return err
}

func (d *mitsuDriver) SetHeaderLine(headerNum int, lineNum int, text string, format string) error {
	if format == "" {
		format = "000000"
	}
	safeText := escapeXMLText(text)

	// Пример: <SET HEADER='1'><L0 FORM='000011'>Текст</L0></SET>
	cmd := fmt.Sprintf(
		"<SET HEADER='%d'><L%d FORM='%s'>%s</L%d></SET>",
		headerNum, lineNum, format, safeText, lineNum,
	)
	_, err := d.sendCommand(cmd)
	return err
}

// SetLanSettings (4.9)
func (d *mitsuDriver) SetLanSettings(s LanSettings) error {
	// Все параметры кроме LAN (IP) необязательны, но передаем структуру целиком
	cmd := fmt.Sprintf(
		"<SET LAN='%s' MASK='%s' PORT='%d' DNS='%s' GW='%s'/>",
		s.Addr, s.Mask, s.Port, s.Dns, s.Gw,
	)
	_, err := d.sendCommand(cmd)
	return err
}

// SetOfdSettings (4.10)
func (d *mitsuDriver) SetOfdSettings(s OfdSettings) error {
	cmd := fmt.Sprintf(
		"<SET OFD='%s' PORT='%d' CLIENT='%s' TimerFN='%d' TimerOFD='%d'/>",
		s.Addr, s.Port, s.Client, s.TimerFN, s.TimerOFD,
	)
	_, err := d.sendCommand(cmd)
	return err
}

// SetOismSettings (4.11)
func (d *mitsuDriver) SetOismSettings(s ServerSettings) error {
	cmd := fmt.Sprintf(
		"<SET OISM='%s' PORT='%d'/>",
		s.Addr, s.Port,
	)
	_, err := d.sendCommand(cmd)
	return err
}

// SetOkpSettings (4.12)
func (d *mitsuDriver) SetOkpSettings(s ServerSettings) error {
	// Для OKP используется атрибут OKP вместо ADDR
	addr := s.Addr
	if addr == "" && s.Okp != "" {
		addr = s.Okp
	}
	cmd := fmt.Sprintf(
		"<SET OKP='%s' PORT='%d'/>",
		addr, s.Port,
	)
	_, err := d.sendCommand(cmd)
	return err
}

// SetOption (4.13)
// Устанавливает одну опцию b0-b9.
// Значения опций см. в таблице на стр. 22.
// Например, b0=0 (нет разделителей), b1=0 (QR слева).
func (d *mitsuDriver) SetOption(optionNum int, value int) error {
	if optionNum < 0 || optionNum > 9 {
		return fmt.Errorf("неверный номер опции: %d", optionNum)
	}
	cmd := fmt.Sprintf("<OPTION b%d='%d'/>", optionNum, value)
	_, err := d.sendCommand(cmd)
	return err
}

// SetPowerFlag (4.14)
// Сбрасывает (1) или устанавливает (0) флаг сбоя питания.
func (d *mitsuDriver) SetPowerFlag(value int) error {
	cmd := fmt.Sprintf("<SET POWER='%d'/>", value)
	_, err := d.sendCommand(cmd)
	return err
}

// TechReset выполняет технологическое обнуление устройства.
// Команда: <SET FACTORY=”/>
func (d *mitsuDriver) TechReset() error {
	// Ответ: <OK SERIAL='...' FN_STATE='...'/>
	_, err := d.sendCommand("<SET FACTORY=''/>")
	return err
}
</file>

<file path="driver\decode.go">
package driver

import (
	"fmt"
	"regexp"
	"time"
)

// DecodeMode декодирует битовую маску MODE в список установленных битов.
func DecodeMode(mask uint32) []string {
	var res []string
	for i := 0; i < 32; i++ {
		if mask&(1<<i) != 0 {
			res = append(res, fmt.Sprintf("MODE бит %d", i))
		}
	}
	return res
}

// DecodeExtMode декодирует битовую маску ExtMODE в список установленных битов.
func DecodeExtMode(mask uint32) []string {
	var res []string
	for i := 0; i < 32; i++ {
		if mask&(1<<i) != 0 {
			res = append(res, fmt.Sprintf("ExtMODE бит %d", i))
		}
	}
	return res
}

// GetReportMeta возвращает метаданные отчета по типу документа.
func GetReportMeta(typeCode int) ReportMeta {
	switch typeCode {
	case 1: // Отчёт о регистрации
		return ReportMeta{
			Kind:  ReportReg,
			Title: "Отчет о регистрации",
		}
	case 11: // Отчет о (пере) регистрации
		return ReportMeta{
			Kind:  ReportRereg,
			Title: "Отчет о перерегистрации",
		}
	case 6: // Отчёт о закрытии ФН
		return ReportMeta{
			Kind:  ReportKindCloseFn,
			Title: "Отчет о закрытии фискального архива",
		}
	default:
		return ReportMeta{
			Kind:  "",
			Title: "Неизвестный отчет",
		}
	}
}

// ExtractDocDateTime парсит XML строку, находит содержимое тега <T1012> и возвращает дату-время в формате "02.01.2006 15:04".
// Поддерживает layout'ы: "02-01-06T15:04", "02-01-06T15:04:05", "2006-01-02T15:04", "2006-01-02T15:04:05".
// Если тег отсутствует или парсинг не удался, возвращает ошибку.
func ExtractDocDateTime(xmlStr string) (string, error) {
	re := regexp.MustCompile(`<T1012>([^<]*)</T1012>`)
	matches := re.FindStringSubmatch(xmlStr)
	if len(matches) < 2 {
		return "", fmt.Errorf("тег T1012 не найден")
	}
	dateStr := matches[1]
	layouts := []string{"02-01-06T15:04", "02-01-06T15:04:05", "2006-01-02T15:04", "2006-01-02T15:04:05"}
	for _, layout := range layouts {
		if t, err := time.Parse(layout, dateStr); err == nil {
			return t.Format("02.01.2006 15:04"), nil
		}
	}
	return "", fmt.Errorf("не удалось распарсить дату-время: %s", dateStr)
}
</file>

<file path="driver\errors.go">
package driver

// ErrorDescriptions содержит расшифровку кодов ошибок согласно Приложению 1 документации.
var ErrorDescriptions = map[string]string{
	"0":   "нет ошибок",
	"1":   "неизвестная операция",
	"2":   "недостаточно памяти для выполнения операции",
	"3":   "операция не задана",
	"4":   "не задана структура хранения ошибки операции ФН",
	"5":   "не задана структура для результатов операции ФН",
	"6":   "не задана структура входящих параметров операции ФН",
	"7":   "превышен максимальный размер данных для команды ФН",
	"8":   "внутренняя ошибка ПО (не задан параметр в классификаторе команд)",
	"10":  "ошибка исходного состояния ФН перед (пере-)регистрацией",
	"11":  "ошибка ФН при получении статуса",
	"12":  "ошибка ФН при выдаче команды 'Начать отчет о регистрации'",
	"13":  "ошибка ФН при выдаче команды 'Передать данные документа'",
	"14":  "ошибка ФН при выдаче команды 'Сформировать отчет о регистрации (перерегистрации)'",
	"15":  "ошибка ФН при выдаче команды 'Начать закрытие фискального режима ФН'",
	"16":  "ошибка ФН при выдаче команды 'Закрыть фискальный режим ФН'",
	"17":  "ошибка при попытке захвата ФН",
	"18":  "ошибка ФН при выдаче команды 'Начать формирование отчета о текущем состоянии расчетов'",
	"19":  "ошибка ФН при выдаче команды 'Сформировать отчет о текущем состоянии расчетов'",
	"20":  "ошибка ФН: смена открыта",
	"21":  "ошибка ФН: смена закрыта",
	"22":  "ошибка ФН: имеется незакрытый документ",
	"23":  "ошибка ФН при выдаче команды 'Запрос количества ФД, на которые нет квитанции'",
	"24":  "ошибка ФН при выдаче команды 'Запрос срока действия ФН'",
	"25":  "ошибка ФН при выдаче команды 'Запрос итогов фискализации ФН'",
	"26":  "ошибка ФН: есть неподтвержденные в ОФД документы",
	"27":  "ошибка ФН при выдаче команды 'Начать открытие смены'",
	"28":  "ошибка ФН при выдаче команды 'Открыть смену'",
	"29":  "ошибка ФН при выдаче команды 'Начать закрытие смены'",
	"30":  "ошибка ФН при выдаче команды 'Закрыть смену'",
	"31":  "ошибка ФН при выдаче команды 'Начать формирование чека (БСО)'",
	"32":  "ошибка определения типа: чек или БСО",
	"33":  "ошибка ФН: чек (БСО) не открыт",
	"34":  "ошибка преобразования данных",
	"35":  "ошибка ФН при выдаче команды 'Сформировать чек'",
	"36":  "ошибка ФН при выдаче команды 'Отменить текущий документ'",
	"37":  "ошибка: незакрытый документ отсутствует",
	"38":  "ошибка: время смены истекло",
	"39":  "ошибка: чек коррекции (БСО коррекции) не открыт",
	"40":  "ошибка ФН при получении счетчиков",
	"41":  "ошибка ФН при получении состояния смены",
	"42":  "ошибка: чек пустой (нет предметов расчета)",
	"43":  "ошибка: стадия формирования чека не соответствует операции",
	"44":  "ошибка ФН при выдаче команды 'Запрос номера и типа версии ПО ФН'",
	"45":  "ошибка: нужна отладочная версия ФН для выполнения операции",
	"46":  "ошибка ФН при выдаче команды 'Сброс ФН'",
	"47":  "ошибка ФН при получении статуса информационного обмена с ОФД",
	"48":  "ошибка ФН: чтение сообщения для ОФД уже начато",
	"49":  "ошибка ФН: нет сообщений для ОФД",
	"50":  "ошибка ФН при выдаче команды 'Передать статус транспортного соединения с сервером ОФД'",
	"51":  "ошибка ФН при выдаче команды 'Начать чтение сообщения для сервера ОФД'",
	"52":  "ошибка ФН: чтение сообщения для ОФД еще не начато",
	"53":  "ошибка ФН при выдаче команды 'Отменить чтение сообщения для сервера ОФД'",
	"54":  "ошибка ФН при выдаче команды 'Прочитать блок сообщения для сервера ОФД'",
	"55":  "ошибка ФН: нет готовности к принятию квитанции от ОФД",
	"56":  "ошибка ФН при выдаче команды 'Передать квитанцию от сервера ОФД'",
	"57":  "ошибка ФН: неверный фискальный признак",
	"58":  "ошибка ФН: неверный формат квитанции",
	"59":  "ошибка ФН: неверный номер ФД",
	"60":  "ошибка ФН: неверный номер ФН",
	"61":  "ошибка ФН: неверный CRC",
	"62":  "ошибка ФН при выдаче команды 'Запрос фискального документа в TLV формате'",
	"63":  "ошибка ФН при выдаче команды 'Чтение TLV фискального документа'",
	"64":  "ошибка ФН: отсутствуют необходимые данные документа в архиве",
	"65":  "ошибка ФН: запрошенный из архива документ не является чеком",
	"66":  "ошибка ФН при выдаче команды 'Запрос общего размера данных переданных командой 07h'",
	"67":  "ошибка ФН при выдаче команды 'Запрос формата ФН'",
	"68":  "ошибка ФН: получены ошибочные данные от ФН",
	"69":  "ошибка ФН: ФН не готов или отсутствует",
	"70":  "ошибка ФН: превышено время ожидания ответа от ФН",
	"71":  "ошибка ФН: Не удалось получить запрос на проверку кода маркировки",
	"72":  "ошибка ФН: операция не поддерживается в автономном режиме",
	"73":  "ошибка ФН: чтение уведомления уже начато",
	"74":  "ошибка ФН: нет уведомлений для передачи",
	"75":  "ошибка ФН при выдаче команды 'Начать чтение уведомления'",
	"76":  "ошибка ФН: чтение уведомления еще не начато",
	"77":  "ошибка ФН: нет готовности к принятию квитанции по уведомлениям",
	"78":  "ошибка ФН: неверный номер уведомления",
	"79":  "ошибка ФН: неверная длина ответа",
	"80":  "операция поддерживается только в автономном режиме",
	"81":  "запрос на обновление ключей проверки КМ не был сформирован",
	"82":  "ошибка ФН: неверный номер запроса в ответе",
	"83":  "ошибка ФН: для выполнения команды необходимо обновить ключи проверки кодов маркировки",
	"84":  "необходимо выгрузить уведомления",
	"94":  "Таймаут приема команды",
	"95":  "Устройство печати занято",
	"96":  "В команде заданы неизвестные параметры",
	"97":  "В команде отсутствуют обязательные параметры",
	"98":  "Превышена максимальная длина параметра",
	"99":  "Неверный формат команды или неизвестная команда",
	"100": "ошибка задания версии ФФД",
	"101": "ошибка задания заводского номера",
	"102": "ошибка задания версии",
	"103": "ошибка задания регистрационного номера",
	"104": "ошибка задания ИНН",
	"105": "ошибка задания ИНН ОФД",
	"106": "ошибка задания причины перерегистрации",
	"107": "ошибка: заданная система налогообложения не поддерживается",
	"108": "ошибка задания признака расчета",
	"109": "ошибка задания признака способа расчета",
	"110": "ошибка задания признака предмета расчета",
	"111": "ошибка задания наименования предмета расчета",
	"112": "ошибка задания единицы измерения предмета расчета",
	"113": "ошибка задания кода товарной номенклатуры предмета расчета",
	"114": "ошибка задания количества единиц предмета расчета",
	"115": "ошибка задания цены за единицу предмета расчета",
	"116": "ошибка задания стоимости предмета расчета",
	"117": "ошибка задания ставки НДС предмета расчета",
	"118": "ошибка расчета размера НДС за единицу предмета расчета",
	"119": "ошибка расчета размера НДС предмета расчета",
	"120": "ошибка: расчет стоимости по позициям чека превысил максимально допустимое значение",
	"121": "ошибка: расчет стоимости по чеку превысил сумму оплат",
	"122": "ошибка задания количества принятых наличных денег в оплату чека",
	"123": "ошибка: расчет стоимости по видам оплаты чека превысил максимально допустимое значение",
	"124": "ошибка получения текущего времени от внутренних часов",
	"125": "ошибка: в чеке с оплатой кредита может быть только один предмет расчета",
	"126": "ошибка: кассир не установлен",
	"127": "ошибка задания признака агента",
	"128": "ошибка: документ в электронной форме не сформирован",
	"129": "ошибка: превышено максимальное количество предметов с кодом товарной номенклатуры",
	"130": "ошибка: попытка повторного задания уникального параметра",
	"131": "ошибка: не задан ИНН поставщика",
	"132": "ошибка: попытка задания количества уникального товара",
	"133": "ошибка: сбой принтера",
	"134": "неудача при записи на флэш-память",
	"135": "файл обновления не был загружен",
	"136": "текущая версия ФФД ФН не поддерживает операцию",
	"137": "текущая версия ФФД ФН не поддерживается",
	"138": "ошибочная последовательность команд",
	"139": "работа с подакцизными товарами запрещена",
	"140": "позиции с маркированными товарами в чеках расхода запрещены",
	"141": "сумма оплат видов безналичного расчета не равна размеру оплаты электронными",
	"142": "размер округления не должен превышать 99 копеек",
	"143": "сумма расчета по чеку в рублях не должна изменяться после округления",
	"144": "не задана часовая зона",
	"145": "не задан телефон или электронный адрес покупателя при расчете в сети “Интернет”",
	"200": "у команды есть неправильно заданные операнды",
	"201": "у команды есть не заданные операнды",
	"202": "ошибка задания режимов работы",
	"203": "ошибка задания расширенных режимов работы",
	"204": "ошибка задания параметра с датой/временем",
	"205": "ошибка задания параметра с ИНН",
	"206": "ошибка задания параметра с битовой маской",
	"207": "длина строки слишком большая",
	"208": "некорректные данные",
	"209": "команда допустима только при использовании внешнего клиента обмена",
	"210": "T1119 уже присутствует в T1115 суммы НДС чека",
	"401": "неизвестная команда ФН",
	"402": "некорректное состояние ФН",
	"403": "отказ ФН",
	"404": "отказ КС",
	"405": "параметры команды не соответствуют сроку жизни ФН",
	"407": "некорректная дата и/или время",
	"408": "нет запрошенных данных",
	"409": "некорректное значение параметров команды",
	"410": "некорректная команда",
	"411": "неразрешенные реквизиты",
	"412": "дублирование данных",
	"413": "отсутствуют данные, необходимые для корректного учета в ФН",
	"414": "количество позиций в документе превысило допустимый предел",
	"416": "превышение размеров TLV данных",
	"417": "нет транспортного соединения",
	"418": "исчерпан ресурс ФН",
	"420": "ограничение ресурса ФН",
	"422": "продолжительность смены превышена",
	"423": "некорректные данные о промежутке времени между фискальными документами",
	"424": "некорректный реквизит, переданный в ФН",
	"425": "реквизит не соответствует установкам при регистрации",
	"432": "сообщение ОФД не может быть принято",
	"435": "ошибка сервиса обновления ключей проверки КМ",
	"436": "неизвестный ответ сервиса обновления ключей проверки кодов проверки",
	"448": "ошибка: требуется повтор процедуры обновления ключей проверки КМ",
	"450": "запрещена работа с маркированным товарами",
	"451": "неверная последовательность подачи команд для обработки маркированных товаров",
	"452": "работа с маркированными товарами временно заблокирована",
	"453": "переполнена таблица проверки кодов маркировки",
	"454": "превышен период 90 дня со времени последнего обновления ключей проверки",
	"460": "в блоке TLV отсутствуют необходимые реквизиты",
	"462": "в реквизите 2007 содержится КМ, который ранее не проверялся в ФН",
	"500": "нет бумаги в принтере",
	"501": "крышка принтера открыта",
	"502": "состояние принтера не рабочее (OFFLINE)",
	"503": "сбой резака",
	"504": "есть другая ошибка принтера",
	"505": "принтер выключен",
	"506": "бумага заканчивается",
	"509": "принтер занят, идет печать",
	"510": "печатная форма документа не была завершена (сбой принтера)",
	"511": "нажата кнопка прогона бумаги",
	"600": "ошибка RTC при выдаче команды 'Прочитать дату/время'",
	"601": "ошибка RTC при выдаче команды 'Установить дату/время'",
	"602": "новые дата и время меньше даты и времени последнего оформленного фискального документа",
	"604": "ошибка: не удалось связаться с сервером ОИСМ",
	"605": "ошибка: получен пустой ответ от ОИСМ",
	"606": "ошибка: не удалось связаться с сервером ОКП",
	"607": "ошибка: получен пустой ответ от ОКП",
	"608": "общая ошибка работы с ОКП",
}
</file>

<file path="driver\interface.go">
package driver

import "time"

// Driver определяет интерфейс для работы с фискальными регистраторами.
type Driver interface {
	Connect() error
	Disconnect() error
	GetFiscalInfo() (*FiscalInfo, error)
	GetModel() (string, error)
	GetVersion() (string, string, string, error)
	GetDateTime() (time.Time, error)
	GetCashier() (string, string, error)
	GetPrinterSettings() (*PrinterSettings, error)
	GetMoneyDrawerSettings() (*DrawerSettings, error)
	GetComSettings() (int32, error)
	GetHeader(int) ([]ClicheLineData, error)
	GetLanSettings() (*LanSettings, error)
	GetOfdSettings() (*OfdSettings, error)
	GetOismSettings() (*OismSettings, error)
	GetOkpSettings() (*ServerSettings, error)
	GetTaxRates() (*TaxRates, error)
	GetRegistrationData() (*RegData, error)
	GetShiftStatus() (*ShiftStatus, error)
	GetShiftTotals() (*ShiftTotals, error)
	GetFnStatus() (*FnStatus, error)
	GetOfdExchangeStatus() (*OfdExchangeStatus, error)
	GetMarkingStatus() (*MarkingStatus, error)
	GetTimezone() (int, error)
	GetPowerStatus() (int, error)
	GetPowerFlag() (bool, error) // Получить состояние флага питания ФН
	GetOptions() (*DeviceOptions, error)
	GetCurrentDocumentType() (int, error)
	GetDocumentXMLFromFN(fd int) (string, error)

	SetPowerFlag(value int) error
	SetDateTime(t time.Time) error
	SetCashier(name string, inn string) error
	SetComSettings(speed int32) error
	SetPrinterSettings(settings PrinterSettings) error
	SetMoneyDrawerSettings(settings DrawerSettings) error
	SetHeader(headerNum int, lines []ClicheLineData) error
	SetHeaderLine(headerNum int, lineNum int, text string, format string) error
	SetLanSettings(settings LanSettings) error
	SetOfdSettings(settings OfdSettings) error
	SetOismSettings(settings ServerSettings) error
	SetOkpSettings(settings ServerSettings) error
	SetOption(optionNum int, value int) error
	SetTimezone(value int) error

	Register(req RegistrationRequest) (*RegResponse, error)
	Reregister(req RegistrationRequest, reasons []int) (*RegResponse, error)
	CloseFiscalArchive() (*CloseFnResult, error)
	ResetMGM() error

	OpenShift(operator string) error
	CloseShift(operator string) error
	PrintXReport() error
	PrintZReport() error
	OpenCheck(checkType int, taxSystem int) error
	AddPosition(pos ItemPosition) error
	Subtotal() error
	Payment(pay PaymentInfo) error
	CloseCheck() error
	CancelCheck() error
	OpenCorrectionCheck(checkType int, taxSystem int) error
	RebootDevice() error
	PrintDiagnostics() error
	DeviceJob(job int) error
	// TechReset выполняет технологическое обнуление (<SET FACTORY=''/>).
	TechReset() error

	Feed(lines int) error
	Cut() error
	PrintLastDocument() error

	// UploadImage загружает изображение в память ККТ.
	// index: 0 - логотип, 1-20 - пользовательские картинки.
	// data: бинарные данные BMP файла.
	UploadImage(index int, data []byte) error

	// OFD Exchange (раздел 13 документации)
	OfdBeginRead() (int, error)
	OfdReadBlock(offset, length int) ([]byte, int, error)
	OfdEndRead() error
	OfdLoadReceipt(receipt []byte) error
	OfdCancelRead() error
	OfdReadFullDocument() ([]byte, error)
}

// ActiveDriver - глобально активный драйвер
var Active Driver

// SetActive устанавливает активный драйвер
func SetActive(d Driver) {
	Active = d
}
</file>

<file path="driver\mitsu_driver.go">
package driver

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"
	"strconv"
	"strings"
	"sync"
	"time"

	"go.bug.st/serial"
)

const (
	stx            = 0x02
	etx            = 0x03
	etb            = 0x17 // End of Transmission Block (для TCP пакетов)
	tcpDataChunkSz = 535  // Макс. кол-во данных в одном TCP пакете перед разбивкой
)

// Config определяет параметры для подключения к ККТ.
type Config struct {
	ConnectionType int32            `json:"connectionType"`      // 0 - COM, 6 - TCP
	IPAddress      string           `json:"ipAddress,omitempty"` // TCP IP
	TCPPort        int32            `json:"tcpPort,omitempty"`   // TCP Port
	ComName        string           `json:"comName,omitempty"`   // COM Port Name
	BaudRate       int32            `json:"baudRate,omitempty"`  // COM Speed
	Timeout        int              `json:"timeout,omitempty"`   // Timeout ms
	Logger         func(msg string) `json:"-"`
}

type mitsuDriver struct {
	config Config
	mu     sync.Mutex
	port   io.ReadWriteCloser // Используется только для COM.
}

func NewMitsuDriver(config Config) Driver {
	if config.Timeout == 0 {
		config.Timeout = 3000
	}
	if config.BaudRate == 0 {
		config.BaudRate = 115200
	}
	return &mitsuDriver{config: config}
}

func (d *mitsuDriver) Connect() error {
	d.mu.Lock()
	defer d.mu.Unlock()
	return d.connectLocked()
}

// connectLocked выполняет подключение.
func (d *mitsuDriver) connectLocked() error {
	var err error
	switch d.config.ConnectionType {
	case 0: // COM
		if d.port != nil {
			return nil
		}
		mode := &serial.Mode{
			BaudRate: int(d.config.BaudRate),
			DataBits: 8,
			Parity:   serial.NoParity,
			StopBits: serial.OneStopBit,
		}
		d.port, err = serial.Open(d.config.ComName, mode)
		if err != nil {
			return fmt.Errorf("ошибка открытия COM-порта: %w", err)
		}
		if p, ok := d.port.(serial.Port); ok {
			p.SetReadTimeout(time.Duration(d.config.Timeout) * time.Millisecond)
		}

	case 6: // TCP/IP
		// Для TCP мы используем режим "запрос-ответ" с короткими соединениями.
		// Connect просто проверяет доступность хоста.
		addr := net.JoinHostPort(d.config.IPAddress, strconv.Itoa(int(d.config.TCPPort)))
		conn, err := net.DialTimeout("tcp", addr, time.Duration(d.config.Timeout)*time.Millisecond)
		if err != nil {
			return fmt.Errorf("ошибка подключения TCP: %w", err)
		}
		// Сразу закрываем, реальное соединение будет в performExchange
		conn.Close()
		// d.port остается nil для TCP

	default:
		return fmt.Errorf("неизвестный тип подключения: %d", d.config.ConnectionType)
	}

	return nil
}

func (d *mitsuDriver) Disconnect() error {
	d.mu.Lock()
	defer d.mu.Unlock()
	return d.disconnectLocked()
}

func (d *mitsuDriver) disconnectLocked() error {
	if d.port != nil {
		d.port.Close()
		d.port = nil
	}
	return nil
}

// sendCommand отправляет команду.
func (d *mitsuDriver) sendCommand(xmlCmd string) ([]byte, error) {
	d.mu.Lock()
	defer d.mu.Unlock()

	// Попытки нужны в основном для COM порта или если TCP моргнул
	attempts := 1
	if d.config.ConnectionType == 0 {
		attempts = 2
	}

	var lastErr error

	for i := 0; i < attempts; i++ {
		// 1. Проверяем состояние драйвера
		if d.config.ConnectionType == 0 && d.port == nil {
			if err := d.connectLocked(); err != nil {
				lastErr = err
				continue
			}
		}

		// 2. Обмен
		resp, err := d.performExchange(xmlCmd, true)
		if err == nil {
			return resp, nil
		}

		lastErr = err

		// 3. Retry логика (только для COM)
		if d.config.ConnectionType == 0 && i < attempts-1 {
			if d.config.Logger != nil {
				d.config.Logger(fmt.Sprintf("COM Error (%v). Retrying...", err))
			}
			d.disconnectLocked()
			time.Sleep(200 * time.Millisecond)
			continue
		}
	}

	return nil, lastErr
}

// sendCommandSilent отправляет команду без лога.
func (d *mitsuDriver) sendCommandSilent(xmlCmd string) ([]byte, error) {
	d.mu.Lock()
	defer d.mu.Unlock()

	// Попытки нужны в основном для COM порта или если TCP моргнул
	attempts := 1
	if d.config.ConnectionType == 0 {
		attempts = 2
	}

	var lastErr error

	for i := 0; i < attempts; i++ {
		// 1. Проверяем состояние драйвера
		if d.config.ConnectionType == 0 && d.port == nil {
			if err := d.connectLocked(); err != nil {
				lastErr = err
				continue
			}
		}

		// 2. Обмен
		resp, err := d.performExchange(xmlCmd, false)
		if err == nil {
			return resp, nil
		}

		lastErr = err

		// 3. Retry логика (только для COM)
		if d.config.ConnectionType == 0 && i < attempts-1 {
			if d.config.Logger != nil {
				d.config.Logger(fmt.Sprintf("COM Error (%v). Retrying...", err))
			}
			d.disconnectLocked()
			time.Sleep(200 * time.Millisecond)
			continue
		}
	}

	return nil, lastErr
}

// performExchange выполняет физическую отправку и прием данных
func (d *mitsuDriver) performExchange(xmlCmd string, logEnabled bool) ([]byte, error) {
	if d.config.Logger != nil && logEnabled {
		d.config.Logger(fmt.Sprintf(">> TX: %s", xmlCmd))
	}

	// 1. Подготовка данных (UTF-8 -> Win1251)
	data, err := encodeCP1251(xmlCmd)
	if err != nil {
		return nil, err
	}

	var conn io.ReadWriteCloser

	// Инициализация соединения
	if d.config.ConnectionType == 0 {
		// --- COM ---
		if d.port == nil {
			return nil, errors.New("port is closed")
		}
		conn = d.port
	} else {
		// --- TCP: Transactional Mode ---
		// Открываем сокет на КАЖДЫЙ запрос
		addr := net.JoinHostPort(d.config.IPAddress, strconv.Itoa(int(d.config.TCPPort)))
		netConn, err := net.DialTimeout("tcp", addr, time.Duration(d.config.Timeout)*time.Millisecond)
		if err != nil {
			return nil, err
		}
		defer netConn.Close() // Гарантированно закрываем после обмена

		netConn.SetDeadline(time.Now().Add(time.Duration(d.config.Timeout) * time.Millisecond))
		conn = netConn
	}

	// 2. Отправка (Framing)
	if d.config.ConnectionType == 0 {
		// --- COM Framing (STX...ETX) ---
		packet := make([]byte, 0, len(data)+5)
		packet = append(packet, stx)
		lenBuf := make([]byte, 2)
		binary.LittleEndian.PutUint16(lenBuf, uint16(len(data)))
		packet = append(packet, lenBuf...)
		packet = append(packet, data...)
		packet = append(packet, etx)
		lrc := byte(0)
		for _, b := range packet {
			lrc ^= b
		}
		packet = append(packet, lrc)

		if _, err := conn.Write(packet); err != nil {
			return nil, err
		}
	} else {
		// --- TCP Framing (Chunked + ETB) ---
		offset := 0
		totalLen := len(data)

		if totalLen == 0 {
			return nil, errors.New("empty command")
		}

		for offset < totalLen {
			remaining := totalLen - offset
			chunkSize := remaining
			if chunkSize > tcpDataChunkSz {
				chunkSize = tcpDataChunkSz
			}
			chunk := data[offset : offset+chunkSize]

			// Нужно ли слать ETB? (если это НЕ последний пакет)
			isLastPacket := (offset + chunkSize) >= totalLen

			if _, err := conn.Write(chunk); err != nil {
				return nil, err
			}

			if !isLastPacket {
				if _, err := conn.Write([]byte{etb}); err != nil {
					return nil, err
				}
			}
			offset += chunkSize
		}
	}

	// 3. Чтение ответа
	var responseData []byte

	if d.config.ConnectionType == 0 {
		// --- COM Reading ---
		buf := make([]byte, 1)
		readBuf := make([]byte, 0, 1024)
		for {
			n, err := conn.Read(buf)
			if err != nil {
				return nil, err
			}
			if n == 0 {
				continue
			}
			readBuf = append(readBuf, buf[0])
			if buf[0] == etx {
				lrcBuf := make([]byte, 1)
				_, err := io.ReadFull(conn, lrcBuf)
				if err != nil {
					return nil, err
				}
				readBuf = append(readBuf, lrcBuf[0])
				break
			}
		}
		if len(readBuf) < 2 {
			return nil, errors.New("short response")
		}
		responseData = readBuf[:len(readBuf)-2]

	} else {
		// --- TCP Reading ---
		accumulated := make([]byte, 0, 4096)
		tempBuf := make([]byte, 1024)

		for {
			n, err := conn.Read(tempBuf)
			if err != nil {
				// EOF при TCP Transactional mode - это НОРМАЛЬНОЕ завершение,
				// если мы уже получили данные. Устройство закрыло соединение после ответа.
				if err == io.EOF && len(accumulated) > 0 {
					break
				}
				return nil, err
			}
			if n == 0 {
				continue
			}

			chunk := tempBuf[:n]

			// Обработка ETB (признак продолжения)
			hasEtb := false
			if len(chunk) > 0 && chunk[len(chunk)-1] == etb {
				hasEtb = true
				chunk = chunk[:len(chunk)-1]
			}

			accumulated = append(accumulated, chunk...)

			// Если ETB нет, проверяем, не конец ли это XML
			if !hasEtb {
				tailLen := 50
				if len(accumulated) < tailLen {
					tailLen = len(accumulated)
				}
				tail := string(accumulated[len(accumulated)-tailLen:])

				// Если видим закрывающий тег, считаем ответ полным и выходим,
				// не дожидаясь таймаута или EOF.
				if strings.Contains(tail, "/>") ||
					strings.Contains(tail, "</OK>") ||
					strings.Contains(tail, "</ERROR>") ||
					strings.Contains(tail, "</ANS>") ||
					strings.Contains(tail, "</Do>") ||
					strings.Contains(tail, "</REG>") {
					break
				}
			}
		}
		responseData = accumulated
	}

	// 4. Проверка на логические ошибки
	if bytes.Contains(responseData, []byte("ERROR")) {
		if d.config.Logger != nil {
			decodedLog, _ := toUTF8(responseData)
			d.config.Logger(fmt.Sprintf("<< RX (ERR): %s", string(decodedLog)))
		}
		return nil, parseError(responseData)
	}

	if d.config.Logger != nil && logEnabled {
		decodedLog, _ := toUTF8(responseData)
		d.config.Logger(fmt.Sprintf("<< RX: %s", string(decodedLog)))
	}

	return responseData, nil
}
</file>

<file path="driver\types.go">
package driver

// FiscalInfo содержит агрегированную информацию о фискальном регистраторе.
type FiscalInfo struct {
	ModelName        string `json:"modelName"`
	SerialNumber     string `json:"serialNumber"`
	RNM              string `json:"RNM"`
	OrganizationName string `json:"organizationName"`
	Address          string `json:"address"`
	Inn              string `json:"INN"`
	FnSerial         string `json:"fn_serial"`
	RegistrationDate string `json:"datetime_reg"`
	FdNumber         string `json:"fd_number"`
	FnEndDate        string `json:"dateTime_end"`
	OfdName          string `json:"ofdName"`
	SoftwareDate     string `json:"bootVersion"`
	FfdVersion       string `json:"ffdVersion"`
	FnExecution      string `json:"fnExecution"`
	FnEdition        string `json:"fn_edition"`
	AttributeExcise  bool   `json:"attribute_excise"`
	AttributeMarked  bool   `json:"attribute_marked"`
}

// PrinterSettings содержит настройки принтера.
type PrinterSettings struct {
	Model    string `xml:"PRINTER,attr"`
	BaudRate int    `xml:"BAUDRATE,attr"`
	Paper    int    `xml:"PAPER,attr"`
	Font     int    `xml:"FONT,attr"`
	Width    int    `xml:"WIDTH,attr"`
	Length   int    `xml:"LENGTH,attr"`
}

// DrawerSettings содержит настройки денежного ящика.
type DrawerSettings struct {
	Pin  int `xml:"CD:PIN,attr"`
	Rise int `xml:"RISE,attr"`
	Fall int `xml:"FALL,attr"`
}

// ClicheLineData содержит данные одной строки клише.
type ClicheLineData struct {
	Text   string
	Format string // Строка вида "000000"
}

// LanSettings содержит настройки сети.
type LanSettings struct {
	Addr string `xml:"LAN,attr"`
	Port int    `xml:"PORT,attr"`
	Mask string `xml:"MASK,attr"`
	Dns  string `xml:"DNS,attr"`
	Gw   string `xml:"GW,attr"`
}

// OfdSettings содержит настройки ОФД.
type OfdSettings struct {
	Addr     string `xml:"OFD,attr"`
	Port     int    `xml:"PORT,attr"`
	Client   string `xml:"CLIENT,attr"`
	TimerFN  int    `xml:"TimerFN,attr"`
	TimerOFD int    `xml:"TimerOFD,attr"`
}

// OismSettings содержит настройки сервера OISM
type OismSettings struct {
	Addr string `xml:"OISM,attr"` // Для OISM
	Port int    `xml:"PORT,attr"`
}

// ServerSettings содержит настройки сервера OKP.
type ServerSettings struct {
	Addr string `xml:"ADDR,attr"`
	Okp  string `xml:"OKP,attr"` // Для OKP (имя атрибута отличается)
	Port int    `xml:"PORT,attr"`
}

// TaxRates содержит настройки налоговых ставок.
type TaxRates struct {
	T1  string `xml:"T1,attr"`  // 20%
	T2  string `xml:"T2,attr"`  // 10%
	T3  string `xml:"T3,attr"`  // 20/120
	T4  string `xml:"T4,attr"`  // 10/110
	T5  string `xml:"T5,attr"`  // 0%
	T6  string `xml:"T6,attr"`  // Без НДС
	T7  string `xml:"T7,attr"`  // 5%
	T8  string `xml:"T8,attr"`  // 7%
	T9  string `xml:"T9,attr"`  // 5/105
	T10 string `xml:"T10,attr"` // 7/107
}

// RegData содержит полные данные о регистрации ККТ.
type RegData struct {
	RNM        string `xml:"T1037,attr"`
	Inn        string `xml:"T1018,attr"`
	FfdVer     string `xml:"T1209,attr"`
	RegDate    string `xml:"DATE,attr"`
	RegTime    string `xml:"TIME,attr"`
	RegNumber  string `xml:"REG,attr"`   // Порядковый номер регистрации
	FdNumber   string `xml:"FD,attr"`    // Номер фискального документа
	FpNumber   string `xml:"T1077,attr"` // Фискальный признак из T1077
	Base       string `xml:"BASE,attr"`  // Коды причин регистрации
	TaxSystems string `xml:"T1062,attr"` // СНО (0,1,...)
	TaxBase    string `xml:"T1062_Base,attr"`

	// Маски режимов
	ModeMask    uint32 `xml:"MODE,attr"`
	ExtModeMask uint32 `xml:"ExtMODE,attr"`

	// Флаги (атрибуты)
	MarkAttr      string `xml:"MARK,attr"`  // Маркировка
	ExciseAttr    string `xml:"T1207,attr"` // Подакцизные
	InternetAttr  string `xml:"T1108,attr"` // Интернет
	ServiceAttr   string `xml:"T1109,attr"` // Услуги
	BsoAttr       string `xml:"T1110,attr"` // БСО
	LotteryAttr   string `xml:"T1126,attr"` // Лотерея
	GamblingAttr  string `xml:"T1193,attr"` // Азартные
	PawnAttr      string `xml:"PAWN,attr"`  // Ломбард
	InsAttr       string `xml:"INS,attr"`   // Страхование
	DineAttr      string `xml:"DINE,attr"`  // Общепит
	OptAttr       string `xml:"OPT,attr"`   // Опт
	VendAttr      string `xml:"VEND,attr"`  // Вендинг
	AutoModeAttr  string `xml:"T1001,attr"` // Автоматический режим
	AutoNumAttr   string `xml:"T1036,attr"` // Номер автомата (атрибут)
	AutonomAttr   string `xml:"T1002,attr"` // Автономный
	EncryptAttr   string `xml:"T1056,attr"` // Шифрование
	PrintAutoAttr string `xml:"T1221,attr"` // Принтер в автомате

	// Вложенные теги
	OrgName     string `xml:"T1048"`
	Address     string `xml:"T1009"`
	Place       string `xml:"T1187"`
	OfdName     string `xml:"T1046"`
	OfdInn      string `xml:"T1017,attr"`
	Site        string `xml:"T1060"`
	EmailSender string `xml:"T1117"`
	// T1036 может быть и тегом
	AutoNumTag string `xml:"T1036"`

	// Дополнительные поля для диалога
	FnSerial      string // Заводской номер ФН
	FnEdition     string // Исполнение ФН
	PrinterSerial string // Серийный номер ФР
}

// ShiftStatus содержит информацию о текущей смене.
type ShiftStatus struct {
	ShiftNum int    `xml:"SHIFT,attr"`
	State    string `xml:"STATE,attr"` // 0-закрыта, 1-открыта, 9-истекла
	Count    int    `xml:"COUNT,attr"`
	FdNum    int    `xml:"FD,attr"`
	KeyValid int    `xml:"KeyValid,attr"`

	// Вложенная структура для статуса обмена ОФД
	Ofd struct {
		Count int    `xml:"COUNT,attr"`
		First int    `xml:"FIRST,attr"`
		Date  string `xml:"DATE,attr"`
		Time  string `xml:"TIME,attr"`
	} `xml:"OFD"`
}

// ShiftTotals содержит итоги смены.
type ShiftTotals struct {
	ShiftNum int `xml:"SHIFT,attr"`
	Income   struct {
		Count string `xml:"COUNT,attr"`
		Total string `xml:"TOTAL,attr"`
	} `xml:"INCOME"`
	Payout struct {
		Count string `xml:"COUNT,attr"`
		Total string `xml:"TOTAL,attr"`
	} `xml:"PAYOUT"`
	Cash struct {
		Total string `xml:"TOTAL,attr"`
	} `xml:"CASH"`
}

// FnStatus содержит информацию о фискальном накопителе.
type FnStatus struct {
	Serial  string `xml:"FN,attr"`
	Ffd     string `xml:"FFD,attr"`
	Phase   string `xml:"PHASE,attr"`
	Valid   string `xml:"VALID,attr"`
	LastFD  int    `xml:"LAST,attr"`
	Flag    string `xml:"FLAG,attr"` // HEX маска предупреждений
	Edition string `xml:"EDITION,attr"`
	Power   string `xml:"POWER,attr"` // Флаг питания (1 = установлен, 0 = сброшен)
}

// OfdExchangeStatus содержит информацию об обмене с ОФД.
type OfdExchangeStatus struct {
	Count    int    `xml:"COUNT,attr"`
	FirstDoc int    `xml:"FIRST,attr"`
	Date     string `xml:"DATE,attr"`
	Time     string `xml:"TIME,attr"`
}

// MarkingStatus содержит информацию о маркировке.
type MarkingStatus struct {
	MarkState int    `xml:"MARK,attr"`
	Keep      int    `xml:"KEEP,attr"`
	Flag      string `xml:"FLAG,attr"`
	Notice    int    `xml:"NOTICE,attr"`
	Holds     int    `xml:"HOLDS,attr"`
	Pending   int    `xml:"PENDING,attr"`
	Warning   int    `xml:"WARNING,attr"`
}

// RegResponse содержит ответ на команду регистрации/перерегистрации.
type RegResponse struct {
	FdNumber string `xml:"FD,attr"`    // Номер фискального документа
	FpNumber string `xml:"T1077,attr"` // Фискальный признак из T1077
}

// CloseFnResult содержит результат закрытия фискального архива.
type CloseFnResult struct {
	FD int    // номер фискального документа
	FP string // фискальный признак
}

// ReportFnCloseData содержит данные для отчета о закрытии фискального архива.
type ReportFnCloseData struct {
	DateTime  string
	FP        string
	FD        int
	RNM       string
	FNNumber  string
	KKTNumber string
	Address   string
	Place     string
}

// RegistrationRequest содержит параметры для регистрации ККТ.
type RegistrationRequest struct {
	// Атрибуты (Attributes)
	IsReregistration bool   `json:"-"` // false = Регистрация, true = Перерегистрация
	Base             string `json:"-"` // Коды причин перерегистрации (через запятую, напр "1,5")

	RNM            string `json:"rnm"`             // T1037 (Рег. номер)
	Inn            string `json:"inn"`             // T1018 (ИНН Пользователя)
	FfdVer         string `json:"ffd_ver"`         // T1209 (Версия ФФД)
	TaxSystems     string `json:"tax_systems"`     // T1062 (СНО через запятую: "0,1")
	TaxSystemBase  string `json:"tax_base"`        // T1062_Base (Базовая СНО - опционально)
	AutomatNumber  string `json:"automat_num"`     // T1036 (Номер автомата)
	InternetCalc   bool   `json:"internet_calc"`   // T1108 (Расчеты в Интернет)
	Service        bool   `json:"service"`         // T1109 (Услуги)
	BSO            bool   `json:"bso"`             // T1110 (БСО)
	Lottery        bool   `json:"lottery"`         // T1126 (Лотерея)
	Gambling       bool   `json:"gambling"`        // T1193 (Азартные игры)
	Excise         bool   `json:"excise"`          // T1207 (Подакцизные товары)
	Marking        bool   `json:"marking"`         // MARK (Маркировка)
	PawnShop       bool   `json:"pawn_shop"`       // PAWN (Ломбард)
	Insurance      bool   `json:"insurance"`       // INS (Страхование)
	Catering       bool   `json:"catering"`        // DINE (Общепит)
	Wholesale      bool   `json:"wholesale"`       // OPT (Опт)
	Vending        bool   `json:"vending"`         // VEND (Вендинг)
	AutomatMode    bool   `json:"automat_mode"`    // T1001 (Автоматический режим)
	AutonomousMode bool   `json:"autonomous_mode"` // T1002 (Автономный режим)
	Encryption     bool   `json:"encryption"`      // T1056 (Шифрование)
	PrinterAutomat bool   `json:"printer_automat"` // T1221 (Принтер в автомате)

	// Вложенные теги (Nested Tags)
	OrgName     string `json:"org_name"`     // T1048
	Address     string `json:"address"`      // T1009
	Place       string `json:"place"`        // T1187
	OfdName     string `json:"ofd_name"`     // T1046
	OfdInn      string `json:"ofd_inn"`      // T1017
	FnsSite     string `json:"fns_site"`     // T1060
	SenderEmail string `json:"sender_email"` // T1117
}

// ItemPosition содержит параметры позиции чека.
type ItemPosition struct {
	Name     string  `json:"name"`     // Наименование товара
	Price    float64 `json:"price"`    // Цена
	Quantity float64 `json:"quantity"` // Количество
	Tax      int     `json:"tax"`      // Налоговая ставка
}

// PaymentInfo содержит параметры оплаты.
type PaymentInfo struct {
	Type int     `json:"type"` // Тип оплаты (0 - наличные, 1 - безналичные, ...)
	Sum  float64 `json:"sum"`  // Сумма
}

// DeviceOptions содержит настройки устройства (b0-b9).
type DeviceOptions struct {
	B0 int `xml:"b0,attr"` // Разделители
	B1 int `xml:"b1,attr"` // QR позиция
	B2 int `xml:"b2,attr"` // Округление
	B3 int `xml:"b3,attr"` // Авто-резак
	B4 int `xml:"b4,attr"` // Авто-тест
	B5 int `xml:"b5,attr"` // Открытие ящика (триггер)
	B6 int `xml:"b6,attr"` // Звук конца бумаги
	B7 int `xml:"b7,attr"` // Текст рядом с QR
	B8 int `xml:"b8,attr"` // Печать кол-ва покупок
	B9 int `xml:"b9,attr"` // Базовая СНО
}

// ReportKind определяет тип отчета.
type ReportKind string

const (
	ReportKindRegistration ReportKind = "registration"
	ReportKindCloseFn      ReportKind = "close_fn"
	// Другие типы отчетов можно добавить здесь
)

// Константы для типов отчетов
const (
	ReportReg   ReportKind = ReportKindRegistration
	ReportRereg ReportKind = ReportKindRegistration
)

// ReportMeta содержит метаданные и данные для отчета.
type ReportMeta struct {
	Kind  ReportKind
	Title string
	Data  interface{} // Данные отчета, например RegData или ReportFnCloseData
	Text  string      // Готовый текст отчета, если уже сформирован
}
</file>

<file path="driver\types_test.go">
package driver

import (
	"encoding/hex"
	"encoding/xml"
	"fmt"
	"strconv"
	"testing"
)

func TestDecodeMode(t *testing.T) {
	if len(DecodeMode(0)) != 0 {
		t.Error("expected empty")
	}
	res := DecodeMode(1)
	if len(res) != 1 || res[0] != "MODE бит 0" {
		t.Error("expected MODE бит 0")
	}
	res = DecodeMode(3)
	if len(res) != 2 || res[0] != "MODE бит 0" || res[1] != "MODE бит 1" {
		t.Error("expected two bits")
	}
}

func TestDecodeExtMode(t *testing.T) {
	if len(DecodeExtMode(0)) != 0 {
		t.Error("expected empty")
	}
	res := DecodeExtMode(1)
	if len(res) != 1 || res[0] != "ExtMODE бит 0" {
		t.Error("expected ExtMODE бит 0")
	}
	res = DecodeExtMode(3)
	if len(res) != 2 || res[0] != "ExtMODE бит 0" || res[1] != "ExtMODE бит 1" {
		t.Error("expected two bits")
	}
}

func TestExtractDocDateTime(t *testing.T) {
	tests := []struct {
		name     string
		xmlStr   string
		expected string
		hasError bool
	}{
		{
			name:     "layout 02-01-06T15:04",
			xmlStr:   `<DocXML FORM="2"><T1012>01-05-23T01:35</T1012></DocXML>`,
			expected: "01.05.2023 01:35",
			hasError: false,
		},
		{
			name:     "layout 02-01-06T15:04:05",
			xmlStr:   `<DocXML FORM="2"><T1012>01-05-23T01:35:45</T1012></DocXML>`,
			expected: "01.05.2023 01:35",
			hasError: false,
		},
		{
			name:     "layout 2006-01-02T15:04",
			xmlStr:   `<DocXML FORM="2"><T1012>2023-05-01T01:35</T1012></DocXML>`,
			expected: "01.05.2023 01:35",
			hasError: false,
		},
		{
			name:     "layout 2006-01-02T15:04:05",
			xmlStr:   `<DocXML FORM="2"><T1012>2023-05-01T01:35:45</T1012></DocXML>`,
			expected: "01.05.2023 01:35",
			hasError: false,
		},
		{
			name:     "layout 02-01-06T15:04 with 4-digit year equivalent",
			xmlStr:   `<DocXML FORM="2"><T1012>01-05-24T01:35</T1012></DocXML>`,
			expected: "01.05.2024 01:35",
			hasError: false,
		},
		{
			name:     "missing T1012 tag",
			xmlStr:   `<DocXML FORM="2"></DocXML>`,
			expected: "",
			hasError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := ExtractDocDateTime(tt.xmlStr)
			if tt.hasError {
				if err == nil {
					t.Errorf("expected error, but got none")
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
				if result != tt.expected {
					t.Errorf("expected %v, got %v", tt.expected, result)
				}
			}
		})
	}
}

func TestRegDataParsing(t *testing.T) {
	xmlStr := `<OK T1077="1234567890"></OK>`
	var reg RegData
	err := xml.Unmarshal([]byte(xmlStr), &reg)
	if err != nil {
		t.Fatalf("failed to unmarshal XML: %v", err)
	}
	if reg.FpNumber != "1234567890" {
		t.Errorf("expected FpNumber '1234567890', got '%s'", reg.FpNumber)
	}
}

// parseDocInfo парсит ответ на <GET DOC='X:fd'/>
func parseDocInfo(data []byte) (offset int64, length int, err error) {
	var docInfo struct {
		Offset string `xml:"OFFSET,attr"`
		Length int    `xml:"LENGTH,attr"`
	}
	if err := decodeXML(data, &docInfo); err != nil {
		return 0, 0, fmt.Errorf("ошибка парсинга информации о документе: %w", err)
	}
	offset, err = strconv.ParseInt(docInfo.Offset, 16, 64)
	if err != nil {
		return 0, 0, fmt.Errorf("ошибка парсинга OFFSET как hex: %w", err)
	}
	return offset, docInfo.Length, nil
}

// decodeHexBlock декодирует ответ на <READ OFFSET='...' LENGTH='...'/>
func decodeHexBlock(data []byte, expectedLength int) ([]byte, error) {
	var blockResp struct {
		Length int    `xml:"LENGTH,attr"`
		Data   string `xml:",innerxml"`
	}
	if err := decodeXML(data, &blockResp); err != nil {
		return nil, fmt.Errorf("ошибка парсинга блока: %w", err)
	}
	chunk, err := hex.DecodeString(blockResp.Data)
	if err != nil {
		return nil, fmt.Errorf("ошибка декодирования HEX блока: %w", err)
	}
	if len(chunk) != expectedLength {
		return nil, fmt.Errorf("ожидалось %d байт, декодировано %d", expectedLength, len(chunk))
	}
	return chunk, nil
}

func TestParseDocInfo(t *testing.T) {
	tests := []struct {
		name           string
		xmlStr         string
		expectedOffset int64
		expectedLength int
		hasError       bool
	}{
		{
			name:           "valid response",
			xmlStr:         `<OK OFFSET='60010000' LENGTH='385'/>`,
			expectedOffset: 0x60010000,
			expectedLength: 385,
			hasError:       false,
		},
		{
			name:           "invalid offset",
			xmlStr:         `<OK OFFSET='invalid' LENGTH='385'/>`,
			expectedOffset: 0,
			expectedLength: 0,
			hasError:       true,
		},
		{
			name:           "missing attributes",
			xmlStr:         `<OK/>`,
			expectedOffset: 0,
			expectedLength: 0,
			hasError:       true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			offset, length, err := parseDocInfo([]byte(tt.xmlStr))
			if tt.hasError {
				if err == nil {
					t.Errorf("expected error, but got none")
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
				if offset != tt.expectedOffset {
					t.Errorf("expected offset %X, got %X", tt.expectedOffset, offset)
				}
				if length != tt.expectedLength {
					t.Errorf("expected length %d, got %d", tt.expectedLength, length)
				}
			}
		})
	}
}

func TestDecodeHexBlock(t *testing.T) {
	tests := []struct {
		name           string
		xmlStr         string
		expectedLength int
		expectedData   string
		hasError       bool
	}{
		{
			name:           "valid hex data",
			xmlStr:         `<OK LENGTH='4'>48656C6C</OK>`, // "Hell"
			expectedLength: 4,
			expectedData:   "Hell",
			hasError:       false,
		},
		{
			name:           "invalid hex",
			xmlStr:         `<OK LENGTH='4'>invalid</OK>`,
			expectedLength: 4,
			expectedData:   "",
			hasError:       true,
		},
		{
			name:           "length mismatch",
			xmlStr:         `<OK LENGTH='4'>48656C</OK>`, // 3 bytes
			expectedLength: 4,
			expectedData:   "",
			hasError:       true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			data, err := decodeHexBlock([]byte(tt.xmlStr), tt.expectedLength)
			if tt.hasError {
				if err == nil {
					t.Errorf("expected error, but got none")
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
				if string(data) != tt.expectedData {
					t.Errorf("expected data %q, got %q", tt.expectedData, string(data))
				}
			}
		})
	}
}
</file>

<file path="driver\utils.go">
package driver

import (
	"bytes"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"strings"

	"golang.org/x/net/html/charset"
	"golang.org/x/text/encoding/charmap"
	"golang.org/x/text/transform"
)

// escapeXMLText экранирует только спецсимволы XML, сохраняя кавычки.
// Это исправляет проблему, когда кавычки в названии ОФД превращались в &#34;
func escapeXMLText(s string) string {
	r := strings.NewReplacer(
		"&", "&",
		"<", "<",
		">", ">",
	)
	return r.Replace(s)
}

func decodeXML(data []byte, v interface{}) error {
	utf8Data, err := toUTF8(data)
	if err != nil {
		return fmt.Errorf("ошибка конвертации кодировки: %w", err)
	}
	return xml.Unmarshal(utf8Data, v)
}

func toUTF8(data []byte) ([]byte, error) {
	r, err := charset.NewReaderLabel("windows-1251", bytes.NewReader(data))
	if err != nil {
		return nil, err
	}
	return io.ReadAll(r)
}

func encodeCP1251(s string) ([]byte, error) {
	encoder := charmap.Windows1251.NewEncoder()
	res, _, err := transform.Bytes(encoder, []byte(s))
	if err != nil {
		return nil, fmt.Errorf("ошибка кодирования в WIN-1251: %w", err)
	}
	return res, nil
}

func parseError(data []byte) error {
	utf8Data, err := toUTF8(data)
	if err != nil {
		utf8Data = data
	}

	type ErrorResp struct {
		No  string `xml:"No,attr"`
		FSE string `xml:"FSE,attr"`
		TAG string `xml:"TAG,attr"`
		PAR string `xml:"PAR,attr"`
	}
	var e ErrorResp

	if err := xml.Unmarshal(utf8Data, &e); err != nil {
		return fmt.Errorf("ошибка ККТ (нераспознанная): %s", string(data))
	}

	desc, exists := ErrorDescriptions[e.No]
	if !exists {
		desc = "неизвестная ошибка"
	}

	msg := fmt.Sprintf("Ошибка ККТ #%s: %s", e.No, desc)

	if e.PAR != "" {
		msg += fmt.Sprintf(" (параметр: %s)", e.PAR)
	}
	if e.FSE != "" {
		fnDesc, fnExists := ErrorDescriptions[e.FSE]
		if fnExists {
			msg += fmt.Sprintf(", ошибка ФН #%s: %s", e.FSE, fnDesc)
		} else {
			msg += fmt.Sprintf(", ошибка ФН: %s", e.FSE)
		}
	}
	if e.TAG != "" {
		msg += fmt.Sprintf(" [TAG: %s]", e.TAG)
	}

	return errors.New(msg)
}
</file>

<file path="gui\connection_profiles.go">
package gui

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"
)

// ConnectionProfile представляет профиль подключения к ККТ
type ConnectionProfile struct {
	SerialNumber   string    `json:"serial_number"`   // Серийный номер ККТ (уникальный идентификатор)
	ConnectionType int       `json:"connection_type"` // 0 = COM, 6 = TCP
	ComName        string    `json:"com_name"`        // Например "COM9"
	BaudRate       int       `json:"baud_rate"`       // Например 115200
	IPAddress      string    `json:"ip_address"`      // Например "192.168.1.100"
	TCPPort        int       `json:"tcp_port"`        // Например 8200
	FirmwareVer    string    `json:"firmware_ver"`    // Версия прошивки ККТ
	ModelName      string    `json:"model_name"`      // Модель ККТ
	LastUsed       time.Time `json:"last_used"`       // Время последнего успешного подключения
}

// ProfilesStorage управляет хранением профилей подключения
type ProfilesStorage struct {
	mu       sync.RWMutex
	profiles []*ConnectionProfile
	filePath string
}

// profilesData используется для сериализации/десериализации JSON
type profilesData struct {
	Profiles []*ConnectionProfile `json:"profiles"`
}

var (
	// Глобальный экземпляр хранилища профилей
	profileStorage *ProfilesStorage
	once           sync.Once
)

// initProfilesStorage инициализирует хранилище профилей
func initProfilesStorage() {
	once.Do(func() {
		// Определяем путь к profiles.json рядом с исполняемым файлом
		exePath, err := os.Executable()
		if err != nil {
			log.Printf("[PROFILES] Ошибка получения пути к исполняемому файлу: %v", err)
			exePath = "." // fallback to current directory
		}
		var dir string
		// Обработка запуска через 'go run' (временная папка)
		if strings.Contains(exePath, "Temp") || strings.Contains(exePath, "go-build") {
			dir, err = os.Getwd()
			if err != nil {
				log.Printf("[PROFILES] Ошибка получения рабочей директории: %v", err)
				dir = "."
			}
		} else {
			dir = filepath.Dir(exePath)
		}
		filePath := filepath.Join(dir, "profiles.json")

		profileStorage = &ProfilesStorage{
			filePath: filePath,
			profiles: make([]*ConnectionProfile, 0),
		}
		// Пытаемся загрузить профили при инициализации
		_ = profileStorage.LoadProfiles()
	})
}

// LoadProfiles загружает профили из JSON-файла
func LoadProfiles() error {
	initProfilesStorage()
	return profileStorage.LoadProfiles()
}

func (s *ProfilesStorage) LoadProfiles() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	data, err := os.ReadFile(s.filePath)
	if err != nil {
		if os.IsNotExist(err) {
			log.Printf("[PROFILES] Файл профилей не найден (%s), создаем пустой список", s.filePath)
			s.profiles = make([]*ConnectionProfile, 0)
			return nil
		}
		log.Printf("[PROFILES] Ошибка чтения файла профилей (%s): %v", s.filePath, err)
		return fmt.Errorf("ошибка чтения файла профилей: %w", err)
	}

	var pd profilesData
	if err := json.Unmarshal(data, &pd); err != nil {
		log.Printf("[PROFILES] Ошибка разбора JSON файла профилей (%s): %v, сбрасываем список", s.filePath, err)
		s.profiles = make([]*ConnectionProfile, 0)
		return fmt.Errorf("ошибка разбора JSON: %w", err)
	}

	log.Printf("[PROFILES] Загружено %d профилей из файла %s", len(pd.Profiles), s.filePath)
	s.profiles = pd.Profiles
	return nil
}

// SaveProfiles (Публичный) - сохраняет профили в JSON-файл
func SaveProfiles() error {
	initProfilesStorage()
	return profileStorage.SaveProfiles()
}

func (s *ProfilesStorage) SaveProfiles() error {
	s.mu.Lock() // Блокируем на запись для внешней консистентности
	defer s.mu.Unlock()
	return s.saveProfilesLocked()
}

// saveProfilesLocked (Приватный) - выполняет запись, НЕ блокируя мьютекс (предполагает, что он уже захвачен)
func (s *ProfilesStorage) saveProfilesLocked() error {
	log.Printf("[PROFILES] Начинаем сохранение %d профилей в файл %s", len(s.profiles), s.filePath)

	data := profilesData{
		Profiles: s.profiles,
	}

	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		log.Printf("[PROFILES] Ошибка сериализации JSON: %v", err)
		return fmt.Errorf("ошибка сериализации JSON: %w", err)
	}

	if err := os.WriteFile(s.filePath, jsonData, 0644); err != nil {
		log.Printf("[PROFILES] Ошибка записи файла профилей (%s): %v", s.filePath, err)
		return fmt.Errorf("ошибка записи файла профилей: %w", err)
	}

	log.Printf("[PROFILES] Успешно сохранено %d профилей", len(s.profiles))
	return nil
}

// GetProfiles возвращает все профили
func GetProfiles() []*ConnectionProfile {
	initProfilesStorage()
	return profileStorage.GetProfiles()
}

func (s *ProfilesStorage) GetProfiles() []*ConnectionProfile {
	s.mu.RLock()
	defer s.mu.RUnlock()

	result := make([]*ConnectionProfile, len(s.profiles))
	copy(result, s.profiles)

	// Сортировка: самый свежий (LastUsed) в начале
	sort.Slice(result, func(i, j int) bool {
		return result[i].LastUsed.After(result[j].LastUsed)
	})

	return result
}

// UpsertProfile добавляет или обновляет профиль
func UpsertProfile(profile *ConnectionProfile) error {
	initProfilesStorage()
	return profileStorage.UpsertProfile(profile)
}

func (s *ProfilesStorage) UpsertProfile(profile *ConnectionProfile) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	log.Printf("[PROFILES] Добавляем/обновляем профиль SN: %s", profile.SerialNumber)

	found := false
	for i, p := range s.profiles {
		if p.SerialNumber == profile.SerialNumber {
			s.profiles[i] = profile
			found = true
			break
		}
	}

	if !found {
		s.profiles = append(s.profiles, profile)
	}

	// Вызываем внутренние методы, которые НЕ используют Lock(), так как мы уже держим Lock
	return s.saveAndLimitLocked()
}

// DeleteProfile удаляет профиль
func DeleteProfile(serialNumber string) error {
	initProfilesStorage()
	return profileStorage.DeleteProfile(serialNumber)
}

func (s *ProfilesStorage) DeleteProfile(serialNumber string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	for i, p := range s.profiles {
		if p.SerialNumber == serialNumber {
			s.profiles = append(s.profiles[:i], s.profiles[i+1:]...)
			// Используем внутренний метод сохранения
			return s.saveProfilesLocked()
		}
	}

	return fmt.Errorf("профиль с серийным номером %s не найден", serialNumber)
}

// FindProfile находит профиль
func FindProfile(serialNumber string) *ConnectionProfile {
	initProfilesStorage()
	return profileStorage.FindProfile(serialNumber)
}

func (s *ProfilesStorage) FindProfile(serialNumber string) *ConnectionProfile {
	s.mu.RLock()
	defer s.mu.RUnlock()

	for _, p := range s.profiles {
		if p.SerialNumber == serialNumber {
			return p
		}
	}
	return nil
}

// ClearProfiles очищает все профили
func ClearProfiles() error {
	initProfilesStorage()
	return profileStorage.ClearProfiles()
}

func (s *ProfilesStorage) ClearProfiles() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.profiles = make([]*ConnectionProfile, 0)
	// Используем внутренний метод
	return s.saveProfilesLocked()
}

// saveAndLimitLocked (Приватный) - лимитирует и сохраняет, предполагая, что Lock уже взят
func (s *ProfilesStorage) saveAndLimitLocked() error {
	if len(s.profiles) > 20 {
		// Сортируем
		sort.Slice(s.profiles, func(i, j int) bool {
			return s.profiles[i].LastUsed.After(s.profiles[j].LastUsed)
		})
		s.profiles = s.profiles[:20]
	}
	return s.saveProfilesLocked()
}

// UpdateLastUsed обновляет время последнего использования
func UpdateLastUsed(serialNumber string) error {
	initProfilesStorage()
	return profileStorage.UpdateLastUsed(serialNumber)
}

func (s *ProfilesStorage) UpdateLastUsed(serialNumber string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	for i, p := range s.profiles {
		if p.SerialNumber == serialNumber {
			s.profiles[i].LastUsed = time.Now()
			// Используем внутренний метод
			return s.saveProfilesLocked()
		}
	}
	return nil
}

// DisplayString возвращает строку для UI
func (p *ConnectionProfile) DisplayString() string {
	var connInfo string
	if p.ConnectionType == 0 {
		connInfo = fmt.Sprintf("%s", p.ComName)
	} else {
		connInfo = fmt.Sprintf("%s:%d", p.IPAddress, p.TCPPort)
	}

	fwVer := p.FirmwareVer
	if fwVer == "" {
		fwVer = "—"
	} else {
		fwVer = "v" + fwVer
	}

	return fmt.Sprintf("SN%s - %s - %s", p.SerialNumber, connInfo, fwVer)
}
</file>

<file path="gui\dialog_diff.go">
package gui

import (
	"mitsuscanner/internal/service"

	"github.com/lxn/walk"
	d "github.com/lxn/walk/declarative"
)

// RunDiffDialog открывает диалог подтверждения изменений.
func RunDiffDialog(owner walk.Form, changes []service.Change) (bool, []service.Change) {
	var dlg *walk.Dialog
	var tv *walk.TableView
	var acceptPB *walk.PushButton

	// Копия изменений
	localChanges := make([]service.Change, len(changes))
	copy(localChanges, changes)

	model := NewDiffModel(localChanges)

	err := d.Dialog{
		AssignTo:      &dlg,
		Title:         "Подтверждение изменений",
		MinSize:       d.Size{Width: 650, Height: 400},
		Layout:        d.VBox{},
		DefaultButton: &acceptPB,
		Children: []d.Widget{
			d.Label{Text: "Следующие настройки будут записаны в ККТ:"},
			d.TableView{
				AssignTo:         &tv,
				AlternatingRowBG: true,
				Model:            model,
				Columns: []d.TableViewColumn{
					{Title: "Параметр", Width: 220},
					{Title: "Было", Width: 180},
					{Title: "Стало", Width: 180},
				},
				// Контекстное меню убрали, как просили
			},
			d.Composite{
				Layout: d.HBox{},
				Children: []d.Widget{
					d.Label{Text: "* Правый клик по строке для отмены (удаления) изменения", Font: d.Font{PointSize: 8}, TextColor: walk.RGB(100, 100, 100)},
					d.HSpacer{},
					d.PushButton{
						AssignTo:  &acceptPB,
						Text:      "Применить",
						OnClicked: func() { dlg.Accept() },
					},
					d.PushButton{
						Text:      "Отмена",
						OnClicked: func() { dlg.Cancel() },
					},
				},
			},
		},
	}.Create(owner)

	if err != nil {
		walk.MsgBox(owner, "Ошибка", err.Error(), walk.MsgBoxIconError)
		return false, nil
	}

	// ХАК: Обработка правого клика вручную для удаления
	// walk.TableView не имеет OnItemRightClicked в декларативном виде,
	tv.MouseDown().Attach(func(x, y int, button walk.MouseButton) {
		if button == walk.RightButton {
			// Определяем индекс строки под курсором
			// К сожалению, walk не дает простого способа получить строку по координатам в public API без WinAPI.
			// НО: Обычно правый клик выделяет строку. Попробуем взять CurrentIndex.
			idx := tv.CurrentIndex()
			if idx >= 0 {
				model.RemoveItem(idx)
			}
		}
	})

	if dlg.Run() == walk.DlgCmdOK {
		// Возвращаем true и список (даже если он пуст)
		return true, model.items
	}

	return false, nil
}

// DiffModel модель для таблицы изменений
type DiffModel struct {
	walk.TableModelBase
	items []service.Change
}

func NewDiffModel(items []service.Change) *DiffModel {
	return &DiffModel{items: items}
}

func (m *DiffModel) RowCount() int {
	return len(m.items)
}

func (m *DiffModel) Value(row, col int) interface{} {
	if row >= len(m.items) {
		return ""
	}
	item := m.items[row]
	switch col {
	case 0:
		return item.Description
	case 1:
		return item.OldValue
	case 2:
		return item.NewValue
	}
	return ""
}

func (m *DiffModel) RemoveItem(index int) {
	if index < 0 || index >= len(m.items) {
		return
	}
	m.items = append(m.items[:index], m.items[index+1:]...)
	m.PublishRowsReset()
}
</file>

<file path="gui\dialog_reasons.go">
package gui

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/lxn/walk"
	d "github.com/lxn/walk/declarative"
)

// RunReasonDialog открывает диалог.
func RunReasonDialog(owner walk.Form, currentCodes string) (string, bool) {
	var dlg *walk.Dialog
	var acceptPB, cancelPB *walk.PushButton

	// Переменная для сохранения результата, пока окно еще открыто
	var resultString string

	// 1. Парсинг текущих кодов
	selectedMap := make(map[int]bool)
	if currentCodes != "" {
		parts := strings.Split(currentCodes, ",")
		for _, p := range parts {
			p = strings.TrimSpace(p)
			if code, err := strconv.Atoi(p); err == nil {
				selectedMap[code] = true
			}
		}
	}

	// 2. Список причин
	reasons := []string{
		"1 - Замена ФН",
		"2 - Замена ОФД",
		"3 - Изменение реквизитов пользователя",
		"4 - Изменение адреса/места установки",
		"5 - Перевод кассы из автономного режима в режим передачи данных",
		"6 - Перевод кассы из режима передачи данных в автономный режим",
		"7 - Изменение версии модели ККТ",
		"8 - Изменение перечня СНО",
		"9 - Изменение номера автомата",
		"10 - Отключение автоматического режима (осуществление расчетов кассиром)",
		"11 - Включение автоматического режима",
		"12 - Включение режима БСО",
		"13 - Отключение режима БСО",
		"14 - Отключение режима расчетов в сети Интернет",
		"15 - Включение режима расчетов в Интернет (можно не печатать чек и БСО)",
		"18 - Отключение режима азартных игр",
		"19 - Включение режима азартных игр (прием ставок, выплата выигрыша)",
		"20 - Отключение режима лотерей",
		"21 - Включение режима лотерей (продажа билетов, выплата выигрышей)",
		"22 - Изменение версии ФФД",
		"32 - Иные причины",
	}

	// Создаем слайс для хранения указателей на чекбоксы и соответствующих кодов
	checkBoxes := make([]*walk.CheckBox, len(reasons))
	codesList := make([]int, len(reasons))
	var checkWidgets []d.Widget

	// 3. Генерация виджетов
	for i, text := range reasons {
		idx := i
		parts := strings.Split(text, " - ")
		code, _ := strconv.Atoi(parts[0])
		codesList[idx] = code
		isChecked := selectedMap[code]

		checkWidgets = append(checkWidgets, d.CheckBox{
			AssignTo: &checkBoxes[idx], // Привязываем Go-структуру
			Text:     text,
			Checked:  isChecked,
			MinSize:  d.Size{Width: 350},
		})
	}

	// 4. Описание диалога
	err := d.Dialog{
		AssignTo:      &dlg,
		Title:         "Причины перерегистрации (ФНС)",
		MinSize:       d.Size{Width: 360, Height: 320},
		MaxSize:       d.Size{Width: 360, Height: 320},
		FixedSize:     true,
		Layout:        d.VBox{},
		DefaultButton: &acceptPB,
		CancelButton:  &cancelPB,
		Children: []d.Widget{
			d.ScrollView{
				Layout:          d.VBox{MarginsZero: true},
				HorizontalFixed: true,
				Children: []d.Widget{
					d.Composite{
						// Выравниваем слева сверху
						Layout:   d.VBox{MarginsZero: true, Spacing: 2, Alignment: d.AlignHNearVNear},
						Children: checkWidgets,
					},
				},
			},
			d.Composite{
				Layout: d.HBox{Margins: d.Margins{Top: 5}},
				Children: []d.Widget{
					d.HSpacer{},
					d.PushButton{
						AssignTo: &acceptPB,
						Text:     "OK",
						OnClicked: func() {
							// Считываем данные ЗДЕСЬ, пока окно живо
							var codes []string
							for i, cb := range checkBoxes {
								if cb.Checked() {
									codes = append(codes, fmt.Sprintf("%d", codesList[i]))
								}
							}
							resultString = strings.Join(codes, ",")

							// Закрываем окно с результатом OK
							dlg.Close(walk.DlgCmdOK)
						},
					},
					d.PushButton{
						AssignTo: &cancelPB,
						Text:     "Отмена",
						OnClicked: func() {
							dlg.Close(walk.DlgCmdCancel)
						},
					},
				},
			},
		},
	}.Create(owner)

	if err != nil {
		fmt.Println("Error creating dialog:", err)
		return "", false
	}

	// Запуск
	// Если вернулся OK, значит мы уже заполнили resultString внутри OnClicked
	if dlg.Run() == walk.DlgCmdOK {
		return resultString, true
	}

	return "", false
}
</file>

<file path="gui\dialog_report.go">
package gui

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode/utf8"

	"mitsuscanner/driver"

	"github.com/lxn/walk"
	d "github.com/lxn/walk/declarative"
)

/*
   ===============================
   REPORT MODAL - МОДАЛКА ДЛЯ ОТЧЕТОВ
   ===============================

   Архитектура:
   1. buildReportLines   — сбор данных отчета (БЕЗ форматирования)
   2. formatKeyValueText — выравнивание и формирование plain text
   3. buildFormattedText — тонкая склейка
   4. RunReportModal     — UI

   ВАЖНО:
   Итог — обычная строка (plain text).
   Она используется ОДИНАКОВО для:
   - отображения
   - копирования
   - сохранения
*/

// --------------------
// Модель строки
// --------------------

type kv struct {
	Key   string
	Value string
}

// --------------------
// 1. СБОР ДАННЫХ
// --------------------

func buildReportLines(data interface{}, kind driver.ReportKind) ([]kv, error) {
	switch kind {
	case driver.ReportKindRegistration:
		var rd driver.RegData
		if d, ok := data.(driver.RegData); ok {
			rd = d
		} else if d, ok := data.(*driver.RegData); ok {
			rd = *d
		} else {
			return nil, fmt.Errorf("invalid report data type: %T", data)
		}
		return buildRegistrationLines(rd), nil
	case driver.ReportKindCloseFn:
		var cd driver.ReportFnCloseData
		if d, ok := data.(driver.ReportFnCloseData); ok {
			cd = d
		} else if d, ok := data.(*driver.ReportFnCloseData); ok {
			cd = *d
		} else {
			return nil, fmt.Errorf("invalid report data type: %T", data)
		}
		return buildCloseFnLines(cd), nil
	default:
		return nil, fmt.Errorf("unknown report kind: %v", kind)
	}
}

func buildRegistrationLines(regData driver.RegData) []kv {
	var lines []kv

	lines = append(lines, kv{"ЗН ФР", regData.PrinterSerial})
	lines = append(lines, kv{"Номер ФД", regData.FdNumber})
	lines = append(lines, kv{"ФП", regData.FpNumber})
	lines = append(lines, kv{"Дата и время регистрации", formatDateTime(regData.RegDate, regData.RegTime)})
	lines = append(lines, kv{"Номер ФН", regData.FnSerial})
	lines = append(lines, kv{"Исполнение ФН", regData.FnEdition})
	lines = append(lines, kv{"РНМ", formatRNM(regData.RNM)})
	lines = append(lines, kv{"ИНН организации", regData.Inn})
	lines = append(lines, kv{"Наименование организации", regData.OrgName})
	lines = append(lines, kv{"Адрес расчетов", regData.Address})
	lines = append(lines, kv{"Место расчетов", regData.Place})

	lines = append(lines, kv{"Версия ФФД", formatFFD(regData.FfdVer)})
	lines = append(lines, kv{"Системы налогообложения (СНО)", formatTaxSystems(regData.TaxSystems)})
	lines = append(lines, kv{"Базовая система налогообложения", regData.TaxBase})

	lines = append(lines, kv{"ИНН ОФД", regData.OfdInn})
	lines = append(lines, kv{"Наименование ОФД", regData.OfdName})
	lines = append(lines, kv{"Коды причин регистрации", regData.Base})

	// Флаги — добавляем только если есть
	appendIfNotEmpty(&lines, "Маркировка товаров", regData.MarkAttr)
	appendIfNotEmpty(&lines, "Подакцизные товары", regData.ExciseAttr)
	appendIfNotEmpty(&lines, "Расчеты в сети Интернет", regData.InternetAttr)
	appendIfNotEmpty(&lines, "Услуги", regData.ServiceAttr)
	appendIfNotEmpty(&lines, "БСО", regData.BsoAttr)
	appendIfNotEmpty(&lines, "Лотерея", regData.LotteryAttr)
	appendIfNotEmpty(&lines, "Азартные игры", regData.GamblingAttr)
	appendIfNotEmpty(&lines, "Ломбард", regData.PawnAttr)
	appendIfNotEmpty(&lines, "Страхование", regData.InsAttr)
	appendIfNotEmpty(&lines, "Общепит", regData.DineAttr)
	appendIfNotEmpty(&lines, "Оптовая торговля", regData.OptAttr)
	appendIfNotEmpty(&lines, "Вендинг", regData.VendAttr)
	appendIfNotEmpty(&lines, "Автоматический режим", regData.AutoModeAttr)
	appendIfNotEmpty(&lines, "Номер автомата", regData.AutoNumAttr)

	return lines
}

func buildCloseFnLines(closeData driver.ReportFnCloseData) []kv {
	var lines []kv

	lines = append(lines, kv{"Дата и время закрытия", closeData.DateTime})
	lines = append(lines, kv{"ФП", closeData.FP})
	lines = append(lines, kv{"Номер ФД", fmt.Sprintf("%d", closeData.FD)})
	lines = append(lines, kv{"РНМ", formatRNM(closeData.RNM)})
	lines = append(lines, kv{"Номер ФН", closeData.FNNumber})
	lines = append(lines, kv{"ЗН ККТ", closeData.KKTNumber})
	lines = append(lines, kv{"Адрес расчетов", closeData.Address})
	lines = append(lines, kv{"Место расчетов", closeData.Place})

	return lines
}

func appendIfNotEmpty(lines *[]kv, key, value string) {
	if value != "" {
		*lines = append(*lines, kv{key, value})
	}
}

// --------------------
// 2. ФОРМАТИРОВАНИЕ
// --------------------

func formatKeyValueText(lines []kv) string {
	maxKeyLen := 0
	for _, l := range lines {
		keyLen := utf8.RuneCountInString(l.Key)
		if keyLen > maxKeyLen {
			maxKeyLen = keyLen
		}
	}

	var b strings.Builder

	for _, l := range lines {
		keyPad := maxKeyLen - utf8.RuneCountInString(l.Key)
		prefix := l.Key + strings.Repeat(" ", keyPad) + ": "

		value := normalizeNewlines(l.Value)
		valueLines := strings.Split(value, "\n")

		// Первая строка
		b.WriteString(prefix)
		b.WriteString(valueLines[0])
		b.WriteString("\n")

		// Остальные строки (если есть)
		for i := 1; i < len(valueLines); i++ {
			b.WriteString(strings.Repeat(" ", utf8.RuneCountInString(prefix)))
			b.WriteString(valueLines[i])
			b.WriteString("\n")
		}
	}

	return b.String()
}

func normalizeNewlines(s string) string {
	s = strings.ReplaceAll(s, "\r\n", "\n")
	s = strings.ReplaceAll(s, "\r", "\n")
	return s
}

func toWindowsText(s string) string {
	return strings.ReplaceAll(s, "\n", "\r\n")
}

// --------------------
// 3. СКЛЕЙКА
// --------------------

func buildFormattedReportText(meta driver.ReportMeta) (string, error) {
	if meta.Data == nil {
		return "", fmt.Errorf("report data is nil")
	}
	if meta.Text != "" {
		return meta.Text, nil
	}
	lines, err := buildReportLines(meta.Data, meta.Kind)
	if err != nil {
		return "", err
	}
	return formatKeyValueText(lines), nil
}

// --------------------
// 4. UI
// --------------------

func RunReportModal(owner walk.Form, meta driver.ReportMeta) {
	var dlg *walk.Dialog
	var copyPB, savePB, closePB *walk.PushButton

	text, err := buildFormattedReportText(meta)
	if err != nil {
		walk.MsgBox(owner, "Ошибка", err.Error(), walk.MsgBoxIconError)
		return
	}

	err = d.Dialog{
		AssignTo:      &dlg,
		Title:         meta.Title,
		MinSize:       d.Size{Width: 500, Height: 400},
		MaxSize:       d.Size{Width: 500, Height: 400},
		Layout:        d.VBox{},
		DefaultButton: &copyPB,
		CancelButton:  &closePB,
		Children: []d.Widget{
			d.TextEdit{
				Text:     toWindowsText(text),
				ReadOnly: true,
				VScroll:  true,
				Font:     d.Font{Family: "Consolas", PointSize: 9},
			},
			d.Composite{
				Layout: d.HBox{Spacing: 6},
				Children: []d.Widget{
					d.HSpacer{},
					d.PushButton{
						AssignTo: &copyPB,
						Text:     "Копировать",
						OnClicked: func() {
							_ = walk.Clipboard().SetText(text)
						},
					},
					d.PushButton{
						AssignTo: &savePB,
						Text:     "Сохранить",
						OnClicked: func() {
							if err := saveReportText(text, meta.Kind); err != nil {
								walk.MsgBox(dlg, "Ошибка", err.Error(), walk.MsgBoxIconError)
							}
						},
					},
					d.PushButton{
						AssignTo: &closePB,
						Text:     "Закрыть",
						OnClicked: func() {
							dlg.Accept()
						},
					},
				},
			},
		},
	}.Create(owner)

	if err != nil {
		panic(err)
	}

	dlg.Run()
}

// RunRegistrationTextDialog - обратная совместимость
func RunRegistrationTextDialog(owner walk.Form, regData driver.RegData) {
	meta := driver.ReportMeta{
		Kind:  driver.ReportKindRegistration,
		Title: "Расшифрованные данные регистрации",
		Data:  regData,
	}
	RunReportModal(owner, meta)
}

// saveReportText сохраняет текст отчета в соответствующую папку.
func saveReportText(text string, kind driver.ReportKind) error {
	var dir string
	var filename string
	switch kind {
	case driver.ReportKindRegistration:
		dir = "./registration_docs"
		filename = "registration_data.txt"
	case driver.ReportKindCloseFn:
		dir = "./close_fn_docs"
		filename = "close_fn_data.txt"
	default:
		dir = "./reports"
		filename = "report_data.txt"
	}
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}
	fullPath := filepath.Join(dir, filename)
	return os.WriteFile(fullPath, []byte(text), 0644)
}

// saveRegistrationText - обратная совместимость
func saveRegistrationText(text string) error {
	return saveReportText(text, driver.ReportKindRegistration)
}

// formatRNM форматирует РНМ с пробелами по 4 цифры.
func formatRNM(rnm string) string {
	if len(rnm) != 16 {
		return rnm
	}
	return fmt.Sprintf("%s %s %s %s", rnm[0:4], rnm[4:8], rnm[8:12], rnm[12:16])
}

// formatDateTime форматирует дату и время как дд.мм.гггг чч:мм.
func formatDateTime(date, time string) string {
	if len(date) != 10 || len(time) < 5 {
		return date + " " + time
	}
	// date: гггг-мм-дд
	// time: чч:мм:сс
	year := date[0:4]
	month := date[5:7]
	day := date[8:10]
	hour := time[0:2]
	min := time[3:5]
	return fmt.Sprintf("%s.%s.%s %s:%s", day, month, year, hour, min)
}

// formatFFD заменяет 4 на 1.2.
func formatFFD(ffd string) string {
	if ffd == "4" {
		return "1.2"
	}
	return ffd
}

// formatTaxSystems расшифровывает системы налогообложения.
func formatTaxSystems(tax string) string {
	taxMap := map[string]string{
		"0": "ОСН",
		"1": "УСН доход",
		"2": "УСН доход-расход",
		"3": "ЕНВД",
		"4": "ЕСХН",
		"5": "Патент",
	}
	parts := strings.Split(tax, ",")
	var names []string
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if name, ok := taxMap[p]; ok {
			names = append(names, name)
		} else {
			names = append(names, p)
		}
	}
	return strings.Join(names, ", ")
}
</file>

<file path="gui\execution.go">
package gui

import (
	"fmt"
	"sort"

	"mitsuscanner/driver"
	"mitsuscanner/internal/service"

	"github.com/lxn/walk"
)

func ApplyChangesPipeline(changes []service.Change) {
	drv := driver.Active
	if drv == nil {
		return
	}

	// ЕСЛИ СПИСОК ИЗМЕНЕНИЙ ПУСТ (пользователь удалил всё в диалоге и нажал Применить)
	if len(changes) == 0 {
		mw.Synchronize(func() {
			// Восстанавливаем состояние из памяти
			restoreViewFromSnapshot(serviceModel, initialSnapshot)
			logMsg("[SYSTEM] Изменения отменены пользователем, возврат к исходным настройкам.")
		})
		return
	}

	// 1. Сортировка (Normal -> Cliche -> Network)
	sort.Slice(changes, func(i, j int) bool {
		return changes[i].Priority < changes[j].Priority
	})

	mw.Synchronize(func() {
		isLoadingData = true
		btnServiceAction.SetEnabled(false)
		btnServiceAction.SetText("Запись...")
	})

	go func() {
		var errCount int
		var needReboot bool

		for i, ch := range changes {
			mw.Synchronize(func() {
				btnServiceAction.SetText(fmt.Sprintf("Запись %d/%d...", i+1, len(changes)))
			})

			if err := ch.ApplyFunc(drv); err != nil {
				errCount++
				fmt.Printf("Error applying %s: %v\n", ch.ID, err)
			}

			if ch.Priority == service.PriorityNetwork {
				needReboot = true
			}
		}

		mw.Synchronize(func() {
			if errCount > 0 {
				walk.MsgBox(mw, "Завершено с ошибками", fmt.Sprintf("Не удалось применить %d настроек.\nСм. лог (консоль).", errCount), walk.MsgBoxIconWarning)
			} else {
				msg := "Настройки успешно сохранены."
				if needReboot {
					msg += "\n\nБыли изменены сетевые настройки. Устройство перезагружается..."
				}
				walk.MsgBox(mw, "Успех", msg, walk.MsgBoxIconInformation)
			}

			if needReboot {
				go drv.RebootDevice()
				onReadAllSettings()
			} else {
				onReadAllSettings()
			}
		})
	}()
}
</file>

<file path="gui\helpers.go">
package gui

import (
	"mitsuscanner/driver"
)

// =============================================================================
// ХЕЛПЕРЫ ДЛЯ СБОРКИ ДАННЫХ ИЗ НЕСКОЛЬКИХ АТОМАРНЫХ ОПЕРАЦИЙ ДРАЙВЕРА
// =============================================================================

// GetFullRegistrationData собирает полные данные регистрации для отображения в GUI.
// Выполняет последовательность команд:
//   - GET REG='?' (основные данные регистрации)
//   - GET INFO='F' (данные ФН: серийный номер, исполнение)
//   - GET VER='?' (серийный номер принтера)
//
// Используется в: onReadRegistration, onRegister, onReregister
func GetFullRegistrationData(drv driver.Driver) (*driver.RegData, error) {
	// 1. Базовые данные регистрации
	regData, err := drv.GetRegistrationData()
	if err != nil {
		return nil, err
	}

	// 2. Данные ФН (серийный номер, исполнение)
	// Ошибки игнорируем — поля останутся пустыми
	if fnStatus, err := drv.GetFnStatus(); err == nil {
		regData.FnSerial = fnStatus.Serial
		regData.FnEdition = fnStatus.Edition
	}

	// 3. Серийный номер принтера
	// Ошибки игнорируем — поле останется пустым
	if _, serial, _, err := drv.GetVersion(); err == nil {
		regData.PrinterSerial = serial
	}

	return regData, nil
}

// GetCloseFnReportData собирает данные для отчёта о закрытии фискального накопителя.
// Выполняет последовательность команд:
//   - GET REG='?' (RNM, адрес, место)
//   - GET INFO='F' (серийный номер ФН)
//   - GET VER='?' (серийный номер принтера)
//   - GET DOC='X:fd' + READ (XML документа для извлечения даты-времени)
//
// Параметры:
//   - drv: активный драйвер
//   - fd: номер фискального документа (из результата CloseFiscalArchive)
//   - fp: фискальный признак (из результата CloseFiscalArchive)
//
// Используется в: onCloseFn
func GetCloseFnReportData(drv driver.Driver, fd int, fp string) (*driver.ReportFnCloseData, error) {
	// 1. Базовые данные регистрации (RNM, адрес, место)
	regData, err := drv.GetRegistrationData()
	if err != nil {
		return nil, err
	}

	// 2. Серийный номер ФН
	fnSerial := ""
	if fnStatus, err := drv.GetFnStatus(); err == nil {
		fnSerial = fnStatus.Serial
	}

	// 3. Серийный номер принтера (ЗН ККТ)
	printerSerial := ""
	if _, serial, _, err := drv.GetVersion(); err == nil {
		printerSerial = serial
	}

	// 4. Дата-время из XML документа в ФН
	dateTimeStr := "—"
	if xmlDoc, err := drv.GetDocumentXMLFromFN(fd); err == nil {
		if dt, err := driver.ExtractDocDateTime(xmlDoc); err == nil {
			dateTimeStr = dt
		}
	}

	return &driver.ReportFnCloseData{
		FD:        fd,
		FP:        fp,
		DateTime:  dateTimeStr,
		RNM:       regData.RNM,
		FNNumber:  fnSerial,
		KKTNumber: printerSerial,
		Address:   regData.Address,
		Place:     regData.Place,
	}, nil
}
</file>

<file path="gui\image_utils.go">
package gui

import (
	"bytes"
	"fmt"
	"image"
	"image/color"
	_ "image/jpeg" // Поддержка декодирования JPG
	_ "image/png"  // Поддержка декодирования PNG
	"os"

	"golang.org/x/image/bmp"
	"golang.org/x/image/draw"
)

// PrepareImageForKKT загружает изображение, изменяет размер и конвертирует в монохромный BMP.
// maxWidth: максимальная ширина (обычно 384 для 57мм или 576 для 80мм).
func PrepareImageForKKT(path string, maxWidth int) ([]byte, error) {
	// 1. Открываем файл
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	img, _, err := image.Decode(file)
	if err != nil {
		return nil, fmt.Errorf("ошибка декодирования изображения: %w", err)
	}

	// 2. Ресайз (сохраняя пропорции)
	bounds := img.Bounds()
	width := bounds.Dx()
	height := bounds.Dy()

	var newWidth, newHeight int
	if width > maxWidth {
		ratio := float64(maxWidth) / float64(width)
		newWidth = maxWidth
		newHeight = int(float64(height) * ratio)
	} else {
		newWidth = width
		newHeight = height
	}

	// Создаем rect для ресайза
	// Используем Gray, чтобы сразу получить ч/б оттенки
	grayImg := image.NewGray(image.Rect(0, 0, newWidth, newHeight))

	// Используем бикубическую интерполяцию для качественного ресайза
	draw.CatmullRom.Scale(grayImg, grayImg.Bounds(), img, bounds, draw.Over, nil)

	// 3. Бинаризация (Thresholding) -> превращаем в 1-битный Paletted
	// Создаем палитру: Индекс 0 - Черный, 1 - Белый (стандарт для термопечати)
	palette := color.Palette{
		color.Black,
		color.White,
	}

	palettedImg := image.NewPaletted(grayImg.Bounds(), palette)

	// Порог бинаризации (128 из 255)
	threshold := 128

	for y := 0; y < newHeight; y++ {
		for x := 0; x < newWidth; x++ {
			grayColor := grayImg.GrayAt(x, y)
			if int(grayColor.Y) > threshold {
				palettedImg.SetColorIndex(x, y, 1) // Белый
			} else {
				palettedImg.SetColorIndex(x, y, 0) // Черный
			}
		}
	}

	// 4. Кодирование в BMP
	var buf bytes.Buffer
	// bmp.Encode поддерживает сохранение Paletted изображений с глубиной 1 бит,
	// если в палитре 2 цвета.
	if err := bmp.Encode(&buf, palettedImg); err != nil {
		return nil, fmt.Errorf("ошибка кодирования в BMP: %w", err)
	}

	return buf.Bytes(), nil
}
</file>

<file path="gui\kkt_monitor.go">
package gui

import (
	"context"
	"log"
	"sync"
	"time"

	"mitsuscanner/driver"
)

// KktPanelStatus содержит данные состояния для верхней панели
type KktPanelStatus struct {
	ModelName    string    // Модель ККТ
	SerialNumber string    // Серийный номер
	UnsentDocs   int       // Количество неотправленных документов в ОФД
	PowerFlag    bool      // Текущее значение флага питания (TRUE=OK, FALSE=Reboot)
	LastUpdate   time.Time // Время последнего обновления
}

// Глобальные переменные модуля
var (
	monitorCtx     context.Context
	monitorCancel  context.CancelFunc
	monitorMutex   sync.Mutex
	panelStatus    = &KktPanelStatus{}
	updateCallback func(*KktPanelStatus)
	isPaused       bool
)

// StartMonitor запускает мониторинг.
func StartMonitor(drv driver.Driver, model, serial string, unsentDocs int) {
	monitorMutex.Lock()
	defer monitorMutex.Unlock()

	// Если уже запущен - остановим
	if monitorCancel != nil {
		monitorCancel()
	}

	// Инициализация контекста
	monitorCtx, monitorCancel = context.WithCancel(context.Background())

	// Установка начального состояния
	panelStatus.ModelName = model
	panelStatus.SerialNumber = serial
	panelStatus.UnsentDocs = unsentDocs
	// Важно: Мы предполагаем, что при старте мониторинга мы уже установили флаг в 1 (TRUE).
	// Поэтому начальное состояние = true (OK).
	panelStatus.PowerFlag = true
	panelStatus.LastUpdate = time.Now()

	// Сразу обновляем UI начальными данными
	if updateCallback != nil {
		statusCopy := *panelStatus
		go updateCallback(&statusCopy)
	}

	// Запуск горутины мониторинга
	go monitorRoutine(drv)
	log.Printf("[MONITOR] Мониторинг ККТ запущен (Тихий режим)")
}

// StopMonitor останавливает мониторинг
func StopMonitor() {
	monitorMutex.Lock()
	defer monitorMutex.Unlock()

	if monitorCancel != nil {
		monitorCancel()
		monitorCancel = nil
		log.Printf("[MONITOR] Мониторинг ККТ остановлен")
	}
}

// PauseMonitor приостанавливает мониторинг (для рег-запросов)
func PauseMonitor() {
	monitorMutex.Lock()
	defer monitorMutex.Unlock()
	isPaused = true
}

// ResumeMonitor возобновляет мониторинг
func ResumeMonitor() {
	monitorMutex.Lock()
	defer monitorMutex.Unlock()
	isPaused = false
}

// SetUpdateCallback устанавливает callback для обновления UI
func SetUpdateCallback(fn func(*KktPanelStatus)) {
	monitorMutex.Lock()
	defer monitorMutex.Unlock()
	updateCallback = fn
}

// monitorRoutine - основная горутина мониторинга
func monitorRoutine(drv driver.Driver) {
	// Небольшая пауза перед началом опроса
	time.Sleep(2 * time.Second)

	ticker := time.NewTicker(3 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-monitorCtx.Done():
			return

		case <-ticker.C:
			monitorMutex.Lock()
			if isPaused {
				monitorMutex.Unlock()
				continue
			}
			monitorMutex.Unlock()

			// Опрашиваем ТОЛЬКО флаг питания
			checkPowerFlag(drv)
		}
	}
}

// checkPowerFlag проверяет только флаг питания
func checkPowerFlag(drv driver.Driver) {
	// Получаем текущий флаг питания из ККТ
	// Если ККТ перезагрузилась, флаг сбросится в 0 (false).
	// Если все ок, он останется 1 (true), который мы установили при подключении.
	powerFlag, err := drv.GetPowerFlag()
	if err != nil {
		// Ошибки связи не логируем в основной лог, чтобы не спамить
		// Можно добавить счетчик ошибок, если нужно
		return
	}

	monitorMutex.Lock()
	changed := powerFlag != panelStatus.PowerFlag
	panelStatus.PowerFlag = powerFlag
	panelStatus.LastUpdate = time.Now()
	monitorMutex.Unlock()

	// Если состояние изменилось, обновляем UI
	if changed && updateCallback != nil {
		monitorMutex.Lock()
		statusCopy := *panelStatus
		monitorMutex.Unlock()

		// Логируем только событие смены статуса
		if !statusCopy.PowerFlag {
			log.Printf("[MONITOR] ВНИМАНИЕ: Обнаружена перезагрузка ККТ! (Флаг сброшен)")
		} else {
			log.Printf("[MONITOR] Питание восстановлено/подтверждено.")
		}

		go updateCallback(&statusCopy)
	}
}
</file>

<file path="gui\network_scanner.go">
package gui

import (
	"bufio"
	"bytes"
	"fmt"
	"net"
	"os/exec"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/lxn/walk"
)

func runNetworkScan() {
	mw.Synchronize(func() {
		actionBtn.SetEnabled(false)
		actionBtn.SetText("Сканирование...")
		logMsg("--- Запуск поиска по ARP (MAC 00-22-00...) ---")
	})

	// 1. "Прогрев" ARP
	if err := triggerArpDiscovery(); err != nil {
		logMsg("Ошибка инициации ARP: %v", err)
	}

	// Даем ОС время на обновление таблицы
	time.Sleep(1 * time.Second)

	// 2. Читаем таблицу
	arpTable, err := getArpTable()
	if err != nil {
		logMsg("Ошибка чтения ARP таблицы: %v", err)
		restoreBtnState()
		return
	}

	// 3. Фильтруем по MAC Mitsu
	var candidates []string
	mitsuPrefix := "00-22-00"

	for ip, mac := range arpTable {
		// Нормализуем MAC
		cleanMac := strings.ReplaceAll(mac, "-", "")
		cleanMac = strings.ReplaceAll(cleanMac, ":", "")
		cleanMac = strings.ToUpper(cleanMac)
		cleanPrefix := strings.ReplaceAll(mitsuPrefix, "-", "")

		if strings.HasPrefix(cleanMac, cleanPrefix) {
			logMsg("Найден кандидат в ARP: %s [%s]", ip, mac)
			candidates = append(candidates, ip)
		}
	}

	if len(candidates) == 0 {
		mw.Synchronize(func() {
			logMsg("Устройства Mitsu не найдены в ARP.")
			walk.MsgBox(mw, "Результат", "Устройства не найдены.\nПопробуйте пропинговать устройство вручную.", walk.MsgBoxIconInformation)
			restoreBtnState()
		})
		return
	}

	// 4. Проверяем открытый порт 8200
	foundChan := make(chan string, len(candidates))
	var wg sync.WaitGroup

	logMsg("Проверка порта 8200 у %d кандидатов...", len(candidates))

	for _, ip := range candidates {
		wg.Add(1)
		go func(targetIP string) {
			defer wg.Done()
			conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:8200", targetIP), 500*time.Millisecond)
			if err == nil {
				conn.Close()
				foundChan <- targetIP
			} else {
				logMsg("IP %s: MAC совпал, но порт 8200 закрыт.", targetIP)
			}
		}(ip)
	}

	wg.Wait()
	close(foundChan)

	var foundList []string
	for ip := range foundChan {
		logMsg("ПОДТВЕРЖДЕНО: %s", ip)
		foundList = append(foundList, fmt.Sprintf("%s:8200", ip))
	}

	mw.Synchronize(func() {
		if len(foundList) > 0 {
			newList := getInitialDeviceList()
			searchItem := newList[len(newList)-1]
			newList = newList[:len(newList)-1]
			newList = append(newList, foundList...)
			newList = append(newList, searchItem)

			addrCombo.SetModel(newList)
			addrCombo.SetText(foundList[0])
			logMsg("Найдено %d устр.", len(foundList))
		} else {
			logMsg("Порт 8200 недоступен у найденных MAC.")
			walk.MsgBox(mw, "Результат", "Устройства найдены по MAC, но порт 8200 закрыт.", walk.MsgBoxIconWarning)
		}
		updateUIState()
		actionBtn.SetEnabled(true)
	})
}

func restoreBtnState() {
	mw.Synchronize(func() {
		updateUIState()
	})
}

// triggerArpDiscovery пингует подсеть UDP пакетами
func triggerArpDiscovery() error {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return err
	}

	var wg sync.WaitGroup
	sem := make(chan struct{}, 100)

	for _, a := range addrs {
		ipnet, ok := a.(*net.IPNet)
		if !ok || ipnet.IP.IsLoopback() || ipnet.IP.To4() == nil {
			continue
		}

		ip := ipnet.IP.To4()
		mask := ipnet.Mask
		ones, _ := mask.Size()
		if ones < 24 {
			continue // Пропускаем большие сети
		}

		baseIP := ip.Mask(mask)
		for i := 1; i < 255; i++ {
			targetIP := net.IPv4(baseIP[0], baseIP[1], baseIP[2], byte(i))
			if targetIP.Equal(ip) {
				continue
			}

			wg.Add(1)
			sem <- struct{}{}
			go func(ipStr string) {
				defer wg.Done()
				defer func() { <-sem }()
				// Шлем пакет на порт 8200 (или любой другой), чтобы инициировать ARP запрос
				conn, err := net.DialTimeout("udp", fmt.Sprintf("%s:8200", ipStr), 100*time.Millisecond)
				if err == nil {
					conn.Write([]byte{0x00})
					conn.Close()
				}
			}(targetIP.String())
		}
	}
	wg.Wait()
	return nil
}

// getArpTable парсит 'arp -a'
func getArpTable() (map[string]string, error) {
	cmd := exec.Command("arp", "-a")
	output, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	result := make(map[string]string)
	// Регулярка для IP и MAC (поддержка Windows "-" и Unix ":")
	re := regexp.MustCompile(`(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+([0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2})`)

	scanner := bufio.NewScanner(bytes.NewReader(output))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		matches := re.FindStringSubmatch(line)
		if len(matches) == 3 {
			result[matches[1]] = matches[2]
		}
	}
	return result, nil
}
</file>

<file path="gui\ofd_transfer.go">
package gui

import (
	"context"
	"fmt"
	"mitsuscanner/driver"
	"mitsuscanner/pkg/ofdclient"
	"time"
)

// OfdTransferResult содержит результат передачи документа
type OfdTransferResult struct {
	Success       bool
	DocumentsSent int
	ErrorMessage  string
}

// SendFirstUnsentDocument отправляет первый неотправленный документ в ОФД.
// Это заглушка - в будущем здесь будет реальный клиент ОФД.
func SendFirstUnsentDocument(drv driver.Driver) (*OfdTransferResult, error) {
	result := &OfdTransferResult{}

	// 1. Проверяем статус обмена с ОФД
	ofdStatus, err := drv.GetOfdExchangeStatus()
	if err != nil {
		return nil, fmt.Errorf("ошибка получения статуса ОФД: %w", err)
	}

	if ofdStatus.Count == 0 {
		result.Success = true
		result.DocumentsSent = 0
		result.ErrorMessage = "Нет неотправленных документов"
		return result, nil
	}

	// 2. Проверяем/устанавливаем режим внешнего клиента
	ofdSettings, err := drv.GetOfdSettings()
	if err != nil {
		return nil, fmt.Errorf("ошибка получения настроек ОФД: %w", err)
	}

	originalClient := ofdSettings.Client
	needRestore := false

	if ofdSettings.Client != "1" {
		// Переключаем на внешний клиент
		ofdSettings.Client = "1"
		if err := drv.SetOfdSettings(*ofdSettings); err != nil {
			return nil, fmt.Errorf("ошибка установки режима внешнего клиента: %w", err)
		}
		needRestore = true
	}

	// Гарантируем восстановление настроек
	defer func() {
		if needRestore {
			ofdSettings.Client = originalClient
			drv.SetOfdSettings(*ofdSettings)
		}
	}()

	// 3. Получаем номер ФН и версию ФФД для клиента ОФД
	fnStatus, err := drv.GetFnStatus()
	if err != nil {
		return nil, fmt.Errorf("ошибка получения статуса ФН: %w", err)
	}
	fnSerial := fnStatus.Serial
	ffdVersion := fnStatus.Ffd

	// 4. Читаем документ из ККТ
	docData, err := drv.OfdReadFullDocument()
	if err != nil {
		return nil, fmt.Errorf("ошибка чтения документа: %w", err)
	}

	// 5. Отправка в ОФД с использованием нового клиента
	client := ofdclient.New(ofdclient.Config{
		Timeout:       300 * time.Second,
		RetryCount:    3,
		RetryInterval: 5 * time.Second,
	})
	defer client.Close()

	// Формируем запрос
	req := ofdclient.SendRequest{
		OfdAddress: fmt.Sprintf("%s:%d", ofdSettings.Addr, ofdSettings.Port),
		FnNumber:   fnSerial,
		FFDVersion: ffdVersion,
		Container:  docData,
	}

	// Отправляем документ
	ctx, cancel := context.WithTimeout(context.Background(), 300*time.Second)
	defer cancel()

	resp, err := client.Send(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("ошибка отправки в ОФД: %w", err)
	}

	// 6. Записываем квитанцию в ФН
	if err := drv.OfdLoadReceipt(resp.Receipt); err != nil {
		return nil, fmt.Errorf("ошибка записи квитанции: %w", err)
	}

	result.Success = true
	result.DocumentsSent = 1
	result.ErrorMessage = fmt.Sprintf(
		"Документ успешно отправлен в ОФД.\nФН: %s\nКвитанция: %d байт",
		fnSerial, len(resp.Receipt))

	return result, nil
}

// RefreshFnInfo обновляет информацию о ФН в модели регистрации
func RefreshFnInfo(drv driver.Driver) error {
	if drv == nil {
		return fmt.Errorf("нет подключения к ККТ")
	}

	fnStatus, err := drv.GetFnStatus()
	if err != nil {
		return fmt.Errorf("ошибка чтения статуса ФН: %w", err)
	}

	// Обновляем модель
	regModel.FnNumber = fnStatus.Serial
	regModel.FnValidDate = fnStatus.Valid
	regModel.FnPhase = fnStatus.Phase

	phaseText, phaseColor := decodeFnPhase(fnStatus.Phase)
	regModel.FnPhaseText = phaseText
	regModel.FnPhaseColor = phaseColor

	// Обновляем UI
	if regBinder != nil {
		regBinder.Reset()
	}
	if fnPhaseLabel != nil {
		fnPhaseLabel.SetTextColor(phaseColor)
	}

	return nil
}
</file>

<file path="gui\tab_main.go">
package gui

import (
	"fmt"
	"log"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/lxn/walk"
	d "github.com/lxn/walk/declarative"
	"go.bug.st/serial"

	"mitsuscanner/driver"
)

// Global state
var (
	mw      *walk.MainWindow
	logView *walk.TextEdit

	// Элементы управления
	addrCombo        *walk.ComboBox   // Строка подключения (Умный комбобокс)
	actionBtn        *walk.PushButton // Кнопка действия (Искать/Подкл/Откл)
	clearProfilesBtn *walk.PushButton // Кнопка очистки профилей

	// Панель информации о ККТ (появляется после подключения)
	kktInfoComposite *walk.Composite // Контейнер для инфо
	modelLabel       *walk.Label     // Модель
	serialLabel      *walk.Label     // Серийный номер
	unsentDocsLabel  *walk.Label     // Неотправленные документы
	rebootIndicator  *walk.Label     // Индикатор перезагрузки (Цветная точка)

	// Элементы вкладки "Информация"
	infoView *walk.TextEdit // Текстовое поле для инфо

	// Элементы лога
	logGroupBox      *walk.GroupBox
	collapsedLogComp *walk.Composite
	logPreviewLabel  *walk.Label
	isLogExpanded    bool = true
)

// SetMainWindow позволяет установить главное окно извне (для debug режима).
func SetMainWindow(w *walk.MainWindow) {
	mw = w
}

const (
	itemSearchLAN = "Поиск в сети / Ввести IP..."
	defaultPort   = 8200
	defaultBaud   = 115200
)

func RunApp() error {
	// Загружаем профили подключений перед формированием UI
	if err := LoadProfiles(); err != nil {
		log.Printf("[GUI] Ошибка загрузки профилей при старте: %v", err)
	}

	mw = new(walk.MainWindow)
	err := d.MainWindow{
		AssignTo: &mw,
		Title:    "Mitsu Driver Utility",
		// Фиксируем размер окна (600x600)
		Size:    d.Size{Width: 400, Height: 600},
		MinSize: d.Size{Width: 400, Height: 600},
		MaxSize: d.Size{Width: 400, Height: 600},
		Layout:  d.VBox{MarginsZero: true, Spacing: 5},
		Children: []d.Widget{
			// --- Верхняя панель (Подключение + Инфо) ---
			d.GroupBox{
				Layout: d.HBox{Margins: d.Margins{Left: 5, Top: 5, Right: 5, Bottom: 5}, Spacing: 10},
				Children: []d.Widget{

					// ЛЕВАЯ ЧАСТЬ: Управление подключением
					d.Composite{
						Layout: d.HBox{MarginsZero: true, Spacing: 5},
						Children: []d.Widget{
							d.ComboBox{
								AssignTo:              &addrCombo,
								Editable:              true,
								Model:                 getInitialDeviceList(),
								CurrentIndex:          0,
								OnCurrentIndexChanged: onDeviceSelectionChanged,
								OnTextChanged:         onDeviceTextChanged,
								MinSize:               d.Size{Width: 220, Height: 0},
								ToolTipText:           "Введите COMx:Baud или IP:Port. Примеры: COM9:115200, 192.168.1.50:8200",
							},
							d.PushButton{
								AssignTo:  &actionBtn,
								Text:      "Подключить",
								OnClicked: onActionBtnClicked,
								MinSize:   d.Size{Width: 80},
							},
							d.PushButton{
								AssignTo:    &clearProfilesBtn,
								Text:        "🗑️",
								MaxSize:     d.Size{Width: 30},
								ToolTipText: "Очистить сохранённые профили",
								OnClicked:   onClearProfiles,
							},
						},
					},

					// РАЗДЕЛИТЕЛЬ
					// d.VSeparator{},

					// ПРАВАЯ ЧАСТЬ: Инфо о ККТ (Model, SN, Reboot status)
					d.Composite{
						AssignTo: &kktInfoComposite,
						Visible:  false, // Скрыт до подключения
						Layout:   d.HBox{MarginsZero: true, Spacing: 8, Alignment: d.AlignHNearVCenter},
						Children: []d.Widget{
							d.Label{AssignTo: &modelLabel, Text: "Mitsu", Font: d.Font{Bold: true}},
							d.Label{AssignTo: &serialLabel, Text: "SN: ..."},
							d.Label{AssignTo: &unsentDocsLabel, Text: "ОФД: 0"},
							d.Label{Text: "|"},
							d.Label{
								AssignTo:    &rebootIndicator,
								Text:        "⦿", // Кружок
								Font:        d.Font{PointSize: 14, Bold: true},
								TextColor:   walk.RGB(0, 200, 0), // Зеленый
								ToolTipText: "Зеленый: Норма (Флаг=1)\nКрасный: Был сбой питания (Флаг=0)",
							},
						},
					},
					// Растяжка, чтобы прижать всё влево
					d.HSpacer{},
				},
			},

			// --- Вкладки ---
			d.TabWidget{
				Pages: []d.TabPage{
					// 1. Информация
					{
						Title:  "Информация",
						Layout: d.VBox{Margins: d.Margins{Left: 6, Top: 6, Right: 6, Bottom: 6}, Spacing: 5},
						Children: []d.Widget{
							d.PushButton{Text: "Обновить данные", OnClicked: refreshInfo},
							d.TextEdit{
								AssignTo: &infoView,
								ReadOnly: true,
								VScroll:  true,
								Font:     d.Font{Family: "Consolas", PointSize: 9},
							},
							// Панель операционных кнопок
							d.Composite{
								Layout: d.HBox{Alignment: d.AlignHCenterVCenter},
								Children: []d.Widget{
									d.Composite{
										Layout: d.Grid{Columns: 4, Spacing: 10},
										Children: []d.Widget{
											d.PushButton{Text: "X-Отчет", OnClicked: onPrintX, MinSize: d.Size{Width: 120}},
											d.PushButton{Text: "Копия док.", OnClicked: onPrintCopy, MinSize: d.Size{Width: 120}},
											d.PushButton{Text: "Z-Отчет", OnClicked: onPrintZ, MinSize: d.Size{Width: 120}},
											d.PushButton{Text: "Прогон/Отрезка", OnClicked: onFeedAndCut, MinSize: d.Size{Width: 120}},
										},
									},
								},
							},
						},
					},
					// 2. Регистрация
					GetRegistrationTab(),
					// 3. Сервис
					GetServiceTab(),
				},
			},

			// --- Лог (Сворачиваемый) ---
			d.Composite{
				Layout: d.VBox{MarginsZero: true},
				Children: []d.Widget{
					// Развернутый вид
					d.GroupBox{
						AssignTo: &logGroupBox,
						Title:    "Лог",
						Layout:   d.VBox{MarginsZero: true},
						MinSize:  d.Size{Height: 150},
						MaxSize:  d.Size{Height: 200},
						Children: []d.Widget{
							d.Composite{
								Layout: d.HBox{MarginsZero: true},
								Children: []d.Widget{
									d.HSpacer{},
									d.PushButton{Text: "🔽 Свернуть", OnClicked: toggleLog, MaxSize: d.Size{Width: 80}},
								},
							},
							d.TextEdit{
								AssignTo: &logView,
								ReadOnly: true,
								VScroll:  true,
								HScroll:  true,
							},
						},
					},
					// Свернутый вид
					d.Composite{
						AssignTo: &collapsedLogComp,
						Visible:  false, // Скрыт по умолчанию
						Layout:   d.HBox{Margins: d.Margins{Left: 5, Top: 2, Right: 5, Bottom: 2}},
						Children: []d.Widget{
							d.PushButton{Text: "🔼 Лог", OnClicked: toggleLog, MaxSize: d.Size{Width: 60}},
							// ИЗМЕНЕНО: Добавлен EllipsisMode и MaxSize для предотвращения растягивания
							d.Label{
								AssignTo:      &logPreviewLabel,
								Text:          "...",
								TextAlignment: d.AlignNear,
								EllipsisMode:  d.EllipsisEnd,      // Обрезать текст с конца "..."
								MaxSize:       d.Size{Width: 500}, // Жесткий лимит ширины (600 - кнопка - отступы)
							},
						},
					},
				},
			},
		},
	}.Create()

	if err != nil {
		return err
	}

	// Автовыбор первого профиля при старте
	if addrCombo.Model() != nil {
		onDeviceSelectionChanged()
	}

	mw.Closing().Attach(func(canceled *bool, reason walk.CloseReason) {
		if driver.Active != nil {
			_ = driver.Active.Disconnect()
			driver.Active = nil
		}
	})

	mw.Run()
	return nil
}

// toggleLog переключает видимость лога
func toggleLog() {
	isLogExpanded = !isLogExpanded

	mw.SetSuspended(true)
	defer mw.SetSuspended(false)

	if isLogExpanded {
		logGroupBox.SetVisible(true)
		collapsedLogComp.SetVisible(false)
	} else {
		logGroupBox.SetVisible(false)
		collapsedLogComp.SetVisible(true)
	}
}

// --- Логика UI ---

// getInitialDeviceList формирует список
func getInitialDeviceList() []string {
	var items []string

	// 1. Профили
	profiles := GetProfiles()
	for _, p := range profiles {
		items = append(items, p.DisplayString())
	}

	// 2. COM-порты (чистые)
	ports, _ := serial.GetPortsList()
	sort.Strings(ports)
	for _, port := range ports {
		if !isPortInProfiles(port, profiles) {
			items = append(items, port) // Просто COMx, без скорости
		}
	}

	// 3. Поиск
	items = append(items, itemSearchLAN)

	return items
}

func isPortInProfiles(port string, profiles []*ConnectionProfile) bool {
	for _, p := range profiles {
		if p.ConnectionType == 0 && p.ComName == port {
			return true
		}
	}
	return false
}

func refreshDeviceList() {
	mw.Synchronize(func() {
		addrCombo.SetModel(getInitialDeviceList())
		if addrCombo.CurrentIndex() < 0 && len(getInitialDeviceList()) > 0 {
			addrCombo.SetCurrentIndex(0)
		}
	})
}

// onConnectSuccess - действия после успешного соединения
func onConnectSuccess(drv driver.Driver, cfg driver.Config) {
	logMsg("[SYSTEM] Подключение установлено. Чтение информации...")

	// 1. Читаем статику (Модель, Версия, SN)
	model, _ := drv.GetModel()
	ver, serial, _, _ := drv.GetVersion()
	shiftStatus, _ := drv.GetShiftStatus()

	unsent := 0
	if shiftStatus != nil {
		unsent = shiftStatus.Ofd.Count
	}

	logMsg("[INFO] %s, SN: %s, FW: %s", model, serial, ver)

	// 2. Сохраняем профиль
	profile := &ConnectionProfile{
		SerialNumber:   serial,
		ConnectionType: int(cfg.ConnectionType),
		ComName:        cfg.ComName,
		BaudRate:       int(cfg.BaudRate),
		IPAddress:      cfg.IPAddress,
		TCPPort:        int(cfg.TCPPort),
		FirmwareVer:    ver,
		ModelName:      model,
		LastUsed:       time.Now(),
	}
	go func() {
		UpsertProfile(profile)
		mw.Synchronize(func() { refreshDeviceList() })
	}()

	// 3. УСТАНОВКА ФЛАГА ПИТАНИЯ
	// Устанавливаем 1 (TRUE), чтобы обозначить "Мы контролируем ситуацию".
	// Если ККТ перезагрузится, она (вероятно) сбросит флаг в 0.
	if err := drv.SetPowerFlag(1); err != nil {
		logMsg("[WARN] Не удалось установить флаг питания: %v", err)
	} else {
		// Не пишем в лог, чтобы не шуметь, или пишем только в DEBUG
		// logMsg("[SYSTEM] Флаг питания установлен (1).")
	}

	// 4. Запускаем мониторинг (передаем статику)
	StartMonitor(drv, model, serial, unsent)
	SetUpdateCallback(updateKktInfoPanel)

	// 5. Показываем панель
	mw.Synchronize(func() {
		// Первичное заполнение лейблов
		modelLabel.SetText(model)
		serialLabel.SetText("SN: " + serial)
		unsentDocsLabel.SetText(fmt.Sprintf("ОФД: %d", unsent))
		rebootIndicator.SetTextColor(walk.RGB(0, 200, 0)) // Зеленый по умолчанию при успехе
		kktInfoComposite.SetVisible(true)
	})
}

func updateKktInfoPanel(status *KktPanelStatus) {
	mw.Synchronize(func() {
		// Обновляем только индикатор перезагрузки
		// ЛОГИКА:
		// PowerFlag == true (1) -> НОРМА (мы его сами поставили)
		// PowerFlag == false (0) -> СБОЙ (устройство сбросилось)

		if status.PowerFlag {
			// НОРМА
			rebootIndicator.SetText("⦿")
			rebootIndicator.SetTextColor(walk.RGB(0, 200, 0)) // Зеленый
			rebootIndicator.SetToolTipText("Питание в норме")
		} else {
			// СБОЙ / ПЕРЕЗАГРУЗКА
			rebootIndicator.SetText("○")
			rebootIndicator.SetTextColor(walk.RGB(255, 0, 0)) // Красный
			rebootIndicator.SetToolTipText("ВНИМАНИЕ: Произошла перезагрузка ККТ!")
		}
	})
}

func onDeviceSelectionChanged() {
	if driver.Active != nil {
		return
	}
	updateUIState()
}

func onDeviceTextChanged() {
	updateUIState()
}

func onClearProfiles() {
	if walk.MsgBox(mw, "Подтверждение", "Очистить все профили?", walk.MsgBoxYesNo|walk.MsgBoxIconQuestion) != walk.DlgCmdYes {
		return
	}

	actionBtn.SetEnabled(false)
	go func() {
		err := ClearProfiles()
		mw.Synchronize(func() {
			if err != nil {
				walk.MsgBox(mw, "Ошибка", err.Error(), walk.MsgBoxIconError)
			} else {
				logMsg("Профили очищены.")
				refreshDeviceList()
			}
			updateUIState()
		})
	}()
}

func updateUIState() {
	if driver.Active != nil {
		actionBtn.SetText("Отключить")
		actionBtn.SetEnabled(true)
		addrCombo.SetEnabled(false)
		return
	}

	addrCombo.SetEnabled(true)
	text := strings.TrimSpace(addrCombo.Text())

	if text == "" || text == itemSearchLAN {
		actionBtn.SetText("Искать")
		actionBtn.SetEnabled(true)
		return
	}

	actionBtn.SetText("Подключить")
	actionBtn.SetEnabled(true)
}

// parseConnectionString разбирает "HOST:PORT" или "COMx:BAUD"
func parseConnectionString(input string) (host string, port int, isCom bool) {
	input = strings.TrimSpace(input)
	isCom = strings.HasPrefix(strings.ToUpper(input), "COM")

	// Если есть двоеточие - пытаемся разбить
	if strings.Contains(input, ":") {
		parts := strings.Split(input, ":")
		host = parts[0]
		if len(parts) > 1 {
			if p, err := strconv.Atoi(parts[1]); err == nil {
				port = p
			}
		}
	} else {
		host = input
	}

	// Дефолты если порт не указан (или 0)
	if port == 0 {
		if isCom {
			port = defaultBaud
		} else {
			port = defaultPort
		}
	}

	return host, port, isCom
}

// extractSNFromProfileString извлекает "SN123456" из строки отображения
func extractSNFromProfileString(s string) string {
	// Формат: SN123456 - ...
	parts := strings.Split(s, " - ")
	if len(parts) > 0 {
		// Убираем префикс SN
		return strings.TrimPrefix(parts[0], "SN")
	}
	return ""
}

func onActionBtnClicked() {
	// 1. Отключение
	if driver.Active != nil {
		_ = driver.Active.Disconnect()
		driver.Active = nil
		StopMonitor()
		kktInfoComposite.SetVisible(false)
		updateUIState()
		logMsg("Отключено.")
		return
	}

	rawText := strings.TrimSpace(addrCombo.Text())

	// 2. Поиск
	if actionBtn.Text() == "Искать" {
		go runNetworkScan()
		return
	}

	// 3. Подключение
	cfg := driver.Config{
		Timeout: 3000,
		Logger:  func(s string) { logMsg(s) },
	}

	// СЦЕНАРИЙ А: Выбран профиль (строка начинается с SN...)
	if strings.HasPrefix(rawText, "SN") {
		sn := extractSNFromProfileString(rawText)
		profile := FindProfile(sn)
		if profile != nil {
			logMsg("Подключение по профилю: %s...", profile.SerialNumber)
			cfg.ConnectionType = int32(profile.ConnectionType)
			if cfg.ConnectionType == 0 {
				cfg.ComName = profile.ComName
				cfg.BaudRate = int32(profile.BaudRate)
			} else {
				cfg.IPAddress = profile.IPAddress
				cfg.TCPPort = int32(profile.TCPPort)
			}
		} else {
			// Если профиль не найден, пробуем парсить
			logMsg("[WARN] Профиль не найден, пробуем парсить строку...")
			h, p, isCom := parseConnectionString(rawText)
			if isCom {
				cfg.ConnectionType = 0
				cfg.ComName = h
				cfg.BaudRate = int32(p)
			} else {
				cfg.ConnectionType = 6
				cfg.IPAddress = h
				cfg.TCPPort = int32(p)
			}
		}
	} else {
		// СЦЕНАРИЙ Б: Ручной ввод
		h, p, isCom := parseConnectionString(rawText)
		if isCom {
			cfg.ConnectionType = 0
			cfg.ComName = h
			cfg.BaudRate = int32(p)
		} else {
			cfg.ConnectionType = 6
			cfg.IPAddress = h
			cfg.TCPPort = int32(p)
		}
	}

	logMsg("Соединение с %s...", getConnString(&cfg))
	setControlsEnabled(false)

	go func() {
		drv := driver.NewMitsuDriver(cfg)
		if err := drv.Connect(); err != nil {
			mw.Synchronize(func() {
				logMsg("ОШИБКА: %v", err)
				walk.MsgBox(mw, "Ошибка", fmt.Sprintf("Не удалось подключиться: %v", err), walk.MsgBoxIconError)
				setControlsEnabled(true)
				updateUIState()
			})
			return
		}

		mw.Synchronize(func() {
			driver.Active = drv
			updateUIState()
		})

		onConnectSuccess(drv, cfg)
		refreshInfo()
	}()
}

func setControlsEnabled(enabled bool) {
	addrCombo.SetEnabled(enabled)
	actionBtn.SetEnabled(enabled)
}

func getConnString(c *driver.Config) string {
	if c.ConnectionType == 0 {
		return fmt.Sprintf("%s:%d", c.ComName, c.BaudRate)
	}
	return fmt.Sprintf("%s:%d", c.IPAddress, c.TCPPort)
}

// --- Утилиты ---
func refreshInfo() {
	drv := driver.Active
	if drv == nil {
		return
	}
	mw.Synchronize(func() { infoView.SetText("Загрузка данных...") })

	go func() {
		info, err := drv.GetFiscalInfo()
		if err != nil {
			mw.Synchronize(func() {
				infoView.SetText(fmt.Sprintf("ОШИБКА ПОЛУЧЕНИЯ ДАННЫХ:\r\n%v", err))
			})
			return
		}

		type kv struct {
			k, v string
		}
		var lines []kv

		lines = append(lines, kv{"Модель ККТ", info.ModelName})
		lines = append(lines, kv{"Заводской номер", info.SerialNumber})
		lines = append(lines, kv{"Версия прошивки", info.SoftwareDate})
		lines = append(lines, kv{"РНМ", info.RNM})
		lines = append(lines, kv{"ИНН организации", info.Inn})
		lines = append(lines, kv{"Организация", info.OrganizationName})
		lines = append(lines, kv{"ОФД", info.OfdName})
		lines = append(lines, kv{"Дата регистрации", info.RegistrationDate})
		lines = append(lines, kv{"Версия ФФД", info.FfdVersion})
		lines = append(lines, kv{"Срок действия ФН", info.FnEndDate})
		lines = append(lines, kv{"Исполнение ФН", info.FnEdition})

		sh, err := drv.GetShiftStatus()
		if err == nil {
			st := "Закрыта"
			if sh.State == "1" {
				st = "Открыта"
			}
			lines = append(lines, kv{"Смена", fmt.Sprintf("№%d (%s)", sh.ShiftNum, st)})
			ofdInfo := fmt.Sprintf("%d", sh.Ofd.Count)
			if sh.Ofd.Count > 0 {
				ofdInfo += fmt.Sprintf(" (Первый: №%d от %s %s)", sh.Ofd.First, sh.Ofd.Date, sh.Ofd.Time)
			}
			lines = append(lines, kv{"Неотправленных ФД", ofdInfo})

		} else {
			lines = append(lines, kv{"Смена", "Ошибка получения статуса"})
		}

		var sb strings.Builder
		maxKeyLen := 0
		for _, item := range lines {
			if len(item.k) > maxKeyLen {
				maxKeyLen = len(item.k)
			}
		}
		maxKeyLen += 2

		for _, item := range lines {
			format := fmt.Sprintf("%%-%ds : %%s\r\n", maxKeyLen)
			sb.WriteString(fmt.Sprintf(format, item.k, item.v))
		}

		mw.Synchronize(func() {
			infoView.SetText(sb.String())
		})
	}()
}

func onPrintX() {
	if driver.Active != nil {
		go func() {
			if err := driver.Active.PrintXReport(); err != nil {
				logMsg("Error X: %v", err)
			}
		}()
	}
}
func onPrintZ() {
	if driver.Active != nil {
		if walk.MsgBox(mw, "Подтверждение", "Закрыть смену?", walk.MsgBoxYesNo) == walk.DlgCmdYes {
			go func() {
				driver.Active.CloseShift("Admin")
				time.Sleep(500 * time.Millisecond)
				driver.Active.PrintLastDocument()
				refreshInfo()
			}()
		}
	}
}
func onPrintCopy() {
	if driver.Active != nil {
		go driver.Active.PrintLastDocument()
	}
}
func onFeedAndCut() {
	if driver.Active != nil {
		go func() {
			driver.Active.Feed(5)
			driver.Active.Cut()
		}()
	}
}

func logMsg(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	timestamp := time.Now().Format("15:04:05.000")
	fullMsg := fmt.Sprintf("[%s] %s\r\n", timestamp, msg)

	if mw != nil {
		mw.Synchronize(func() {
			// Обновляем основной лог
			if logView != nil {
				logView.AppendText(fullMsg)
			}
			// Обновляем превью для свернутого состояния
			if logPreviewLabel != nil {
				logPreviewLabel.SetText(fmt.Sprintf("[%s] %s", timestamp, msg))
			}
		})
	} else {
		log.Print(fullMsg)
	}
}
</file>

<file path="gui\tab_registration.go">
package gui

import (
	"fmt"
	"html"
	"mitsuscanner/driver"
	"regexp"
	"strconv"
	"strings"

	"github.com/lxn/walk"
	d "github.com/lxn/walk/declarative"
)

// hasBit проверяет, установлен ли бит в целом числе
func hasBit(value int, bit int) bool {
	return (value & (1 << bit)) != 0
}

// RegViewModel - модель данных для формы регистрации
type RegViewModel struct {
	RNM           string
	INN           string
	OrgName       string
	Address       string
	Place         string
	Email         string
	Site          string
	AutomatNumber string
	FFD           string
	Reasons       string

	OFDName string
	OFDINN  string

	// d.CheckBoxes (Settings)
	ModeAutonomous bool
	ModeEncryption bool
	ModeService    bool
	ModeInternet   bool
	ModeAutomat    bool
	ModeBSO        bool
	ModeExcise     bool
	ModeGambling   bool
	ModeLottery    bool
	ModeMarking    bool
	ModePawn       bool
	ModeInsurance  bool
	ModeCatering   bool
	ModeWholesale  bool
	ModeVending    bool

	// SNO (Taxation)
	TaxOSN        bool // 0
	TaxUSN        bool // 1
	TaxUSN_M      bool // 2
	TaxENVD       bool // 3
	TaxESHN       bool // 4
	TaxPat        bool // 5
	TaxSystemBase string

	// Информация о ФН
	FnNumber     string
	FnPhase      string
	FnPhaseText  string
	FnPhaseColor walk.Color
	FnValidDate  string
}

var regModel *RegViewModel
var regBinder *walk.DataBinder
var fnPhaseLabel *walk.Label

// decodeFnPhase возвращает текст и цвет для фазы ФН.
// PHASE: 0x01=Готов к фискализации (Синий), 0x03=Боевой режим (Зелёный),
// 0x07=ФН закрыт, отчёт не отправлен (Красный), 0x0F=ФР в архиве (Синий)
func decodeFnPhase(phase string) (text string, color walk.Color) {
	phase = strings.TrimPrefix(strings.ToLower(phase), "0x")
	val, err := strconv.ParseInt(phase, 16, 32)
	if err != nil {
		return "Неизвестно", walk.RGB(0, 0, 0) // Чёрный по умолчанию
	}

	switch val {
	case 0x01:
		return "Готов к фискализации", walk.RGB(0, 0, 255) // Синий
	case 0x03:
		return "Боевой режим", walk.RGB(0, 128, 0) // Зелёный
	case 0x07:
		return "ФН закрыт", walk.RGB(255, 0, 0) // Красный
	case 0x0F:
		return "ФР в архиве", walk.RGB(0, 0, 255) // Синий
	default:
		return fmt.Sprintf("Неизвестная фаза (%s)", phase), walk.RGB(128, 128, 128)
	}
}

// GetRegistrationTab возвращает описание вкладки "Регистрация"
func GetRegistrationTab() d.TabPage {
	regModel = &RegViewModel{} // Default

	return d.TabPage{
		Title:  "Регистрация",
		Layout: d.VBox{Margins: d.Margins{Left: 2, Top: 2, Right: 2, Bottom: 2}, Spacing: 3},
		Children: []d.Widget{
			// Верхняя панель
			d.Composite{
				Layout: d.Grid{Columns: 3, Margins: d.Margins{Left: 2, Top: 2, Right: 2, Bottom: 2}, Spacing: 3},
				Children: []d.Widget{
					d.Label{Text: "Регистрационный номер ККТ (РНМ):"},
					d.LineEdit{Text: d.Bind("RNM"), MinSize: d.Size{Width: 150}},
					d.PushButton{Text: "Вычислить (CRC)", OnClicked: onCalcRNM},
				},
			},

			// Основной контент
			d.Composite{
				Layout: d.VBox{Margins: d.Margins{Left: 2, Top: 2, Right: 2, Bottom: 2}, Spacing: 3},
				Children: []d.Widget{
					d.Composite{
						// Используем HBox для расположения блоков по горизонтали
						// Alignment: AlignTop прижмет маленький блок к верху
						Layout: d.HBox{Margins: d.Margins{Left: 2, Top: 2, Right: 2, Bottom: 2}, Spacing: 3, Alignment: d.Alignment2D(d.AlignDefault)},
						Children: []d.Widget{
							d.GroupBox{
								Title: "Реквизиты организации",
								// StretchFactor: 3 означает, что этот блок будет занимать ~75% ширины (3 части)
								// StretchFactor: 3,
								Layout: d.Grid{Columns: 2, Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 5},
								Children: []d.Widget{
									d.Label{Text: "Наименование:"},
									d.LineEdit{Text: d.Bind("OrgName")},
									d.Label{Text: "ИНН:"},
									d.LineEdit{Text: d.Bind("INN")},
									d.Label{Text: "Адрес расчетов:"},
									d.LineEdit{Text: d.Bind("Address")},
									d.Label{Text: "Место расчетов:"},
									d.LineEdit{Text: d.Bind("Place")},
									d.Label{Text: "E-mail отправителя:"},
									d.LineEdit{Text: d.Bind("Email")},
									d.Label{Text: "Сайт ФНС:"},
									d.LineEdit{Text: d.Bind("Site")},
								},
							},
							d.GroupBox{
								Title: "Системы налогообложения",
								// StretchFactor: 1 означает, что этот блок будет занимать ~25% ширины (1 часть)
								// StretchFactor: 1,
								// MinSize можно задать, чтобы чекбоксы не сплющивались, если окно сузят
								MinSize: d.Size{Width: 150},
								Layout:  d.VBox{Margins: d.Margins{Left: 3, Top: 1, Right: 3, Bottom: 1}, Spacing: 1},
								Children: []d.Widget{
									d.CheckBox{Text: "ОСН", Checked: d.Bind("TaxOSN"), Alignment: d.Alignment2D(d.AlignNear)},
									d.CheckBox{Text: "УСН доход", Checked: d.Bind("TaxUSN"), Alignment: d.Alignment2D(d.AlignNear)},
									d.CheckBox{Text: "УСН доход - расход", Checked: d.Bind("TaxUSN_M"), Alignment: d.Alignment2D(d.AlignNear)},
									d.CheckBox{Text: "ЕСХН", Checked: d.Bind("TaxESHN"), Alignment: d.Alignment2D(d.AlignNear)},
									d.CheckBox{Text: "Патент", Checked: d.Bind("TaxPat"), Alignment: d.Alignment2D(d.AlignNear)},
									d.Label{Text: "СНО по умолчанию:", Font: d.Font{PointSize: 7}},
									d.ComboBox{
										Value:         d.Bind("TaxSystemBase"),
										BindingMember: "Code",
										DisplayMember: "Name",
										Model: []*NV{
											{Name: "", Code: ""},
											{Name: "ОСН", Code: "0"},
											{Name: "УСН доход", Code: "1"},
											{Name: "УСН доход - расход", Code: "2"},
											{Name: "ЕСХН", Code: "4"},
											{Name: "Патент", Code: "5"},
										},
									},
								},
							},
						},
					},
					d.Composite{
						Layout: d.HBox{Margins: d.Margins{Left: 3, Top: 1, Right: 3, Bottom: 1}, Spacing: 5},
						Children: []d.Widget{
							d.GroupBox{
								Title:  "Фискальные признаки",
								Layout: d.Grid{Columns: 3, Margins: d.Margins{Left: 3, Top: 1, Right: 3, Bottom: 1}, Spacing: 1},
								Children: []d.Widget{
									// Колонка 1
									d.CheckBox{Text: "Автономный режим", Checked: d.Bind("ModeAutonomous")},
									d.CheckBox{Text: "Шифрование данных", Checked: d.Bind("ModeEncryption")},
									d.CheckBox{Text: "Расчеты за услуги", Checked: d.Bind("ModeService")},
									d.CheckBox{Text: "Расчеты в Интернет", Checked: d.Bind("ModeInternet")},
									d.CheckBox{Text: "Принтер в автомате", Checked: d.Bind("ModeAutomat")},
									// Колонка 2
									d.CheckBox{Text: "Только БСО", Checked: d.Bind("ModeBSO")},
									d.CheckBox{Text: "Подакцизные товары", Checked: d.Bind("ModeExcise")},
									d.CheckBox{Text: "Проведение азартных игр", Checked: d.Bind("ModeGambling")},
									d.CheckBox{Text: "Проведение лотерей", Checked: d.Bind("ModeLottery")},
									d.CheckBox{Text: "Маркированные товары", Checked: d.Bind("ModeMarking")},
									// Колонка 3
									d.CheckBox{Text: "Ломбард", Checked: d.Bind("ModePawn")},
									d.CheckBox{Text: "Страхование", Checked: d.Bind("ModeInsurance")},
									d.CheckBox{Text: "Общепит", Checked: d.Bind("ModeCatering")},
									d.CheckBox{Text: "Оптовая торговля", Checked: d.Bind("ModeWholesale")},
									d.CheckBox{Text: "Вендинг", Checked: d.Bind("ModeVending")},
								},
							},
							d.GroupBox{
								Title:   "Информация о ФН",
								Layout:  d.VBox{MarginsZero: true, Spacing: 3},
								MinSize: d.Size{Width: 200},
								Children: []d.Widget{
									// Информационные поля
									d.Composite{
										Layout: d.Grid{Columns: 2, Spacing: 5},
										Children: []d.Widget{
											d.Label{Text: "№:"},
											d.Label{Text: d.Bind("FnNumber"), Font: d.Font{Bold: true}},
											d.Label{Text: "Фаза:"},
											d.Label{AssignTo: &fnPhaseLabel, Text: d.Bind("FnPhaseText")},
											d.Label{Text: "До:"},
											d.Label{Text: d.Bind("FnValidDate"), Font: d.Font{Bold: true}},
										},
									},
									// Кнопки управления
									d.Composite{
										Layout: d.HBox{MarginsZero: true, Spacing: 5, Alignment: d.AlignHCenterVCenter},
										Children: []d.Widget{
											d.PushButton{
												Text:        "Отправить в ОФД",
												OnClicked:   onSendToOfd,
												MinSize:     d.Size{Width: 110},
												ToolTipText: "Отправить первый неотправленный документ в ОФД",
											},
											d.PushButton{
												Text:        "↻", // Unicode символ обновления
												OnClicked:   onRefreshFnInfo,
												MaxSize:     d.Size{Width: 30, Height: 30},
												ToolTipText: "Обновить информацию о ФН",
											},
										},
									},
								},
							},
						},
					},
				},
			},

			// --- 3. Блок: Причины (слева) + ОФД (справа) ---
			d.Composite{
				// Выравнивание по верху, чтобы блоки не разъезжались по высоте
				Layout: d.HBox{Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 10, Alignment: d.Alignment2D(d.AlignNear)},
				Children: []d.Widget{

					// ПРАВАЯ ЧАСТЬ: ОФД
					d.GroupBox{
						Title:         "Оператор фискальных данных",
						StretchFactor: 2, // Занимает 2 части ширины (шире, чем причины)
						Layout:        d.VBox{Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 5},
						Children: []d.Widget{
							d.Composite{
								Layout: d.HBox{Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 5},
								Children: []d.Widget{
									d.Label{Text: "ИНН ОФД:", TextAlignment: d.AlignFar},
									d.LineEdit{Text: d.Bind("OFDINN")},
								},
							},
							d.Composite{
								Layout: d.HBox{Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 5},
								Children: []d.Widget{
									d.Label{Text: "Наименование ОФД:", TextAlignment: d.AlignFar},
									d.LineEdit{Text: d.Bind("OFDName")},
								},
							},
						},
					},

					// ЛЕВАЯ ЧАСТЬ: Причины перерегистрации
					d.GroupBox{
						Title:         "Причины перерегистрации",
						StretchFactor: 1, // Занимает 1 часть ширины
						Layout:        d.VBox{Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 10},
						Children: []d.Widget{
							// Поле ввода кодов
							d.LineEdit{Text: d.Bind("Reasons"), ReadOnly: true},

							// Контейнер для центрирования кнопки
							d.Composite{
								Layout: d.HBox{MarginsZero: true, Alignment: d.AlignHCenterVCenter},
								Children: []d.Widget{
									d.PushButton{
										Text:      "Выбрать...",
										OnClicked: onSelectReasons,
										MinSize:   d.Size{Width: 100}, // Фиксируем размер кнопки
										MaxSize:   d.Size{Width: 100},
									},
								},
							},
						},
					},
				},
			},

			// Кнопки
			d.Composite{
				Layout: d.HBox{Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 5},
				Children: []d.Widget{
					d.PushButton{Text: "Считать из ККТ", OnClicked: onReadRegistration},
					d.HSpacer{},
					d.PushButton{Text: "Закрытие ФН", OnClicked: onCloseFn},
					d.PushButton{Text: "Замена ФН", OnClicked: onReplaceFn},
					d.PushButton{Text: "Перерегистрация", OnClicked: onReregister},
					d.PushButton{Text: "Регистрация", OnClicked: onRegister},
				},
			},
		},
		DataBinder: d.DataBinder{
			AssignTo:       &regBinder,
			DataSource:     regModel,
			ErrorPresenter: d.ToolTipErrorPresenter{},
		},
	}
}

// --- Обработчики событий ---

// onCalcRNM открывает диалог генерации РНМ
func onCalcRNM() {
	// Сначала забираем данные из формы в модель
	if err := regBinder.Submit(); err != nil {
		return
	}

	inn := strings.TrimSpace(regModel.INN)
	if len(inn) != 10 && len(inn) != 12 {
		walk.MsgBox(mw, "Ошибка", "Для расчета РНМ заполните корректный ИНН пользователя (10 или 12 цифр).", walk.MsgBoxIconError)
		return
	}

	// Пытаемся получить заводской номер из драйвера
	serial := ""
	if driver.Active != nil {
		info, err := driver.Active.GetFiscalInfo()
		if err == nil && info != nil {
			serial = info.SerialNumber
		}
	}

	// Запускаем диалог
	runRnmGenerationDialog(inn, serial)
}

func onReadRegistration() {
	drv := driver.Active
	if drv == nil {
		walk.MsgBox(mw, "Ошибка", "Нет подключения к ККТ", walk.MsgBoxIconError)
		return
	}

	go func() {
		regData, err := drv.GetRegistrationData()
		if err != nil {
			mw.Synchronize(func() { walk.MsgBox(mw, "Ошибка", err.Error(), walk.MsgBoxIconError) })
			return
		}

		fnStatus, fnErr := drv.GetFnStatus()

		mw.Synchronize(func() {

			regModel.RNM = regData.RNM
			regModel.INN = regData.Inn
			regModel.OrgName = regData.OrgName
			regModel.Address = regData.Address
			regModel.Place = regData.Place
			regModel.Email = regData.EmailSender
			regModel.Site = regData.Site
			regModel.OFDINN = regData.OfdInn
			regModel.OFDName = html.UnescapeString(regData.OfdName)

			// --- Парсинг атрибутов режимов работы ---

			// Парсинг MODE и ExtMODE с использованием hasBit
			modeInt := int(regData.ModeMask)
			extModeInt := int(regData.ExtModeMask)

			regModel.ModeEncryption = hasBit(modeInt, 0) // Шифрование
			regModel.ModeAutonomous = hasBit(modeInt, 1) // Автономный режим
			regModel.ModeService = hasBit(modeInt, 3)    // Услуги
			regModel.ModeBSO = hasBit(modeInt, 4)        // БСО
			regModel.ModeInternet = hasBit(modeInt, 5)   // Интернет
			regModel.ModeCatering = hasBit(modeInt, 6)   // Общепит
			regModel.ModeWholesale = hasBit(modeInt, 7)  // Опт

			regModel.ModeExcise = hasBit(extModeInt, 0)    // Подакцизные
			regModel.ModeGambling = hasBit(extModeInt, 1)  // Азартные
			regModel.ModeLottery = hasBit(extModeInt, 2)   // Лотереи
			regModel.ModeAutomat = hasBit(extModeInt, 3)   // Принтер в автомате
			regModel.ModeMarking = hasBit(extModeInt, 4)   // Маркированные товары
			regModel.ModePawn = hasBit(extModeInt, 5)      // Ломбард
			regModel.ModeInsurance = hasBit(extModeInt, 6) // Страхование
			regModel.ModeVending = hasBit(extModeInt, 7)   // Вендинг

			// Парсинг СНО
			regModel.TaxOSN = false
			regModel.TaxUSN = false
			regModel.TaxUSN_M = false
			regModel.TaxENVD = false
			regModel.TaxESHN = false
			regModel.TaxPat = false

			taxParts := strings.Split(regData.TaxSystems, ",")
			for _, t := range taxParts {
				trimmedT := strings.TrimSpace(t)
				switch trimmedT {
				case "0":
					regModel.TaxOSN = true
				case "1":
					regModel.TaxUSN = true
				case "2":
					regModel.TaxUSN_M = true
				case "3":
					regModel.TaxENVD = true
				case "4":
					regModel.TaxESHN = true
				case "5":
					regModel.TaxPat = true
				}
			}

			// Установка TaxSystemBase на первую зарегистрированную СНО по умолчанию
			regModel.TaxSystemBase = regData.TaxBase

			if err := regBinder.Reset(); err != nil {
				walk.MsgBox(mw, "Ошибка биндинга", fmt.Sprintf("Ошибка обновления UI: %v", err), walk.MsgBoxIconError)
			}

			// Читаем информацию о ФН
			if fnErr == nil {
				regModel.FnNumber = fnStatus.Serial
				regModel.FnValidDate = fnStatus.Valid
				regModel.FnPhase = fnStatus.Phase

				// Декодируем фазу
				phaseText, phaseColor := decodeFnPhase(fnStatus.Phase)
				regModel.FnPhaseText = phaseText
				regModel.FnPhaseColor = phaseColor
			} else {
				regModel.FnNumber = "Ошибка чтения"
				regModel.FnPhaseText = "—"
				regModel.FnValidDate = "—"
			}

			if err := regBinder.Reset(); err != nil {
				walk.MsgBox(mw, "Ошибка биндинга", fmt.Sprintf("Ошибка обновления UI: %v", err), walk.MsgBoxIconError)
			}

			if fnErr == nil && fnPhaseLabel != nil {
				_, phaseColor := decodeFnPhase(fnStatus.Phase)
				fnPhaseLabel.SetTextColor(phaseColor)
			}
		})
	}()
}

func onRegister() {
	drv := driver.Active
	if drv == nil {
		return
	}
	if err := regBinder.Submit(); err != nil {
		return
	}

	if !regexp.MustCompile(`^\d+$`).MatchString(regModel.INN) || (len(regModel.INN) != 10 && len(regModel.INN) != 12) {
		walk.MsgBox(mw, "Ошибка", "ИНН должен состоять только из цифр и иметь длину 10 или 12 символов.", walk.MsgBoxIconError)
		return
	}

	if strings.TrimSpace(regModel.OrgName) == "" {
		walk.MsgBox(mw, "Ошибка", "Поле 'Наименование' обязательно для заполнения.", walk.MsgBoxIconError)
		return
	}

	if strings.TrimSpace(regModel.Address) == "" {
		walk.MsgBox(mw, "Ошибка", "Поле 'Адрес расчетов' обязательно для заполнения.", walk.MsgBoxIconError)
		return
	}

	if strings.TrimSpace(regModel.Place) == "" {
		walk.MsgBox(mw, "Ошибка", "Поле 'Место расчетов' обязательно для заполнения.", walk.MsgBoxIconError)
		return
	}

	req := fillRequestFromModel(false)

	go func() {
		if err := drv.SetCashier("Администратор", ""); err != nil {
			return
		}
		resp, err := drv.Register(req)
		if err != nil {
			mw.Synchronize(func() { walk.MsgBox(mw, "Ошибка регистрации", err.Error(), walk.MsgBoxIconError) })
			return
		}
		if err := drv.PrintLastDocument(); err != nil {
		}
		typeCode, err := drv.GetCurrentDocumentType()
		if err != nil {
			// log.Printf("[DRIVER] Ошибка получения типа документа: %v", err)
		}
		meta := driver.GetReportMeta(typeCode)
		regData, err := GetFullRegistrationData(drv)
		if err != nil {
			mw.Synchronize(func() { walk.MsgBox(mw, "Ошибка", err.Error(), walk.MsgBoxIconError) })
			return
		}
		if resp.FdNumber != "" {
			regData.FdNumber = resp.FdNumber
		}
		if resp.FpNumber != "" {
			regData.FpNumber = resp.FpNumber
		}
		meta.Data = regData
		if meta.Kind == driver.ReportReg || meta.Kind == driver.ReportRereg {
			mw.Synchronize(func() { RunReportModal(mw, meta) })
		}
	}()
}

func onReregister() {
	drv := driver.Active
	if drv == nil {
		return
	}
	if err := regBinder.Submit(); err != nil {
		return
	}

	if regModel.Reasons == "" {
		walk.MsgBox(mw, "Ошибка", "Не выбраны причины перерегистрации", walk.MsgBoxIconError)
		return
	}

	var reasons []int
	parts := strings.Split(regModel.Reasons, ",")
	for _, p := range parts {
		code, err := strconv.Atoi(strings.TrimSpace(p))
		if err != nil {
			walk.MsgBox(mw, "Ошибка", "Некорректный формат причин", walk.MsgBoxIconError)
			return
		}
		reasons = append(reasons, code)
	}

	if !regexp.MustCompile(`^\d+$`).MatchString(regModel.INN) || (len(regModel.INN) != 10 && len(regModel.INN) != 12) {
		walk.MsgBox(mw, "Ошибка", "ИНН должен состоять только из цифр и иметь длину 10 или 12 символов.", walk.MsgBoxIconError)
		return
	}

	if strings.TrimSpace(regModel.OrgName) == "" {
		walk.MsgBox(mw, "Ошибка", "Поле 'Наименование' обязательно для заполнения.", walk.MsgBoxIconError)
		return
	}

	if strings.TrimSpace(regModel.Address) == "" {
		walk.MsgBox(mw, "Ошибка", "Поле 'Адрес расчетов' обязательно для заполнения.", walk.MsgBoxIconError)
		return
	}

	if strings.TrimSpace(regModel.Place) == "" {
		walk.MsgBox(mw, "Ошибка", "Поле 'Место расчетов' обязательно для заполнения.", walk.MsgBoxIconError)
		return
	}

	req := fillRequestFromModel(true)

	go func() {
		if err := drv.SetCashier("Администратор", ""); err != nil {
			return
		}
		_, err := drv.Reregister(req, reasons)
		if err != nil {
			mw.Synchronize(func() {
				walk.MsgBox(mw, "Ошибка перерегистрации", err.Error(), walk.MsgBoxIconError)
			})
			return
		}
		if err := drv.PrintLastDocument(); err != nil {
		}
		typeCode, err := drv.GetCurrentDocumentType()
		if err != nil {
			// log.Printf("[DRIVER] Ошибка получения типа документа: %v", err)
		}
		meta := driver.GetReportMeta(typeCode)
		regData, err := GetFullRegistrationData(drv)
		if err != nil {
			mw.Synchronize(func() { walk.MsgBox(mw, "Ошибка", err.Error(), walk.MsgBoxIconError) })
			return
		}
		meta.Data = regData
		if meta.Kind == driver.ReportReg || meta.Kind == driver.ReportRereg {
			mw.Synchronize(func() { RunReportModal(mw, meta) })
		}
	}()
}

func onSelectReasons() {
	if err := regBinder.Submit(); err != nil {
		return
	}
	reasons, ok := RunReasonDialog(mw, regModel.Reasons)
	if ok {
		regModel.Reasons = reasons
		if err := regBinder.Reset(); err != nil {
			fmt.Println("Binder reset error:", err)
		}
	}
}

func onReplaceFn() {
	drv := driver.Active
	if drv == nil {
		return
	}
	if err := regBinder.Submit(); err != nil {
		return
	}

	req := fillRequestFromModel(false)
	reasons := []int{1}

	go func() {
		if err := drv.SetCashier("Администратор", ""); err != nil {
			return
		}
		resp, err := drv.Reregister(req, reasons)
		if err != nil {
			mw.Synchronize(func() {
				walk.MsgBox(mw, "Ошибка замены ФН", err.Error(), walk.MsgBoxIconError)
			})
		} else {
			mw.Synchronize(func() {
				walk.MsgBox(mw, "Успех", fmt.Sprintf("ФН заменен!\nФД: %s\nФП: %s", resp.FdNumber, resp.FpNumber), walk.MsgBoxIconInformation)
			})
		}
	}()
}

func onCloseFn() {
	drv := driver.Active
	if drv == nil {
		return
	}
	if walk.MsgBox(mw, "Подтверждение", "Вы действительно хотите закрыть фискальный архив?\nЭто необратимая операция!", walk.MsgBoxYesNo|walk.MsgBoxIconWarning) != walk.DlgCmdYes {
		return
	}
	go func() {
		// 1. Закрытие ФН (включает PRINT)
		result, err := drv.CloseFiscalArchive()
		if err != nil {
			mw.Synchronize(func() { walk.MsgBox(mw, "Ошибка", err.Error(), walk.MsgBoxIconError) })
			return
		}

		// 2. Получение типа документа для метаданных отчёта
		typeCode, _ := drv.GetCurrentDocumentType()
		meta := driver.GetReportMeta(typeCode)

		// 3. Сбор данных для отчёта через хелпер
		reportData, err := GetCloseFnReportData(drv, result.FD, result.FP)
		if err != nil {
			mw.Synchronize(func() { walk.MsgBox(mw, "Ошибка", err.Error(), walk.MsgBoxIconError) })
			return
		}

		// 4. Отображение отчёта
		meta.Data = reportData
		mw.Synchronize(func() { RunReportModal(mw, meta) })
	}()
}

// onSendToOfd отправляет первый неотправленный документ в ОФД
func onSendToOfd() {
	drv := driver.Active
	if drv == nil {
		walk.MsgBox(mw, "Ошибка", "Нет подключения к ККТ", walk.MsgBoxIconError)
		return
	}

	go func() {
		result, err := SendFirstUnsentDocument(drv)
		mw.Synchronize(func() {
			if err != nil {
				walk.MsgBox(mw, "Ошибка", err.Error(), walk.MsgBoxIconError)
				return
			}

			if result.Success {
				walk.MsgBox(mw, "Успех",
					fmt.Sprintf("Отправлено документов: %d", result.DocumentsSent),
					walk.MsgBoxIconInformation)
			} else {
				walk.MsgBox(mw, "Информация", result.ErrorMessage, walk.MsgBoxIconWarning)
			}

			// Обновляем информацию о ФН
			onRefreshFnInfo()
		})
	}()
}

// onRefreshFnInfo обновляет информацию о ФН
func onRefreshFnInfo() {
	drv := driver.Active
	if drv == nil {
		return
	}

	go func() {
		err := RefreshFnInfo(drv)
		if err != nil {
			mw.Synchronize(func() {
				logMsg("Ошибка обновления ФН: %v", err)
			})
		}
	}()
}

func fillRequestFromModel(isRereg bool) driver.RegistrationRequest {
	req := driver.RegistrationRequest{
		IsReregistration: isRereg,
		RNM:              regModel.RNM,
		Inn:              regModel.INN,
		OrgName:          regModel.OrgName,
		Address:          regModel.Address,
		Place:            regModel.Place,
		SenderEmail:      regModel.Email,
		FnsSite:          regModel.Site,
		FfdVer:           regModel.FFD,
		OfdName:          regModel.OFDName,
		OfdInn:           regModel.OFDINN,
		AutonomousMode:   regModel.ModeAutonomous,
		Encryption:       regModel.ModeEncryption,
		Service:          regModel.ModeService,
		InternetCalc:     regModel.ModeInternet,
		BSO:              regModel.ModeBSO,
		Gambling:         regModel.ModeGambling,
		Lottery:          regModel.ModeLottery,
		Excise:           regModel.ModeExcise,
		Marking:          regModel.ModeMarking,
		PawnShop:         regModel.ModePawn,
		Insurance:        regModel.ModeInsurance,
		Catering:         regModel.ModeCatering,
		Wholesale:        regModel.ModeWholesale,
		Vending:          regModel.ModeVending,
		PrinterAutomat:   regModel.ModeAutomat,
		TaxSystemBase:    regModel.TaxSystemBase,
	}

	var taxCodes []string
	if regModel.TaxOSN {
		taxCodes = append(taxCodes, "0")
	}
	if regModel.TaxUSN {
		taxCodes = append(taxCodes, "1")
	}
	if regModel.TaxUSN_M {
		taxCodes = append(taxCodes, "2")
	}
	if regModel.TaxENVD {
		taxCodes = append(taxCodes, "3")
	}
	if regModel.TaxESHN {
		taxCodes = append(taxCodes, "4")
	}
	if regModel.TaxPat {
		taxCodes = append(taxCodes, "5")
	}
	req.TaxSystems = strings.Join(taxCodes, ",")

	return req
}

// --- Логика генерации РНМ (CRC) ---

// runRnmGenerationDialog запускает диалоговое окно для расчета РНМ
func runRnmGenerationDialog(inn, serial string) {
	var dlg *walk.Dialog
	var acceptPB, cancelPB *walk.PushButton
	var db *walk.DataBinder

	// Модель для диалога
	dlgModel := struct {
		Serial   string
		OrderNum string
	}{
		Serial:   serial,
		OrderNum: "1", // По умолчанию 1
	}

	err := d.Dialog{
		AssignTo:      &dlg,
		Title:         "Генерация РНМ (CRC16)",
		MinSize:       d.Size{Width: 350, Height: 200},
		Layout:        d.VBox{},
		DefaultButton: &acceptPB,
		CancelButton:  &cancelPB,
		DataBinder: d.DataBinder{
			AssignTo:   &db,
			DataSource: &dlgModel,
		},
		Children: []d.Widget{
			d.Label{Text: "ИНН Пользователя (из формы):"},
			d.LineEdit{Text: inn, ReadOnly: true}, // ИНН только для отображения

			d.Label{Text: "Заводской номер ККТ (20 знаков):"},
			d.LineEdit{Text: d.Bind("Serial"), MaxLength: 20},

			d.Label{Text: "Порядковый номер регистрации (обычно 1):"},
			d.LineEdit{Text: d.Bind("OrderNum"), MaxLength: 10},

			d.Composite{
				Layout: d.HBox{},
				Children: []d.Widget{
					d.HSpacer{},
					d.PushButton{
						AssignTo: &acceptPB,
						Text:     "Сгенерировать",
						OnClicked: func() {
							if err := db.Submit(); err != nil {
								return
							}
							if dlgModel.Serial == "" {
								walk.MsgBox(dlg, "Ошибка", "Введите заводской номер", walk.MsgBoxIconError)
								return
							}

							// Расчет
							rnm, err := calculateRNM(dlgModel.OrderNum, inn, dlgModel.Serial)
							if err != nil {
								walk.MsgBox(dlg, "Ошибка расчета", err.Error(), walk.MsgBoxIconError)
								return
							}

							// Применяем результат
							regModel.RNM = rnm
							if err := regBinder.Reset(); err != nil {
								fmt.Println("Binder reset error:", err)
							}
							dlg.Accept()
						},
					},
					d.PushButton{
						AssignTo:  &cancelPB,
						Text:      "Отмена",
						OnClicked: func() { dlg.Cancel() },
					},
				},
			},
		},
	}.Create(mw)

	if err != nil {
		walk.MsgBox(mw, "Error", err.Error(), walk.MsgBoxIconError)
		return
	}

	dlg.Run()
}

// calculateRNM выполняет расчет РНМ по алгоритму CRC16-CCITT.
// Формат входных данных для CRC:
// Pad(Order, 10) + Pad(INN, 12) + Pad(Serial, 20)
// Результат: Pad(Order, 10) + Pad(CRC, 6)
func calculateRNM(orderNum, inn, serial string) (string, error) {
	// 1. Формируем строку для расчета
	paddedOrder := padLeft(orderNum, 10, '0')
	paddedInn := padLeft(inn, 12, '0')
	paddedSerial := padLeft(serial, 20, '0')

	// Строка: 0000000001 + 007804437548 + 00000000000000000156 (пример)
	calcString := paddedOrder + paddedInn + paddedSerial

	// 2. Считаем CRC
	crc := crc16ccitt([]byte(calcString))

	// 3. Формируем хвост (CRC дополненный до 6 цифр нулями)
	// Пример: CRC 33271 -> "033271"
	crcStr := fmt.Sprintf("%d", crc)
	paddedCrc := padLeft(crcStr, 6, '0')

	// 4. Итоговый РНМ
	finalRnm := paddedOrder + paddedCrc

	return finalRnm, nil
}

// crc16ccitt вычисляет CRC-16 (CCITT False)
// Poly: 0x1021, Init: 0xFFFF
func crc16ccitt(data []byte) uint16 {
	crc := uint16(0xFFFF)
	for _, b := range data {
		crc ^= uint16(b) << 8
		for i := 0; i < 8; i++ {
			if (crc & 0x8000) != 0 {
				crc = (crc << 1) ^ 0x1021
			} else {
				crc <<= 1
			}
		}
	}
	return crc
}

// padLeft дополняет строку символом padChar слева до длины length
func padLeft(s string, length int, padChar byte) string {
	if len(s) >= length {
		return s // Или обрезать, если требуется строго length
	}
	padding := make([]byte, length-len(s))
	for i := range padding {
		padding[i] = padChar
	}
	return string(padding) + s
}
</file>

<file path="gui\tab_service.go">
package gui

import (
	"fmt"
	"net"
	"strconv"
	"strings"
	"time"

	"github.com/lxn/walk"
	d "github.com/lxn/walk/declarative"

	"mitsuscanner/driver"
	"mitsuscanner/internal/cliche"
	"mitsuscanner/internal/service"
)

// -----------------------------
// ВСПОМОГАТЕЛЬНЫЕ СТРУКТУРЫ
// -----------------------------

// NV (Name-Value) используется для заполнения ComboBox
type NV struct {
	Name string
	Code string
}

// Списки значений для выпадающих меню
var (
	// ОФД Клиент
	listClients = []*NV{
		{"Внешний", "1"},
		{"Встроенный (LAN)", "0"},
	}
	// Скорость
	listBaud = []*NV{
		{"9600", "9600"}, {"19200", "19200"}, {"38400", "38400"}, {"57600", "57600"}, {"115200", "115200"},
	}
	// Модель принтера
	listModels = []*NV{
		{"RP-809", "1"}, {"F80", "2"},
	}
	// Значения должны быть "80" и "57", а не индексы "0"/"1"
	listPapers = []*NV{
		{"80мм", "80"}, {"57мм", "57"},
	}
	// Позиция QR (b1)
	listQRPos = []*NV{
		{"Слева", "0"}, {"По центру", "1"}, {"Справа", "2"},
	}
	// Округление (b2)
	listRounding = []*NV{
		{"Нет", "0"}, {"0.10", "1"}, {"0.50", "2"}, {"1.00", "3"},
	}
	// Триггер ящика (b5)
	listDrawerTrig = []*NV{
		{"Нет", "0"}, {"Наличные", "1"}, {"Безнал", "2"}, {"Всегда", "3"},
	}
	// Часовые пояса (упрощенно)
	listTimezones = []*NV{
		{"UTC+2 (Клд)", "2"}, {"UTC+3 (Мск)", "3"}, {"UTC+4 (Смр)", "4"},
		{"UTC+5 (Екб)", "5"}, {"UTC+6 (Омск)", "6"}, {"UTC+7 (Крсн)", "7"},
		{"UTC+8 (Ирк)", "8"}, {"UTC+9 (Якт)", "9"}, {"UTC+10 (Влд)", "10"},
		{"UTC+11 (Маг)", "11"}, {"UTC+12 (Кам)", "12"}, {"Не настроено", "254"},
	}

	listClicheTypes = []*NV{
		{"1 - Заголовок (Клише)", "1"},
		{"2 - После пользователя", "2"},
		{"3 - Подвал (Реклама)", "3"},
		{"4 - Конец чека", "4"},
	}
	listAlign = []*NV{
		{"Слева", "0"}, {"Центр", "1"}, {"Справа", "2"},
	}
	listFonts = []*NV{
		{"A", "0"}, {"B", "1"},
	}
	listUnderline = []*NV{
		{"Нет", "0"}, {"Текст", "1"}, {"Вся строка", "2"},
	}
)

// -----------------------------
// МОДЕЛИ ДАННЫХ КЛИШЕ
// -----------------------------

// ClicheItemWrapper обертка над internal/cliche.Line для GUI.
// Walk требует конкретных типов полей для DataBinding.
type ClicheItemWrapper struct {
	Index int
	Line  cliche.Line
}

// Геттеры/Сеттеры для DataBinder, чтобы мапить поля формы на cliche.Props

func (c *ClicheItemWrapper) Text() string     { return c.Line.Text }
func (c *ClicheItemWrapper) SetText(v string) { c.Line.Text = v }

func (c *ClicheItemWrapper) Format() string { return c.Line.Format }

func (c *ClicheItemWrapper) Invert() bool     { return c.Line.Props.Invert }
func (c *ClicheItemWrapper) SetInvert(v bool) { c.Line.Props.Invert = v; c.updateFormat() }

func (c *ClicheItemWrapper) Width() int     { return c.Line.Props.Width }
func (c *ClicheItemWrapper) SetWidth(v int) { c.Line.Props.Width = v; c.updateFormat() }

func (c *ClicheItemWrapper) Height() int     { return c.Line.Props.Height }
func (c *ClicheItemWrapper) SetHeight(v int) { c.Line.Props.Height = v; c.updateFormat() }

// Для ComboBox используем string
func (c *ClicheItemWrapper) Font() string { return strconv.Itoa(c.Line.Props.Font) }
func (c *ClicheItemWrapper) SetFont(v string) {
	c.Line.Props.Font, _ = strconv.Atoi(v)
	c.updateFormat()
}

func (c *ClicheItemWrapper) Underline() string { return strconv.Itoa(c.Line.Props.Underline) }
func (c *ClicheItemWrapper) SetUnderline(v string) {
	c.Line.Props.Underline, _ = strconv.Atoi(v)
	c.updateFormat()
}

func (c *ClicheItemWrapper) Align() string { return strconv.Itoa(c.Line.Props.Align) }
func (c *ClicheItemWrapper) SetAlign(v string) {
	c.Line.Props.Align, _ = strconv.Atoi(v)
	c.updateFormat()
}

func (c *ClicheItemWrapper) updateFormat() {
	c.Line.Format = cliche.BuildFormat(c.Line.Props)
}

// ClicheModel - модель для TableView.
type ClicheModel struct {
	walk.TableModelBase
	Items []*ClicheItemWrapper
}

func (m *ClicheModel) RowCount() int {
	return len(m.Items)
}

func (m *ClicheModel) Value(row, col int) interface{} {
	if row >= len(m.Items) {
		return ""
	}
	item := m.Items[row]
	switch col {
	case 0:
		return item.Index + 1 // Номер строки 1..10
	case 1:
		return item.Line.Format
	case 2:
		return item.Line.Text
	}
	return ""
}

// -----------------------------
// VIEW MODEL (ГЛАВНАЯ)
// -----------------------------

type ServiceViewModel struct {
	// --- Время ---
	KktTimeStr    string
	TargetTimeStr string // Было PcTimeStr. Теперь это желаемое время установки.
	AutoSyncPC    bool   // Чекбокс "Авто (Время ПК)"

	// --- Связь и ОФД ---
	OfdString string // Адрес:Порт
	OfdClient string // "0" или "1"
	TimerFN   int
	TimerOFD  int

	OismString string // Адрес:Порт

	// LAN
	LanAddr string
	LanPort int
	LanMask string
	LanDns  string
	LanGw   string

	// --- Параметры (Оборудование и Опции) ---
	// ВАЖНО: Все поля для ComboBox должны быть string, иначе DataBinder не выберет значение
	PrintModel string // "1", "2"
	PrintBaud  string // "115200"
	PrintPaper string // "80", "57" (БЫЛО int, стало string)
	PrintFont  string // "0", "1"   (БЫЛО int, стало string)

	// Опции (b0-b9)
	OptTimezone     string
	OptCut          bool
	OptAutoTest     bool
	OptNearEnd      bool
	OptTextQR       bool
	OptCountInCheck bool
	OptQRPos        string
	OptRounding     string
	OptDrawerTrig   string

	// Опция b9 (разделена на СНО и Флаг)
	OptB9_BaseTax string // "0", "1"... (Value member)
	OptB9_FullX   bool

	// Доступные СНО для b9 (храним в модели, но обновляем виджет вручную)
	OptB9_SNO []*NV

	// Денежный ящик (остаются int, т.к. используются в NumberEdit)
	DrawerPin  int
	DrawerRise int
	DrawerFall int

	// --- Клише ---
	SelectedClicheType string               // "1".."4"
	LastSelectedType   string               // Для сохранения предыдущего состояния при переключении
	ClicheItems        []*ClicheItemWrapper // 10 строк
	CurrentClicheLine  *ClicheItemWrapper   // Указатель на редактируемую строку
	// TempClicheLine - временный объект для редактирования.
	// Данные из него попадают в ClicheItems только по кнопке "Применить".
	TempClicheLine *ClicheItemWrapper
}

// ServiceLabels хранит ссылки на лейблы для выделения жирным шрифтом
type ServiceLabels struct {
	// Printer
	PrinterModel, PrinterBaud, PrinterPaper, PrinterFont, PrinterCut, PrinterSound, PrinterTest *walk.Label
	// Drawer
	DrawerPin, DrawerRise, DrawerFall, DrawerTrig *walk.Label
	// Network
	OfdAddr, OfdClient, TimerFN, TimerOFD, OismAddr, Timezone *walk.Label
	LanIp, LanMask, LanGw, LanPort                            *walk.Label
	// Options
	OptQRPos, OptTextQR, OptCount, OptRounding *walk.Label
	// B9
	OptB9_BaseTax, OptB9_FullX *walk.Label
	// Cliche
	ClicheHeader *walk.Label
}

var (
	serviceModel  *ServiceViewModel
	serviceBinder *walk.DataBinder
	sLabels       ServiceLabels

	// Глобальные снапшоты состояния
	initialSnapshot *service.SettingsSnapshot
	currentSnapshot *service.SettingsSnapshot
	currentChanges  []service.Change

	// Элементы управления
	btnServiceAction *walk.PushButton

	// Специфичный контрол для b9, чтобы менять его Model вручную
	b9ComboBox *walk.ComboBox

	// Элементы для прямого доступа (Время)
	kktTimeLabel   *walk.Label
	targetTimeEdit *walk.LineEdit
	autoSyncCheck  *walk.CheckBox

	// Таймеры
	pcTicker  *time.Ticker
	kktTicker *time.Ticker

	// Сервис времени
	timeService *service.TimeLogic

	// Флаг загрузки (блокировка событий)
	isLoadingData bool

	// --- Элементы редактора Клише ---
	clicheTable        *walk.TableView
	clicheModel        *ClicheModel
	clicheEditorGroup  *walk.GroupBox
	clicheEditorBinder *walk.DataBinder

	ceText                   *walk.LineEdit
	ceAlign, ceFont, ceUnder *walk.ComboBox
	ceWidth, ceHeight        *walk.NumberEdit
	ceInvert                 *walk.CheckBox
)

// -----------------------------
// УТИЛИТЫ
// -----------------------------

func splitHostPort(full string) (string, int) {
	if full == "" {
		return "", 0
	}
	host, portStr, err := net.SplitHostPort(full)
	if err != nil {
		return full, 0
	}
	port, _ := strconv.Atoi(portStr)
	return host, port
}

func joinHostPort(host string, port int) string {
	if port == 0 {
		return host
	}
	return fmt.Sprintf("%s:%d", host, port)
}

// -----------------------------
// ЛОГИКА СНАПШОТОВ И СРАВНЕНИЯ
// -----------------------------

// viewModelToSnapshot конвертирует текущую ViewModel в структуру Snapshot.
func viewModelToSnapshot(vm *ServiceViewModel) *service.SettingsSnapshot {
	s := service.NewSettingsSnapshot()

	// 1. ОФД
	host, port := splitHostPort(vm.OfdString)
	s.Ofd = driver.OfdSettings{
		Addr:     host,
		Port:     port,
		Client:   vm.OfdClient,
		TimerFN:  vm.TimerFN,
		TimerOFD: vm.TimerOFD,
	}

	// 2. ОИСМ
	hostO, portO := splitHostPort(vm.OismString)
	s.Oism = driver.ServerSettings{Addr: hostO, Port: portO}

	// 3. LAN
	s.Lan = driver.LanSettings{
		Addr: vm.LanAddr, Mask: vm.LanMask, Port: vm.LanPort,
		Dns: vm.LanDns, Gw: vm.LanGw,
	}

	// 4. Timezone
	s.Timezone, _ = strconv.Atoi(vm.OptTimezone)

	// 5. Printer
	// Преобразуем строки из UI обратно в int для драйвера
	baud, _ := strconv.Atoi(vm.PrintBaud)
	paper, _ := strconv.Atoi(vm.PrintPaper)
	font, _ := strconv.Atoi(vm.PrintFont)

	s.Printer = driver.PrinterSettings{
		Model:    vm.PrintModel,
		BaudRate: baud,
		Paper:    paper,
		Font:     font,
	}

	// 6. Drawer
	s.Drawer = driver.DrawerSettings{
		Pin:  vm.DrawerPin,
		Rise: vm.DrawerRise,
		Fall: vm.DrawerFall,
	}

	// 7. Options
	opts := driver.DeviceOptions{}
	opts.B1, _ = strconv.Atoi(vm.OptQRPos)
	opts.B2, _ = strconv.Atoi(vm.OptRounding)
	opts.B3 = boolToInt(vm.OptCut)
	opts.B4 = boolToInt(vm.OptAutoTest)
	opts.B5, _ = strconv.Atoi(vm.OptDrawerTrig)
	opts.B6 = boolToInt(vm.OptNearEnd)
	opts.B7 = boolToInt(vm.OptTextQR)
	opts.B8 = boolToInt(vm.OptCountInCheck)

	// В опции B9 содержится код базовой СНО + флаг полного Х-отчет (+16).
	// Код СНО в b9 = 1..8.
	b9Val := 0
	if vm.OptB9_BaseTax != "" {
		if v, err := strconv.Atoi(vm.OptB9_BaseTax); err == nil {
			b9Val += v
		}
	}
	if vm.OptB9_FullX {
		b9Val += 16
	}
	opts.B9 = b9Val
	s.Options = opts

	// 8. Cliches
	// Копируем остальные типы из текущего снапшота, чтобы не потерять их
	if currentSnapshot != nil {
		for k, v := range currentSnapshot.Cliches {
			dst := make([]driver.ClicheLineData, len(v))
			copy(dst, v)
			s.Cliches[k] = dst
		}
	}

	curType, _ := strconv.Atoi(vm.SelectedClicheType)
	var lines []driver.ClicheLineData

	for _, item := range vm.ClicheItems {
		// Обновляем формат в строке перед сохранением
		item.updateFormat()
		lines = append(lines, driver.ClicheLineData{
			Text:   item.Line.Text,
			Format: item.Line.Format,
		})
	}
	s.Cliches[curType] = lines

	return s
}

func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}

func onServiceAction() {
	if len(currentChanges) > 0 {
		onWriteAllParameters()
	} else {
		onReadAllSettings()
	}
}

// recalcChanges вызывается при любом изменении в UI
func recalcChanges() {
	if isLoadingData || serviceBinder == nil || initialSnapshot == nil {
		return
	}

	// 1. Submit данных из UI в ViewModel
	if err := serviceBinder.Submit(); err != nil {
		// Ошибка валидации или биндинга, пока игнорируем
		return
	}

	// 2. Обновляем текущий снапшот на основе VM
	currentSnapshot = viewModelToSnapshot(serviceModel)

	// 3. Сравниваем с начальным
	currentChanges = service.Compare(initialSnapshot, currentSnapshot)

	// 4. Обновляем UI кнопки
	mw.Synchronize(func() {
		count := len(currentChanges)
		if count > 0 {
			btnServiceAction.SetText(fmt.Sprintf("Записать (%d)", count))
		} else {
			btnServiceAction.SetText("Считать")
		}
		// Кнопка всегда активна, если мы не в процессе загрузки (isLoadingData)
		btnServiceAction.SetEnabled(!isLoadingData)

		// 5. Подсветка лейблов
		highlightLabels(currentChanges)
	})
}

// highlightLabels проходит по списку изменений и делает начертание лейблов жирным.
func highlightLabels(changes []service.Change) {
	// Карта соответствия атомарных ID из компаратора к лейблам в UI.
	labelMap := map[string][]**walk.Label{
		"Printer_Model":    {&sLabels.PrinterModel},
		"Printer_Baud":     {&sLabels.PrinterBaud},
		"Printer_Paper":    {&sLabels.PrinterPaper},
		"Printer_Font":     {&sLabels.PrinterFont},
		"Drawer_Settings":  {&sLabels.DrawerPin, &sLabels.DrawerRise, &sLabels.DrawerFall},
		"Timezone":         {&sLabels.Timezone},
		"Opt_QRPos":        {&sLabels.OptQRPos},
		"Opt_Rounding":     {&sLabels.OptRounding},
		"Opt_Cut":          {&sLabels.PrinterCut},
		"Opt_AutoTest":     {&sLabels.PrinterTest},
		"Opt_DrawerTrig":   {&sLabels.DrawerTrig},
		"Opt_NearEnd":      {&sLabels.PrinterSound},
		"Opt_TextQR":       {&sLabels.OptTextQR},
		"Opt_CountInCheck": {&sLabels.OptCount},
		"Opt_B9":           {&sLabels.OptB9_BaseTax, &sLabels.OptB9_FullX},
		"Ofd_Addr":         {&sLabels.OfdAddr},
		"Ofd_Client":       {&sLabels.OfdClient},
		"Ofd_Timers":       {&sLabels.TimerFN, &sLabels.TimerOFD},
		"Oism_Addr":        {&sLabels.OismAddr},
		"Lan_Settings":     {&sLabels.LanIp, &sLabels.LanMask, &sLabels.LanGw, &sLabels.LanPort},
	}

	// Функция-помощник для смены начертания без изменения размера и шрифта
	setBold := func(lbPtr **walk.Label, bold bool) {
		if lbPtr == nil || *lbPtr == nil {
			return
		}
		lbl := *lbPtr
		f := lbl.Font()
		style := walk.FontStyle(0)
		if bold {
			style = walk.FontBold
		}

		// Создаем новый шрифт, сохраняя Family и PointSize
		newFont, err := walk.NewFont(f.Family(), f.PointSize(), style)
		if err == nil {
			lbl.SetFont(newFont)
		}
	}

	// 1. Сначала сбрасываем все лейблы в обычное начертание
	for _, labels := range labelMap {
		for _, lblPtr := range labels {
			setBold(lblPtr, false)
		}
	}

	// 2. Устанавливаем жирное начертание для измененных параметров
	for _, ch := range changes {
		// ИСПРАВЛЕНО: Удалена подсветка ClicheHeader (Cliche_...)

		// Остальные параметры по карте
		if labels, ok := labelMap[ch.ID]; ok {
			for _, lblPtr := range labels {
				setBold(lblPtr, true)
			}
		}
	}
}

// -----------------------------
// ЗАГРУЗКА ДАННЫХ
// -----------------------------

func loadServiceInitial() {
	go func() {
		// Ждем инициализации окна
		for i := 0; i < 20; i++ {
			if mw != nil && mw.Handle() != 0 {
				break
			}
			time.Sleep(100 * time.Millisecond)
		}
		if mw == nil {
			return
		}
		onReadAllSettings()
	}()
}

func onReadAllSettings() {
	drv := driver.Active
	if drv == nil {
		mw.Synchronize(func() {
			serviceModel.KktTimeStr = "Нет подключения"
			// При потере связи ставим время ПК
			serviceModel.TargetTimeStr = timeService.FormatTime(time.Now())
			serviceBinder.Reset()
			btnServiceAction.SetText("Считать")
		})
		return
	}

	// 1. ЗАПОМИНАЕМ ТЕКУЩИЙ ВЫБРАННЫЙ ТИП КЛИШЕ
	// Чтобы после чтения настроек не сбрасывать пользователя на "Заголовок".
	// Если пусто (первый запуск), ставим "1".
	currentClicheType := "1"
	if serviceModel.SelectedClicheType != "" {
		currentClicheType = serviceModel.SelectedClicheType
	}

	mw.Synchronize(func() {
		// Блокируем триггеры изменений на время загрузки
		isLoadingData = true
		btnServiceAction.SetEnabled(false)
		btnServiceAction.SetText("Чтение...")
	})

	go func() {
		// Читаем всё из ККТ (время, настройки, клише, регистрацию)
		t, _ := drv.GetDateTime()
		ofd, _ := drv.GetOfdSettings()
		oism, _ := drv.GetOismSettings()
		lan, _ := drv.GetLanSettings()
		prn, _ := drv.GetPrinterSettings()
		cd, _ := drv.GetMoneyDrawerSettings()
		opts, _ := drv.GetOptions()
		tz, _ := drv.GetTimezone()
		regData, _ := drv.GetRegistrationData()

		allCliches := make(map[int][]driver.ClicheLineData)
		for i := 1; i <= 4; i++ {
			lines, err := drv.GetHeader(i)
			if err == nil {
				allCliches[i] = lines
			}
		}

		mw.Synchronize(func() {
			// 1. Обновляем модель времени
			if !t.IsZero() {
				serviceModel.KktTimeStr = t.Format("02.01.2006 15:04:05")
			}
			// Целевое время при чтении обновляем текущим временем ПК (так как стоит авто)
			serviceModel.TargetTimeStr = timeService.FormatTime(time.Now())

			// 2. Обновляем основные поля в ViewModel
			if ofd != nil {
				serviceModel.OfdString = joinHostPort(ofd.Addr, ofd.Port)
				serviceModel.OfdClient = ofd.Client
				serviceModel.TimerFN = ofd.TimerFN
				serviceModel.TimerOFD = ofd.TimerOFD
			}
			if oism != nil {
				serviceModel.OismString = joinHostPort(oism.Addr, oism.Port)
			}
			if lan != nil {
				serviceModel.LanAddr = lan.Addr
				serviceModel.LanPort = lan.Port
				serviceModel.LanMask = lan.Mask
				serviceModel.LanDns = lan.Dns
				serviceModel.LanGw = lan.Gw
			}
			if prn != nil {
				serviceModel.PrintModel = prn.Model
				serviceModel.PrintBaud = strconv.Itoa(prn.BaudRate)
				serviceModel.PrintPaper = strconv.Itoa(prn.Paper)
				serviceModel.PrintFont = strconv.Itoa(prn.Font)
			}
			if cd != nil {
				serviceModel.DrawerPin = cd.Pin
				serviceModel.DrawerRise = cd.Rise
				serviceModel.DrawerFall = cd.Fall
			}

			// --- Формирование списка доступных СНО для b9 ---
			var taxList []*NV
			// Добавляем пустой вариант
			taxList = append(taxList, &NV{Name: "Не выбрано", Code: "0"})

			if regData != nil && regData.TaxSystems != "" {
				parts := strings.Split(regData.TaxSystems, ",")
				taxNameMap := map[string]string{
					"0": "ОСН", "1": "УСН доход", "2": "УСН д-р",
					"3": "ЕНВД", "4": "ЕСХН", "5": "Патент",
				}
				for _, p := range parts {
					p = strings.TrimSpace(p)
					if p == "" {
						continue
					}

					name, ok := taxNameMap[p]
					if !ok {
						name = "СНО #" + p
					}

					// Конвертация: Code(1062) -> Code(b9) = Code(1062) + 1
					if codeInt, err := strconv.Atoi(p); err == nil {
						b9Code := strconv.Itoa(codeInt + 1)
						taxList = append(taxList, &NV{Name: name, Code: b9Code})
					}
				}
			}
			serviceModel.OptB9_SNO = taxList

			// Обновляем виджет ComboBox вручную
			if b9ComboBox != nil {
				b9ComboBox.SetModel(taxList)
			}

			serviceModel.OptTimezone = strconv.Itoa(tz)
			if opts != nil {
				serviceModel.OptQRPos = fmt.Sprintf("%d", opts.B1)
				serviceModel.OptRounding = fmt.Sprintf("%d", opts.B2)
				serviceModel.OptCut = (opts.B3 == 1)
				serviceModel.OptAutoTest = (opts.B4 == 1)
				serviceModel.OptDrawerTrig = fmt.Sprintf("%d", opts.B5)
				serviceModel.OptNearEnd = (opts.B6 == 1)
				serviceModel.OptTextQR = (opts.B7 == 1)
				serviceModel.OptCountInCheck = (opts.B8 == 1)

				// Парсинг b9
				serviceModel.OptB9_FullX = (opts.B9 & 16) != 0
				taxVal := opts.B9 & 0x0F
				serviceModel.OptB9_BaseTax = strconv.Itoa(taxVal)
			}

			// 3. Обновляем клише
			// ИСПОЛЬЗУЕМ СОХРАНЕННЫЙ ТИП
			serviceModel.SelectedClicheType = currentClicheType
			serviceModel.LastSelectedType = currentClicheType

			curType, _ := strconv.Atoi(currentClicheType)
			lines := allCliches[curType]

			for i := 0; i < 10; i++ {
				var text, format string
				if i < len(lines) {
					text = lines[i].Text
					format = lines[i].Format
				} else {
					text = ""
					format = "000000"
				}

				// Используем пакет cliche для парсинга
				props := cliche.ParseFormat(format)

				serviceModel.ClicheItems[i].Line = cliche.Line{
					Text:   text,
					Format: format,
					Props:  props,
				}
			}

			// 4. Сначала обновляем СНАПШОТЫ
			// ВАЖНО: Делаем глубокую копию карты клише, чтобы initialSnapshot и currentSnapshot
			// не ссылались на одну и ту же карту allCliches.

			tempSnap := viewModelToSnapshot(serviceModel)

			// Создаем две НЕЗАВИСИМЫЕ копии карты клише
			initCliches := make(map[int][]driver.ClicheLineData)
			currCliches := make(map[int][]driver.ClicheLineData)

			for k, v := range allCliches {
				dst1 := make([]driver.ClicheLineData, len(v))
				copy(dst1, v)
				initCliches[k] = dst1

				dst2 := make([]driver.ClicheLineData, len(v))
				copy(dst2, v)
				currCliches[k] = dst2
			}

			// Назначаем разные карты разным снапшотам
			initialSnapshot = tempSnap
			initialSnapshot.Cliches = initCliches

			// Создаем копию структуры для currentSnapshot
			currentSnapshotCopy := *tempSnap
			currentSnapshot = &currentSnapshotCopy
			currentSnapshot.Cliches = currCliches

			currentChanges = nil

			// 5. Теперь безопасно обновлять таблицу и принудительно перерисовывать
			clicheModel.PublishRowsReset()
			if clicheTable != nil {
				clicheTable.Invalidate()
			}

			// 6. Синхронизируем UI с обновленной моделью
			serviceBinder.Reset()

			// 7. Снимаем блокировку и обновляем состояние кнопки
			isLoadingData = false
			btnServiceAction.SetEnabled(true)
			btnServiceAction.SetText("Считать")

			// Принудительно сбрасываем подсветку
			highlightLabels(nil)
		})
	}()
}

// -----------------------------
// ЛОГИКА ВРЕМЕНИ
// -----------------------------

func startClocks() {
	if pcTicker == nil {
		pcTicker = time.NewTicker(time.Second)
		go func() {
			for range pcTicker.C {
				if mw == nil || mw.Handle() == 0 {
					continue
				}
				mw.Synchronize(func() {
					now := time.Now()

					// Логика обновления поля ввода
					if autoSyncCheck != nil && autoSyncCheck.Checked() {
						serviceModel.TargetTimeStr = timeService.FormatTime(now)
						if targetTimeEdit != nil {
							targetTimeEdit.SetText(serviceModel.TargetTimeStr)
						}
					}

					// Логика проверки разницы времени
					// Берем время из поля ввода (оно может быть ручным или авто)
					currentTimeStr := ""
					if targetTimeEdit != nil {
						currentTimeStr = targetTimeEdit.Text()
					}

					// Парсим время из поля ввода для сравнения
					targetTime, err := timeService.ParseTime(currentTimeStr)
					if err == nil {
						checkTimeDifference(targetTime)
					}
				})
			}
		}()
	}
	if kktTicker == nil {
		kktTicker = time.NewTicker(time.Second)
		go func() {
			for range kktTicker.C {
				if mw == nil || mw.Handle() == 0 {
					continue
				}
				mw.Synchronize(func() {
					if len(serviceModel.KktTimeStr) > 10 && serviceModel.KktTimeStr != "Нет подключения" && serviceModel.KktTimeStr != "Ошибка" {
						t, err := timeService.ParseTime(serviceModel.KktTimeStr)
						if err == nil {
							t = t.Add(time.Second)
							serviceModel.KktTimeStr = timeService.FormatTime(t)
							if kktTimeLabel != nil {
								kktTimeLabel.SetText(serviceModel.KktTimeStr)
							}
						}
					}
				})
			}
		}()
	}
}

func checkTimeDifference(targetTime time.Time) {
	if kktTimeLabel == nil {
		return
	}

	_, status := timeService.CompareTimes(serviceModel.KktTimeStr, targetTime)

	switch status {
	case service.TimeStatusOk:
		// Зеленый (OK)
		kktTimeLabel.SetTextColor(walk.RGB(0, 128, 0))
	case service.TimeStatusCritical:
		// Красный (Расхождение > 5 мин)
		kktTimeLabel.SetTextColor(walk.RGB(255, 0, 0))
	default:
		// Черный (Нет данных или ошибка)
		kktTimeLabel.SetTextColor(walk.RGB(0, 0, 0))
	}
}

// -----------------------------
// UI: GET SERVICE TAB
// -----------------------------

func GetServiceTab() d.TabPage {
	// Инициализация модели
	serviceModel = &ServiceViewModel{
		PrintModel:         "1",
		PrintBaud:          "115200",
		PrintPaper:         "80",
		PrintFont:          "0",
		DrawerPin:          5,
		DrawerRise:         100,
		DrawerFall:         100,
		OptTimezone:        "3",
		OptQRPos:           "1",
		OptRounding:        "0",
		OptDrawerTrig:      "1",
		OptCut:             true,
		OptB9_FullX:        false,
		OptB9_BaseTax:      "0",
		OptB9_SNO:          []*NV{{Name: "Не выбрано", Code: "0"}},
		OfdClient:          "1",
		SelectedClicheType: "1",
		LastSelectedType:   "1",
		CurrentClicheLine:  &ClicheItemWrapper{},
		TempClicheLine:     &ClicheItemWrapper{Line: cliche.Line{Format: "000000", Props: cliche.DefaultProps()}},
		KktTimeStr:         "Нет подключения",
		TargetTimeStr:      timeService.FormatTime(time.Now()),
		AutoSyncPC:         true, // По умолчанию включена синхронизация с ПК
	}

	serviceModel.ClicheItems = make([]*ClicheItemWrapper, 10)
	for i := 0; i < 10; i++ {
		// Инициализация строк с дефолтными пропсами
		wrapper := &ClicheItemWrapper{
			Index: i,
			Line: cliche.Line{
				Format: "000000",
				Props:  cliche.DefaultProps(),
			},
		}
		serviceModel.ClicheItems[i] = wrapper
	}
	clicheModel = &ClicheModel{Items: serviceModel.ClicheItems}

	loadServiceInitial()
	startClocks()

	return d.TabPage{
		Title:  "Сервис",
		Layout: d.VBox{MarginsZero: true, Spacing: 5},
		Children: []d.Widget{

			// ВЕРХ: Время и Операции
			d.Composite{
				Layout: d.HBox{MarginsZero: true, Spacing: 6},
				Children: []d.Widget{
					d.GroupBox{
						Title: "Синхронизация времени", StretchFactor: 1,
						Layout: d.VBox{Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 4},
						Children: []d.Widget{
							d.Composite{
								Layout: d.Grid{Columns: 2, Spacing: 4},
								Children: []d.Widget{
									d.Label{Text: "Время ККТ:", Font: d.Font{PointSize: 8}},
									d.Label{
										AssignTo: &kktTimeLabel,
										Text:     d.Bind("KktTimeStr"),
										Font:     d.Font{PointSize: 9, Bold: true},
									},

									d.Label{Text: "Установить:", Font: d.Font{PointSize: 8}},
									d.LineEdit{
										AssignTo: &targetTimeEdit,
										Text:     d.Bind("TargetTimeStr"),
										// Запрещаем редактирование если стоит галочка Авто (реализуется через OnCheckStateChanged)
										ReadOnly: false,
									},
								},
							},
							d.Composite{
								Layout: d.HBox{MarginsZero: true},
								Children: []d.Widget{
									d.CheckBox{
										AssignTo: &autoSyncCheck,
										Text:     "Авто (ПК)",
										Checked:  d.Bind("AutoSyncPC"),
										OnCheckStateChanged: func() {
											if targetTimeEdit != nil {
												targetTimeEdit.SetReadOnly(autoSyncCheck.Checked())
											}
										},
									},
									d.HSpacer{},
									d.PushButton{Text: "Установить", OnClicked: onSyncTime},
								},
							},
						},
					},
					d.GroupBox{
						Title: "Операции", StretchFactor: 1,
						Layout: d.Grid{Columns: 2, Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 4},
						Children: []d.Widget{
							d.PushButton{Text: "Прогон/Отрезка", OnClicked: onFeedAndCutService, MinSize: d.Size{Width: 90}},
							d.PushButton{Text: "Тех. сброс", OnClicked: onTechReset, MinSize: d.Size{Width: 90}},
							d.PushButton{Text: "Ден. ящик", OnClicked: onOpenDrawer, MinSize: d.Size{Width: 90}},
							d.PushButton{Text: "X-отчёт", OnClicked: onPrintXReport, MinSize: d.Size{Width: 90}},
							d.PushButton{Text: "Сброс МГМ", OnClicked: onMGMReset, MinSize: d.Size{Width: 90}},
							// ОСНОВНЫЕ КНОПКИ УПРАВЛЕНИЯ НАСТРОЙКАМИ
							d.PushButton{
								AssignTo:  &btnServiceAction,
								Text:      "Считать",
								OnClicked: onServiceAction,
								MinSize:   d.Size{Width: 150},
							},
						},
					},
				},
			},

			// ТАБЫ ПОДКАТЕГОРИЙ
			d.TabWidget{
				MinSize: d.Size{Height: 300},
				Pages: []d.TabPage{

					// 1. ПАРАМЕТРЫ
					{
						Title:  "Параметры",
						Layout: d.VBox{MarginsZero: true, Spacing: 0, Alignment: d.AlignHNearVNear},
						Children: []d.Widget{
							d.Composite{
								Layout: d.HBox{Margins: d.Margins{Left: 4, Top: 4, Right: 4, Bottom: 4}, Spacing: 4, Alignment: d.AlignHCenterVCenter},
								Children: []d.Widget{

									// КОЛОНКА 1
									d.Composite{
										Layout: d.VBox{MarginsZero: true, Spacing: 4},
										Children: []d.Widget{
											d.GroupBox{
												Title:  "ОФД и ОИСМ",
												Layout: d.Grid{Columns: 4, Spacing: 4, Margins: d.Margins{Left: 4, Top: 4, Right: 4, Bottom: 4}},
												Children: []d.Widget{
													d.Label{AssignTo: &sLabels.OfdAddr, Text: "ОФД:"}, d.LineEdit{Text: d.Bind("OfdString"), MinSize: d.Size{Width: 110}, MaxSize: d.Size{Width: 120}, OnTextChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.OfdClient, Text: "Клиент:"}, d.ComboBox{Value: d.Bind("OfdClient"), BindingMember: "Code", DisplayMember: "Name", Model: listClients, OnCurrentIndexChanged: checkOfdClientChange, MaxSize: d.Size{Width: 100}},
													d.Label{AssignTo: &sLabels.OismAddr, Text: "ОИСМ:"}, d.LineEdit{Text: d.Bind("OismString"), MinSize: d.Size{Width: 110}, MaxSize: d.Size{Width: 120}, OnTextChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.TimerFN, Text: "Т. ФН:"}, d.NumberEdit{Value: d.Bind("TimerFN"), MaxSize: d.Size{Width: 40}, OnValueChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.Timezone, Text: "Пояс:"}, d.ComboBox{Value: d.Bind("OptTimezone"), BindingMember: "Code", DisplayMember: "Name", Model: listTimezones, MinSize: d.Size{Width: 110}, MaxSize: d.Size{Width: 120}, OnCurrentIndexChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.TimerOFD, Text: "Т. ОФД:"}, d.NumberEdit{Value: d.Bind("TimerOFD"), MaxSize: d.Size{Width: 40}, OnValueChanged: recalcChanges},
												},
											},
											d.GroupBox{
												Title:  "Принтер и Бумага",
												Layout: d.Grid{Columns: 6, Spacing: 4, Margins: d.Margins{Left: 4, Top: 4, Right: 4, Bottom: 4}},
												Children: []d.Widget{
													d.Label{AssignTo: &sLabels.PrinterModel, Text: "Модель:"}, d.ComboBox{Value: d.Bind("PrintModel"), BindingMember: "Code", DisplayMember: "Name", Model: listModels, MaxSize: d.Size{Width: 70}, OnCurrentIndexChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.PrinterCut, Text: "Отрез:"}, d.CheckBox{Checked: d.Bind("OptCut"), OnCheckStateChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.PrinterBaud, Text: "Бод:"}, d.ComboBox{Value: d.Bind("PrintBaud"), BindingMember: "Code", DisplayMember: "Name", Model: listBaud, MaxSize: d.Size{Width: 70}, OnCurrentIndexChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.PrinterSound, Text: "Звук:"}, d.CheckBox{Checked: d.Bind("OptNearEnd"), OnCheckStateChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.PrinterPaper, Text: "Ширина:"}, d.ComboBox{Value: d.Bind("PrintPaper"), BindingMember: "Code", DisplayMember: "Name", Model: listPapers, MaxSize: d.Size{Width: 70}, OnCurrentIndexChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.PrinterTest, Text: "Тест:"}, d.CheckBox{Checked: d.Bind("OptAutoTest"), OnCheckStateChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.PrinterFont, Text: "Шрифт:"}, d.ComboBox{Value: d.Bind("PrintFont"), BindingMember: "Code", DisplayMember: "Name", Model: listFonts, MaxSize: d.Size{Width: 70}, ToolTipText: "A-стандратный, B-компактный", OnCurrentIndexChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.DrawerTrig, Text: "Триггер:"}, d.ComboBox{Value: d.Bind("OptDrawerTrig"), BindingMember: "Code", DisplayMember: "Name", Model: listDrawerTrig, MaxSize: d.Size{Width: 80}, OnCurrentIndexChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.DrawerPin, Text: "PIN:"}, d.NumberEdit{Value: d.Bind("DrawerPin"), MaxSize: d.Size{Width: 40}, OnValueChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.DrawerRise, Text: "Rise:"}, d.NumberEdit{Value: d.Bind("DrawerRise"), MaxSize: d.Size{Width: 40}, OnValueChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.DrawerFall, Text: "Fall:"}, d.NumberEdit{Value: d.Bind("DrawerFall"), MaxSize: d.Size{Width: 40}, OnValueChanged: recalcChanges},
												},
											},
										},
									},

									// КОЛОНКА 2
									d.Composite{
										Layout: d.HBox{MarginsZero: true, Spacing: 4},
										Children: []d.Widget{
											d.GroupBox{
												Title:  "Сеть (LAN)",
												Layout: d.Grid{Columns: 2, Spacing: 4, Margins: d.Margins{Left: 4, Top: 4, Right: 4, Bottom: 4}},
												Children: []d.Widget{
													d.Label{AssignTo: &sLabels.LanIp, Text: "IP:"}, d.LineEdit{Text: d.Bind("LanAddr"), MinSize: d.Size{Width: 90}, MaxSize: d.Size{Width: 100}, OnTextChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.LanMask, Text: "Mask:"}, d.LineEdit{Text: d.Bind("LanMask"), MinSize: d.Size{Width: 90}, MaxSize: d.Size{Width: 100}, OnTextChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.LanGw, Text: "GW:"}, d.LineEdit{Text: d.Bind("LanGw"), MinSize: d.Size{Width: 90}, MaxSize: d.Size{Width: 100}, OnTextChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.LanPort, Text: "Port:"}, d.NumberEdit{Value: d.Bind("LanPort"), MaxSize: d.Size{Width: 60}, OnValueChanged: recalcChanges},
												},
											},
											d.GroupBox{
												Title:  "Денежный ящик",
												Layout: d.Grid{Columns: 2, Spacing: 4, Margins: d.Margins{Left: 4, Top: 4, Right: 4, Bottom: 4}},
												Children: []d.Widget{
													d.Label{AssignTo: &sLabels.DrawerTrig, Text: "Триггер:"}, d.ComboBox{Value: d.Bind("OptDrawerTrig"), BindingMember: "Code", DisplayMember: "Name", Model: listDrawerTrig, MaxSize: d.Size{Width: 80}, OnCurrentIndexChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.DrawerPin, Text: "PIN:"}, d.NumberEdit{Value: d.Bind("DrawerPin"), MaxSize: d.Size{Width: 40}, OnValueChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.DrawerRise, Text: "Rise:"}, d.NumberEdit{Value: d.Bind("DrawerRise"), MaxSize: d.Size{Width: 40}, OnValueChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.DrawerFall, Text: "Fall:"}, d.NumberEdit{Value: d.Bind("DrawerFall"), MaxSize: d.Size{Width: 40}, OnValueChanged: recalcChanges},
												},
											},
											d.GroupBox{
												Title:  "Вид чека и Опции",
												Layout: d.Grid{Columns: 4, Spacing: 4, Margins: d.Margins{Left: 4, Top: 4, Right: 4, Bottom: 4}},
												Children: []d.Widget{
													d.Label{AssignTo: &sLabels.OptQRPos, Text: "QR:"},
													d.ComboBox{Value: d.Bind("OptQRPos"), BindingMember: "Code", DisplayMember: "Name", Model: listQRPos, MaxSize: d.Size{Width: 40}, OnCurrentIndexChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.OptTextQR, Text: "Текст QR:"},
													d.CheckBox{Checked: d.Bind("OptTextQR"), OnCheckStateChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.OptCount, Text: "Покупок:"},
													d.CheckBox{Checked: d.Bind("OptCountInCheck"), OnCheckStateChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.OptRounding, Text: "Округл.:"},
													d.ComboBox{Value: d.Bind("OptRounding"), BindingMember: "Code", DisplayMember: "Name", Model: listRounding, MaxSize: d.Size{Width: 40}, OnCurrentIndexChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.OptB9_FullX, Text: "X-Отчет:"},
													d.CheckBox{Text: "Полный", Checked: d.Bind("OptB9_FullX"), ToolTipText: "Печатать полный X-отчет (b9 & 16)", OnCheckStateChanged: recalcChanges},
													d.Label{AssignTo: &sLabels.OptB9_BaseTax, Text: "Баз. СНО:"},
													d.ComboBox{
														AssignTo:              &b9ComboBox,
														Value:                 d.Bind("OptB9_BaseTax"),
														BindingMember:         "Code",
														DisplayMember:         "Name",
														Model:                 serviceModel.OptB9_SNO,
														MinSize:               d.Size{Width: 40},
														ToolTipText:           "Система налогообложения по умолчанию",
														OnCurrentIndexChanged: recalcChanges,
													},
												},
											},
										},
									},
								},
							},
						},
					},

					// 2. КЛИШЕ
					{
						Title:  "Клише",
						Layout: d.VBox{Margins: d.Margins{Left: 8, Top: 8, Right: 8, Bottom: 8}, Spacing: 5},
						Children: []d.Widget{
							d.Composite{
								Layout: d.HBox{MarginsZero: true, Alignment: d.AlignHCenterVCenter},
								Children: []d.Widget{
									d.Label{AssignTo: &sLabels.ClicheHeader, Text: "Редактировать:"},
									d.ComboBox{
										Value:         d.Bind("SelectedClicheType"),
										Model:         listClicheTypes,
										BindingMember: "Code", DisplayMember: "Name",
										MinSize:               d.Size{Width: 100},
										OnCurrentIndexChanged: onClicheTypeSwitched,
									},
								},
							},
							d.Composite{
								Layout: d.HBox{MarginsZero: true, Spacing: 5},
								Children: []d.Widget{
									d.TableView{
										AssignTo:         &clicheTable,
										Model:            clicheModel,
										AlternatingRowBG: true,
										Columns: []d.TableViewColumn{
											{Title: "#", Width: 30},
											{Title: "Fmt", Width: 60},
											{Title: "Текст", Width: 200},
										},
										MinSize:               d.Size{Width: 300, Height: 200},
										MaxSize:               d.Size{Width: 300, Height: 200},
										OnCurrentIndexChanged: onClicheSelectionChanged,
										StyleCell: func(style *walk.CellStyle) {
											// Задаем черный цвет по умолчанию
											style.TextColor = walk.RGB(0, 0, 0)

											if initialSnapshot == nil {
												return
											}
											row := style.Row()
											if row < 0 || row >= len(serviceModel.ClicheItems) {
												return
											}

											curType, _ := strconv.Atoi(serviceModel.SelectedClicheType)
											if initialSnapshot.Cliches == nil {
												return
											}
											initialLines := initialSnapshot.Cliches[curType]

											var initialFormat, initialText string
											if row < len(initialLines) {
												initialFormat = initialLines[row].Format
												initialText = initialLines[row].Text
											} else {
												initialFormat = "000000"
												initialText = ""
											}

											currentItem := serviceModel.ClicheItems[row]

											// Если есть отличия - выделяем жирным
											if currentItem.Line.Text != initialText || currentItem.Line.Format != initialFormat {
												// БЕЗОПАСНОЕ ПОЛУЧЕНИЕ ШРИФТА
												var family string
												var size int

												if style.Font != nil {
													family = style.Font.Family()
													size = style.Font.PointSize()
												} else if clicheTable != nil && clicheTable.Font() != nil {
													// Берем шрифт самой таблицы
													family = clicheTable.Font().Family()
													size = clicheTable.Font().PointSize()
												} else {
													// Дефолтные значения (если совсем всё плохо)
													family = "Segoe UI"
													size = 9
												}

												// Создаем жирный шрифт
												if f, err := walk.NewFont(family, size, walk.FontBold); err == nil {
													style.Font = f
												}
											}
										},
									},
									d.GroupBox{
										AssignTo: &clicheEditorGroup,
										Title:    "Настройки строки",
										Layout:   d.VBox{Margins: d.Margins{Left: 10, Top: 10, Right: 10, Bottom: 10}, Spacing: 8},
										Enabled:  false,
										MaxSize:  d.Size{Width: 300, Height: 250},
										DataBinder: d.DataBinder{
											AssignTo:   &clicheEditorBinder,
											DataSource: serviceModel.TempClicheLine,
											// AutoSubmit не нужен, мы читаем вручную
										},
										Children: []d.Widget{
											d.Label{Text: "Текст:"},
											d.LineEdit{
												AssignTo: &ceText,
												Text:     d.Bind("Text"),
											},
											d.Composite{
												Layout: d.Grid{Columns: 2, Spacing: 10},
												Children: []d.Widget{
													d.Label{Text: "Выравнивание:"},
													d.ComboBox{
														AssignTo:      &ceAlign,
														Value:         d.Bind("Align"),
														Model:         listAlign,
														BindingMember: "Code", DisplayMember: "Name",
													},
													d.Label{Text: "Шрифт:"},
													d.ComboBox{
														AssignTo:      &ceFont,
														Value:         d.Bind("Font"),
														Model:         listFonts,
														BindingMember: "Code", DisplayMember: "Name",
													},
													d.Label{Text: "Подчеркивание:"},
													d.ComboBox{
														AssignTo:      &ceUnder,
														Value:         d.Bind("Underline"),
														Model:         listUnderline,
														BindingMember: "Code", DisplayMember: "Name",
													},
												},
											},
											d.GroupBox{
												Title:  "Масштабирование",
												Layout: d.Grid{Columns: 4},
												Children: []d.Widget{
													d.Label{Text: "Ширина:"},
													d.NumberEdit{
														AssignTo: &ceWidth,
														Value:    d.Bind("Width"),
														MinValue: 0, MaxValue: 8, MaxSize: d.Size{Width: 40},
													},
													d.Label{Text: "Высота:"},
													d.NumberEdit{
														AssignTo: &ceHeight,
														Value:    d.Bind("Height"),
														MinValue: 0, MaxValue: 8, MaxSize: d.Size{Width: 40},
													},
												},
											},
											d.CheckBox{
												AssignTo: &ceInvert, // <--- ДОБАВЛЕНО
												Text:     "Инверсия (Белым по черному)",
												Checked:  d.Bind("Invert"),
											},
											d.VSpacer{Size: 5},
											d.PushButton{
												Text:      "Применить изменения строки",
												OnClicked: onApplyClicheLine,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		DataBinder: d.DataBinder{
			AssignTo:       &serviceBinder,
			DataSource:     serviceModel,
			ErrorPresenter: d.ToolTipErrorPresenter{},
		},
	}
}

// -----------------------------
// ЛОГИКА ИНТЕРФЕЙСА (Event Handlers)
// -----------------------------

// restoreViewFromSnapshot восстанавливает значения в ViewModel из предоставленного снапшота.
func restoreViewFromSnapshot(vm *ServiceViewModel, snap *service.SettingsSnapshot) {
	if snap == nil {
		return
	}

	// Блокируем триггеры recalcChanges
	isLoadingData = true
	defer func() {
		isLoadingData = false
		recalcChanges() // Пересчитываем, чтобы сбросить флаги изменений и кнопки
	}()

	// 1. ОФД
	vm.OfdString = joinHostPort(snap.Ofd.Addr, snap.Ofd.Port)
	vm.OfdClient = snap.Ofd.Client
	vm.TimerFN = snap.Ofd.TimerFN
	vm.TimerOFD = snap.Ofd.TimerOFD

	// 2. ОИСМ
	vm.OismString = joinHostPort(snap.Oism.Addr, snap.Oism.Port)

	// 3. LAN
	vm.LanAddr = snap.Lan.Addr
	vm.LanPort = snap.Lan.Port
	vm.LanMask = snap.Lan.Mask
	vm.LanDns = snap.Lan.Dns
	vm.LanGw = snap.Lan.Gw

	// 4. Timezone
	vm.OptTimezone = strconv.Itoa(snap.Timezone)

	// 5. Принтер
	vm.PrintModel = snap.Printer.Model
	vm.PrintBaud = strconv.Itoa(snap.Printer.BaudRate)
	vm.PrintPaper = strconv.Itoa(snap.Printer.Paper)
	vm.PrintFont = strconv.Itoa(snap.Printer.Font)

	// 6. Денежный ящик
	vm.DrawerPin = snap.Drawer.Pin
	vm.DrawerRise = snap.Drawer.Rise
	vm.DrawerFall = snap.Drawer.Fall

	// 7. Опции
	vm.OptQRPos = strconv.Itoa(snap.Options.B1)
	vm.OptRounding = strconv.Itoa(snap.Options.B2)
	vm.OptCut = (snap.Options.B3 == 1)
	vm.OptAutoTest = (snap.Options.B4 == 1)
	vm.OptDrawerTrig = strconv.Itoa(snap.Options.B5)
	vm.OptNearEnd = (snap.Options.B6 == 1)
	vm.OptTextQR = (snap.Options.B7 == 1)
	vm.OptCountInCheck = (snap.Options.B8 == 1)

	// Восстановление b9
	vm.OptB9_FullX = (snap.Options.B9 & 16) != 0
	taxVal := snap.Options.B9 & 0x0F
	vm.OptB9_BaseTax = strconv.Itoa(taxVal)

	// 8. Клише
	curType, _ := strconv.Atoi(vm.SelectedClicheType)
	lines := snap.Cliches[curType]

	for i := 0; i < 10; i++ {
		var text, format string
		if i < len(lines) {
			text = lines[i].Text
			format = lines[i].Format
		} else {
			text = ""
			format = "000000"
		}

		// Заполняем структуру Line внутри Wrapper, используя новый парсер
		vm.ClicheItems[i].Line = cliche.Line{
			Text:   text,
			Format: format,
			Props:  cliche.ParseFormat(format),
		}
	}

	// Обновляем визуальное состояние
	if serviceBinder != nil {
		serviceBinder.Reset()
	}
	if clicheModel != nil {
		clicheModel.PublishRowsReset()
	}
}

func checkOfdClientChange() {
	if isLoadingData {
		return
	}
	recalcChanges()

	if serviceModel.OfdClient == "0" {
		res := walk.MsgBox(mw, "Подтверждение",
			"Для использования встроенного клиента ОФД требуется подключение ФР к локальной сети (LAN).\n\nПодтверждаете переключение?",
			walk.MsgBoxYesNo|walk.MsgBoxIconQuestion)

		if res != walk.DlgCmdYes {
			serviceModel.OfdClient = "1"
			if serviceBinder != nil {
				serviceBinder.Reset()
			}
			recalcChanges()
		}
	}
}

func onClicheTypeSwitched() {
	if isLoadingData || initialSnapshot == nil {
		// Просто обновляем трекинг, если мы в процессе загрузки
		serviceModel.LastSelectedType = serviceModel.SelectedClicheType
		return
	}

	// 1. ПРИНУДИТЕЛЬНО ЗАБИРАЕМ ДАННЫЕ ИЗ UI В МОДЕЛЬ
	// ВАЖНО: Без этого SelectedClicheType содержит СТАРОЕ значение, так как событие
	// OnCurrentIndexChanged срабатывает ДО автоматического Submit биндинга.
	if err := serviceBinder.Submit(); err != nil {
		logMsg("[CLICHE] Ошибка Submit: %v", err)
		return
	}

	prevType, _ := strconv.Atoi(serviceModel.LastSelectedType)
	newType, _ := strconv.Atoi(serviceModel.SelectedClicheType)

	// Если типы совпадают (или не изменились после Submit), ничего не делаем
	if prevType == newType {
		return
	}
	// Защита от некорректных значений
	if prevType < 1 {
		prevType = 1
	}
	if newType < 1 {
		newType = 1
	}

	// logMsg("[CLICHE] Переключение типа: %d -> %d", prevType, newType)

	// 2. СОХРАНЯЕМ ТЕКУЩЕЕ СОСТОЯНИЕ UI В СНАПШОТ (Slot PREV)
	// Данные в таблице сейчас относятся к prevType. Сохраняем их в currentSnapshot.
	var linesToSave []driver.ClicheLineData
	for _, item := range serviceModel.ClicheItems {
		item.updateFormat() // Синхронизируем Format из Props
		linesToSave = append(linesToSave, driver.ClicheLineData{
			Text:   item.Line.Text,
			Format: item.Line.Format,
		})
	}
	currentSnapshot.Cliches[prevType] = linesToSave

	// 3. ЗАГРУЖАЕМ НОВЫЕ ДАННЫЕ ИЗ СНАПШОТА В UI (Slot NEW)
	// Берем данные для нового типа из currentSnapshot (там либо исходные, либо уже измененные)
	newLines := currentSnapshot.Cliches[newType]

	for i := 0; i < 10; i++ {
		var text, format string
		// Если данных меньше 10 строк, заполняем пустыми
		if i < len(newLines) {
			text = newLines[i].Text
			format = newLines[i].Format
		} else {
			text = ""
			format = "000000"
		}

		// Обновляем обертки строк (pointers in slice remain same, content changes)
		serviceModel.ClicheItems[i].Line = cliche.Line{
			Text:   text,
			Format: format,
			Props:  cliche.ParseFormat(format),
		}
	}

	// 4. ОБНОВЛЯЕМ ТРЕКИНГ
	serviceModel.LastSelectedType = serviceModel.SelectedClicheType

	// 5. ОБНОВЛЯЕМ ТАБЛИЦУ
	clicheModel.PublishRowsReset()
	if clicheTable != nil {
		clicheTable.Invalidate()
	}

	// 6. СБРАСЫВАЕМ РЕДАКТОР
	clicheEditorGroup.SetEnabled(false)
	clicheEditorGroup.SetTitle("Настройки строки")

	// 7. ПЕРЕСЧИТЫВАЕМ ИЗМЕНЕНИЯ
	// Теперь в UI загружен newType, а в currentSnapshot сохранен prevType.
	// recalcChanges соберет полный снапшот корректно.
	recalcChanges()
}

func onWriteAllParameters() {
	if len(currentChanges) == 0 {
		return
	}
	confirmed, finalChanges := RunDiffDialog(mw, currentChanges)
	if !confirmed {
		return
	}
	ApplyChangesPipeline(finalChanges)
}

func onTechReset() {
	drv := driver.Active
	if drv == nil {
		return
	}
	if walk.MsgBox(mw, "ВНИМАНИЕ",
		"Выполнить ТЕХНОЛОГИЧЕСКОЕ ОБНУЛЕНИЕ?\nЭто полностью очистит настройки ККТ.",
		walk.MsgBoxYesNo|walk.MsgBoxIconWarning) != walk.DlgCmdYes {
		return
	}
	go func() {
		err := drv.TechReset()
		mw.Synchronize(func() {
			if err != nil {
				walk.MsgBox(mw, "Ошибка", "Сбой тех. обнуления: "+err.Error(), walk.MsgBoxIconError)
			} else {
				walk.MsgBox(mw, "Успех", "Технологическое обнуление выполнено.", walk.MsgBoxIconInformation)
				onReadAllSettings()
			}
		})
	}()
}

func onSyncTime() {
	drv := driver.Active
	if drv == nil {
		return
	}

	// 1. Получаем строку времени из GUI (уже обновленную биндингом или вручную)
	// Для надежности берем прямо из виджета
	var timeStr string
	if targetTimeEdit != nil {
		timeStr = targetTimeEdit.Text()
	} else {
		timeStr = serviceModel.TargetTimeStr
	}

	// 2. Парсим через сервис
	targetTime, err := timeService.ParseTime(timeStr)
	if err != nil {
		walk.MsgBox(mw, "Ошибка", "Некорректный формат времени.\nОжидается: ДД.ММ.ГГГГ ЧЧ:ММ:СС", walk.MsgBoxIconError)
		return
	}

	go func() {
		// 3. Отправляем команду драйверу
		err := drv.SetDateTime(targetTime)
		mw.Synchronize(func() {
			if err != nil {
				walk.MsgBox(mw, "Ошибка", "Ошибка синхронизации: "+err.Error(), walk.MsgBoxIconError)
			} else {
				// Обновляем время ККТ в UI сразу, чтобы пользователь видел результат
				serviceModel.KktTimeStr = timeService.FormatTime(targetTime)
				// Принудительно обновляем лейбл
				if kktTimeLabel != nil {
					kktTimeLabel.SetText(serviceModel.KktTimeStr)
				}
				walk.MsgBox(mw, "Успех", "Время установлено успешно.", walk.MsgBoxIconInformation)
			}
		})
	}()
}

func onRebootDevice() {
	drv := driver.Active
	if drv == nil {
		return
	}
	go func() {
		drv.RebootDevice()
		mw.Synchronize(func() {
			walk.MsgBox(mw, "Инфо", "Команда перезагрузки отправлена", walk.MsgBoxIconInformation)
		})
	}()
}

func onFeedAndCutService() {
	drv := driver.Active
	if drv == nil {
		return
	}
	go func() {
		drv.Feed(5)
		drv.Cut()
	}()
}

func onOpenDrawer() {
	drv := driver.Active
	if drv == nil {
		return
	}
	go func() { drv.DeviceJob(2) }()
}

func onPrintXReport() {
	drv := driver.Active
	if drv == nil {
		return
	}
	go func() { drv.PrintXReport() }()
}

func onMGMReset() {
	drv := driver.Active
	if drv == nil {
		return
	}
	go func() { drv.ResetMGM() }()
}

// reloadEditor загружает данные из выбранной строки списка во временный объект редактора.
func reloadEditor(idx int) {
	srcItem := serviceModel.ClicheItems[idx]

	// Копируем данные в TempClicheLine
	// Важно скопировать значения, а не ссылку, чтобы редактирование не меняло список сразу
	serviceModel.TempClicheLine.Index = srcItem.Index
	serviceModel.TempClicheLine.Line = srcItem.Line // cliche.Line - это struct (value type), копируется по значению

	if clicheEditorBinder != nil {
		clicheEditorBinder.SetDataSource(serviceModel.TempClicheLine)
		clicheEditorBinder.Reset()
	}

	// Обновляем DataBinder редактора
	clicheEditorBinder.Reset()

	clicheEditorGroup.SetEnabled(true)
	clicheEditorGroup.SetTitle(fmt.Sprintf("Настройки строки №%d", idx+1))
}

// onApplyClicheLine вызывается при нажатии кнопки "Применить" в редакторе клише.
func onApplyClicheLine() {
	idx := clicheTable.CurrentIndex()
	if idx < 0 {
		return
	}

	// 1. Ручное чтение значений из виджетов
	newText := ceText.Text()

	// Хелпер для чтения значения из ComboBox через Model и CurrentIndex
	getComboVal := func(cb *walk.ComboBox) int {
		idx := cb.CurrentIndex()
		if idx < 0 {
			return 0
		}

		// Получаем модель виджета и приводим к типу []*NV, который мы использовали при инициализации
		if items, ok := cb.Model().([]*NV); ok {
			if idx < len(items) {
				if i, err := strconv.Atoi(items[idx].Code); err == nil {
					return i
				}
			}
		}
		return 0
	}

	newAlign := getComboVal(ceAlign)
	newFont := getComboVal(ceFont)
	newUnder := getComboVal(ceUnder)

	newWidth := int(ceWidth.Value())
	newHeight := int(ceHeight.Value())
	newInvert := ceInvert.Checked()

	// 2. Обновляем структуру TempClicheLine вручную
	serviceModel.TempClicheLine.Line.Text = newText
	serviceModel.TempClicheLine.Line.Props.Align = newAlign
	serviceModel.TempClicheLine.Line.Props.Font = newFont
	serviceModel.TempClicheLine.Line.Props.Underline = newUnder
	serviceModel.TempClicheLine.Line.Props.Width = newWidth
	serviceModel.TempClicheLine.Line.Props.Height = newHeight
	serviceModel.TempClicheLine.Line.Props.Invert = newInvert

	// Пересчитываем формат (строку "xxxxxx")
	serviceModel.TempClicheLine.updateFormat()

	// 3. Сравниваем с текущим значением в списке
	originalItem := serviceModel.ClicheItems[idx]

	hasChanges := false
	if serviceModel.TempClicheLine.Line.Text != originalItem.Line.Text {
		hasChanges = true
	}
	if serviceModel.TempClicheLine.Line.Format != originalItem.Line.Format {
		hasChanges = true
	}

	if !hasChanges {
		logMsg("Нет изменений в строке %d", idx+1)
		return
	}

	// 4. Применяем изменения в основной список
	originalItem.Line = serviceModel.TempClicheLine.Line

	// 5. Обновляем таблицу и запускаем пересчет изменений
	clicheModel.PublishRowChanged(idx)
	if clicheTable != nil {
		clicheTable.Invalidate()
	}
	recalcChanges()

	// logMsg("Строка %d обновлена в памяти: %s (Format: %s)", idx+1, newText, serviceModel.TempClicheLine.Line.Format)
}

func onClicheSelectionChanged() {
	idx := clicheTable.CurrentIndex()
	if idx < 0 {
		clicheEditorGroup.SetEnabled(false)
		return
	}
	reloadEditor(idx)
}
</file>
